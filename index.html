<!DOCTYPE html>
<html>
 

<!-- === Supabase KV Sync Adapter (no-login, auto-sync) === -->
<script type="module">
// Minimal, no-login cloud persistence by mirroring localStorage to Supabase.
// 1) Create a table in Supabase named: kv_store
//    Columns:
//      key text PRIMARY KEY
//      value jsonb
//      updated_at timestamptz DEFAULT now()
// 2) Turn RLS ON and add permissive policies if you truly want no-login use:
//    - SELECT: USING (true)
//    - INSERT: WITH CHECK (true)
//    - UPDATE: USING (true)  WITH CHECK (true)   // optional; you can omit to prevent edits
//    - DELETE: USING (false)                      // optional; disallow deletes
// 3) Paste your Supabase project URL and anon key below.

import { createClient } from "https://esm.sh/@supabase/supabase-js"

const SUPABASE_URL = window.SUPABASE_URL || "https://qzkzugzfpegozpiqutdv.supabase.co"
const SUPABASE_KEY = window.SUPABASE_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6a3p1Z3pmcGVnb3pwaXF1dGR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4MTc5MDMsImV4cCI6MjA3MTM5MzkwM30.mdFYuFjbRfsILWPkQQmVUCDR7dGqEo-mdPZ6iwolvGk"
const TABLE = "kv_store"
const KNOWN_KEYS = [
  "att_employees_v2","att_records_v2","att_schedules_v2","att_schedules_default",
  "att_projects_v1","att_filter_project_v1","att_overrides_schedules","att_overrides_projects",
  "att_splits_v1","payroll_rates","payroll_reg_hours","payroll_ot_hours","payroll_ot_multiplier",
  "payroll_week_start","payroll_week_end","payroll_deduction_divisor","payroll_sss_table",
  "payroll_loan_sss","payroll_loan_pagibig","payroll_vale","payroll_vale_wed","payroll_hist"
]

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

const __origSetItem = Storage.prototype.setItem
const __origRemoveItem = Storage.prototype.removeItem

async function cloudUpsert(key, value) {
  try {
    // Try upsert
    const { error } = await supabase
      .from(TABLE)
      .upsert({ key, value: tryParse(value) }, { onConflict: "key" })
    if (error) console.warn("Supabase upsert error:", error.message)
  } catch (e) { console.warn("Supabase upsert failed", e) }
}
async function cloudDelete(key) {
  try {
    const { error } = await supabase.from(TABLE).delete().eq("key", key)
    if (error) console.warn("Supabase delete error:", error.message)
  } catch (e) { console.warn("Supabase delete failed", e) }
}
function tryParse(v) {
  try { return JSON.parse(v) } catch { return v }
}

// Write-through on any localStorage change
Storage.prototype.setItem = function(k, v) {
  try { __origSetItem.call(this, k, v) } catch {}
  // Only mirror known keys to reduce noise
  if (KNOWN_KEYS.includes(k)) cloudUpsert(k, v)
}
Storage.prototype.removeItem = function(k) {
  try { __origRemoveItem.call(this, k) } catch {}
  if (KNOWN_KEYS.includes(k)) cloudDelete(k)
}

// On first load, pull from cloud and hydrate localStorage automatically.
// If we detect changes vs. current localStorage, we populate and reload once
// so the rest of the app sees the new data without manual "sync".
;(async function initialHydrate(){
  try {
    const { data, error } = await supabase
      .from(TABLE)
      .select("key, value")
      .in("key", KNOWN_KEYS)
    if (error) { console.warn("Supabase fetch error:", error.message); return }
    let changed = false
    ;(data || []).forEach(row => {
      const k = row.key
      const cloudStr = safeStringify(row.value)
      const cur = localStorage.getItem(k)
      if (cloudStr != null && cloudStr !== cur) {
        try { __origSetItem.call(localStorage, k, cloudStr) } catch {}
        changed = true
      }
    })
    if (changed) {
      // One-time reload to let downstream scripts render with hydrated data
      if (!sessionStorage.getItem("__kv_reloaded")) {
        sessionStorage.setItem("__kv_reloaded","1")
        location.reload()
      }
    }
  } catch (e) { console.warn("Initial hydrate failed", e) }
})()

function safeStringify(v){
  try { return typeof v === "string" ? v : JSON.stringify(v) } catch { return null }
}
</script>
<!-- === / Supabase KV Sync Adapter === -->

  <meta charset="utf-8"/>
  <title>
   Attendance &mdash; Schedules + Ranges (Merged) + Projects
  </title>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <style>
  /*
   * Allow the application to consume the full viewport width so wide tables (like
   * the DTR grid) are not artificially constrained. The original max-width of
   * 1200px caused wide tables to be clipped on larger screens and hid
   * additional columns. Removing the fixed max-width lets the container grow
   * with the window size, and combined with overflow handling on the panel
   * ensures that all columns remain accessible via horizontal scrolling when
   * necessary.
   */
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;max-width:100%;color:#0b1220}
  header{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab-btn{padding:8px 12px;cursor:pointer;border:1px solid #cbd5e1;background:#f8fafc;border-radius:6px}
  .tab-btn.active{background:#0ea5a4;color:#fff}
  section.panel{display:none}
  section.panel.active{display:block;padding-top:8px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  input[type=file],input[type=date],input[type=time],input[type=number],button,select{padding:6px 8px}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border:1px solid #e2e8f0;padding:8px;text-align:center;font-size:13px}
  th{background:#f1f5f9;position:sticky;top:0;z-index:1}
  .missing{background:#ffdede;color:#7a0000;font-weight:700}
  .note{color:#64748b;font-size:13px;margin-top:6px}
  input.cell{width:100%;box-sizing:border-box}
  .small{font-size:12px;color:#64748b}
  .muted{color:#64748b;font-size:12px}
  @media (max-width:800px){th,td{font-size:12px}}
  .section-title{margin-top:12px;margin-bottom:4px;font-weight:700}
  /* Ensure DTR table columns stay visible and don't collapse in Chrome. Allow
     horizontal scrolling if needed by preventing cells from shrinking and
     wrapping. */
  #panelMain {
    overflow-x: auto;
  }
  #panelMain #resultsTable {
    /*
     * Use max-content so the table grows to accommodate all of its columns.
     * This prevents Chrome from collapsing column widths to fit a parent with
     * limited width and ensures that long headers (e.g. "Clock Out 4",
     * "Night Differential") do not disappear. When combined with the
     * overflow-x:auto on #panelMain, a horizontal scrollbar will appear
     * whenever the total table width exceeds the viewport, allowing users to
     * scroll horizontally to view hidden columns.
     */
    table-layout: auto;
    width: max-content;
  }
  #panelMain #resultsTable th,
  #panelMain #resultsTable td {
    white-space: nowrap;
  }

  /* Make the wrapper around the DTR results scrollable on the x-axis. Without
     this wrapper, wide tables can be clipped by parent containers with
     overflow hidden. */
  .results-wrapper {
    overflow-x: auto;
  }
  </style>
  <style>

  /* Hide individual deduction columns in Payroll table (show only Total Deductions) */
  #payrollTab #payrollTable th:nth-child(9),
  #payrollTab #payrollTable td:nth-child(9),
  #payrollTab #payrollTable th:nth-child(10),
  #payrollTab #payrollTable td:nth-child(10),
  #payrollTab #payrollTable th:nth-child(11),
  #payrollTab #payrollTable td:nth-child(11),
  #payrollTab #payrollTable th:nth-child(12),
  #payrollTab #payrollTable td:nth-child(12),
  #payrollTab #payrollTable th:nth-child(13),
  #payrollTab #payrollTable td:nth-child(13),
  #payrollTab #payrollTable th:nth-child(14),
  #payrollTab #payrollTable td:nth-child(14),
  #payrollTab #payrollTable th:nth-child(15),
  #payrollTab #payrollTable td:nth-child(15) { display: none; }

  
/* ===== Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  #panelProjectTotals, #panelProjectTotals * { visibility: visible !important; }
  #panelProjectTotals { position: absolute; left: 0; top: 0; width: 100%; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}
</style>

  <style id="payrollScopedStyles">
  #panelPayroll {
    --border:#e2e8f0; --bg:#f8fafc; --bg2:#f1f5f9; --text:#0b1220;
    --accent:#2563eb; --muted:#64748b;
  }
  #panelPayroll *, #panelPayroll *::before, #panelPayroll *::after { box-sizing:border-box }
  #panelPayroll { color:var(--text) }
  #panelPayroll header { display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;flex-wrap:wrap }
  #panelPayroll h2 { margin:0 }
  #panelPayroll .tabs { display:flex;gap:6px;flex-wrap:wrap }
  #panelPayroll .tab-btn { padding:8px 12px;border:1px solid var(--border);background:white;border-radius:8px;cursor:pointer }
  #panelPayroll .tab-btn.active { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll .tab { display:none }
  #panelPayroll .tab.active { display:block }
  #panelPayroll .controls { display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:10px 0 }
  #panelPayroll label { font-size:12px;color:var(--muted) }
  #panelPayroll input[type=date], 
  #panelPayroll input[type=number], 
  #panelPayroll input[type=text], 
  #panelPayroll select, 
  #panelPayroll button { padding:6px 8px;border:1px solid var(--border);border-radius:6px }
  #panelPayroll button.primary { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll table { border-collapse:collapse;width:100%;margin-top:12px }
  #panelPayroll th, #panelPayroll td { border:1px solid var(--border);padding:8px;text-align:center;font-size:13px }
  #panelPayroll th { background:var(--bg2);position:sticky;top:0;z-index:1 }
  #panelPayroll td.num { text-align:right }
  #panelPayroll input.cell { width:100%;padding:4px;border:1px solid var(--border);border-radius:4px;text-align:right }
  #panelPayroll .note { font-size:12px;color:var(--muted) }
  #panelPayroll .section { background:var(--bg);padding:10px;border:1px solid var(--border);border-radius:10px;margin-top:8px }
  #panelPayroll .danger { color:#b91c1c }
  #panelPayroll .wrap { white-space:normal }

  </style>
  <style id="payroll-tabs-fix">
   #panelPayroll .tab{display:none} #panelPayroll .tab.active{display:block}
  </style>
 
<style>
/* --- Employees: Clean Add Employee UI --- */
#panelEmployees .form-card{
  background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,0.04);margin-bottom:12px;
}
#panelEmployees form{
  display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;align-items:start;
}
#panelEmployees label{display:block;font-size:12px;color:#334155;margin-bottom:6px;font-weight:600;}
#panelEmployees input, #panelEmployees select, #panelEmployees textarea{
  width:100%;padding:10px 12px;border:1px solid #cbd5e1;border-radius:10px;outline:none;
}
#panelEmployees input:focus, #panelEmployees select:focus, #panelEmployees textarea:focus{
  border-color:#64748b;box-shadow:0 0 0 3px rgba(100,116,139,0.15);
}
#panelEmployees input:invalid, #panelEmployees select:invalid, #panelEmployees textarea:invalid{
  border-color:#ef4444;
}
#panelEmployees .form-actions{grid-column:1 / -1;display:flex;gap:10px;justify-content:flex-end;margin-top:2px;}
#panelEmployees button, #panelEmployees input[type="submit"], #panelEmployees input[type="button"]{
  border:1px solid #cbd5e1;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer;background:#f8fafc;
}
#panelEmployees button:hover, #panelEmployees input[type="submit"]:hover, #panelEmployees input[type="button"]:hover{
  filter:brightness(0.98);
}
#panelEmployees .btn-primary{background:#0ea5e9;border-color:#0284c7;color:#fff;}
#panelEmployees .btn-danger{background:#fee2e2;border-color:#fecaca;color:#b91c1c;}
#panelEmployees small.hint{display:block;color:#64748b;margin-top:4px;font-size:11px;}
@media (max-width:1100px){
  #panelEmployees form{grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
}
</style>

<style>

/* ===== Strong Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  section.panel { display: none !important; }
  #panelProjectTotals { 
    position: absolute; left: 0; top: 0; width: 100%;
    display: block !important; 
    visibility: visible !important;
  }
  #panelProjectTotals * { visibility: visible !important; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}

</style>

<style>

/* --- Per-project per page when printing --- */
@media print {
  /* If a project has a breakdown row, break after that row; otherwise break after the project header row */
  #panelProjectTotals tr.proj-emp-breakdown { page-break-after: always; }
  #panelProjectTotals tr.proj-row.no-breakdown { page-break-after: always; }
}

</style>

<style>
#payrollTab #payrollTable tfoot td,
#deductionsTab #deductionsTable tfoot td{ font-weight:700; background:#fff7ed; border-top:2px solid #e2e8f0; }
#payrollTab #payrollTable tfoot td.label-cell,
#deductionsTab #deductionsTable tfoot td.label-cell{ text-align:left; }
#payrollTab #payrollTable tfoot td.num,
#deductionsTab #deductionsTable tfoot td.num{ text-align:right; }
</style>
    <!-- Added payroll dashboard theme -->
    <style>
        /* Override default margins and background */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .app-container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            padding: 30px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }
        .sidebar-header {
            padding: 0 30px 30px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        .logo {
            font-size: 24px;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .nav-menu {
            list-style: none;
            padding: 0 15px;
        }
        .nav-item {
            margin-bottom: 8px;
        }
        .nav-link {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            text-decoration: none;
            color: #6b7280;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        .nav-link:hover {
            background: #f3f4f6;
            color: #374151;
            transform: translateX(5px);
        }
        .nav-link.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 30px;
            /*
             * Permit horizontal scrolling within the main content area. The
             * original style hid any overflow on the x-axis, which meant
             * wide tables (such as the DTR results grid) could not be
             * scrolled into view and appeared to be missing columns. By
             * changing overflow-x to auto, the browser will show a
             * horizontal scrollbar when necessary, ensuring all columns
             * remain accessible.
             */
            overflow-x: auto;
        }
        .content-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .page-title {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .page-subtitle {
            color: #6b7280;
            font-size: 14px;
        }
        .date-range {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .date-input {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
        .date-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .warning-note {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #92400e;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 13px;
            margin-top: 15px;
            border-left: 4px solid #f59e0b;
        }
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block;
            }
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 999;
            }
            .sidebar.active {
                transform: translateX(0);
            }
            .main-content {
                margin-left: 0;
                padding: 80px 20px 20px;
            }
            .date-range {
                justify-content: center;
            }
        }
        /* Hide original top-level navigation tabs but keep payroll sub-tabs visible */
        .tabs { display: none !important; }
        /* Explicitly show the sub-tabs inside the Payroll panel. */
        #panelPayroll .tabs {
            display: flex !important;
        }
    </style>
</head>

<!-- Boot guard to avoid 'storedEmployees is not defined' -->
<script>document.addEventListener('DOMContentLoaded', function(){
(function(){
  try {
    if (typeof window.storedEmployees === 'undefined') {
      window.storedEmployees = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
    }
    if (typeof window.storedRecords === 'undefined') {
      window.storedRecords = JSON.parse(localStorage.getItem('att_records_v2') || '[]');
    }
  } catch (e) { console.warn('Boot guard init failed', e); }
})();
});</script>

  <!-- Mobile menu button for smaller screens -->
  <button class="mobile-menu-btn" onclick="toggleSidebar()">
    <span style="font-size: 20px;">☰</span>
  </button>
  <!-- Begin App Container with Sidebar and Main Content -->
  <div class="app-container">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">
          💼 PayrollHub
        </div>
      </div>
      <nav>
        <ul class="nav-menu">
          <li class="nav-item">
            <button class="nav-link tab-btn active" id="tabDashboard" data-page="dashboard">
              <span class="nav-icon">📊</span>
              Dashboard
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="tabMain" data-page="dtr">
              <span class="nav-icon">🕐</span>
              DTR
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="tabSchedule" data-page="schedules">
              <span class="nav-icon">📅</span>
              Schedules
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="tabEmployees" data-page="employees">
              <span class="nav-icon">👥</span>
              Employees
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="tabProjects" data-page="projects">
              <span class="nav-icon">🚀</span>
              Projects
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="tabPayroll" data-page="payroll">
              <span class="nav-icon">💰</span>
              Payroll
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="tabProjectTotals" data-page="totals">
              <span class="nav-icon">📈</span>
              Reports
            </button>
          </li>
        </ul>
      </nav>
    </aside>
    <main class="main-content">
      <div class="content-header">
        <h1 class="page-title">
          <span style="font-size: 32px;">📊</span>
          Dashboard
        </h1>
        <p class="page-subtitle">Manage your payroll system efficiently</p>
        <!-- Hide the legacy date range controls but keep them in the DOM for backwards compatibility -->
        <div class="date-range" id="dateRangeLegacy" style="display:none">
          <span style="font-weight: 600; color: #374151;">Start:</span>
          <input id="weekStart" type="date" class="date-input">
          <span style="font-weight: 600; color: #374151;">End:</span>
          <input id="weekEnd" type="date" class="date-input">
          <button id="dashGenerate" style="margin-left: 8px;">Generate</button>
        </div>
        <!-- New Active Payroll picker -->
        <div class="date-range" id="activePayrollPicker" style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
          <span style="font-weight:600;color:#374151;">Payroll period:</span>
          <select id="activePayrollSelect" class="date-input activeWeekSelect" style="min-width:260px;"></select>
          <button id="newPayrollPeriod" type="button" class="date-input">New period</button>
        </div>
        <div class="warning-note">
          💾 Data persisted in browser (localStorage). Use Clear to remove.
        </div>
      </div>

      <!-- Begin original content -->

<!-- Original tab buttons and header removed in favour of sidebar navigation -->
  <!-- Dashboard panel to host high-level metrics and payroll history -->
  <section class="panel active" id="panelDashboard">
   <h3>Dashboard</h3>
   <!-- Date range picker and action buttons -->
   <!-- The Generate button has been moved into the date-range picker; retain the controls container for future actions if needed. -->
   <div class="controls"></div>
   <!-- Container for viewing a snapshot or diff results -->
   <div id="snapshotView" style="margin-top:12px;"></div>

   <!-- Active Payrolls table showing all un-locked snapshots -->
   <h4>Active Payrolls</h4>
   <table id="activePayrollTable">
     <thead>
       <tr>
         <th>Start</th>
         <th>End</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <!-- Payroll History table showing all generated/locked snapshots -->
   <h4>Payroll History</h4>
   <table id="historyTable">
     <thead>
       <tr>
         <th>Select</th>
         <th>Start</th>
         <th>End</th>
         <th>Locked At</th>
         <th>Hash</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
     <button id="diffBtn">Diff Selected</button>
   </div>
  </section>

  <!-- Original Main panel (DTR) no longer active by default -->
  <section class="panel" id="panelMain">
<!-- Removed DTR-specific Active Payroll selector -->

   <div class="controls">
    <label>
     Upload .DAT/.TXT (multiple)
     <input accept=".dat,.txt" id="fileInput" multiple="" type="file"/>
    </label>
    <button id="manualDtrBtn">Enter Manual DTR</button>
    <button id="printDtrBtn">Print DTR</button>
    <button id="clearData">
     Clear All Data
    </button>
    <label>
     Project:
     <select id="filterProject" title="Filter by project">
     </select>
    </label>
<button id="downloadCSV" style="display:none">
     Download CSV
    </button>
    <label> Search Name: <input id="dtrSearchName" type="text" placeholder="Type a name" style="width:220px" /></label>
   </div>
   <div class="note">
    Regular hours computed per schedule segments. Grace applies to AM/PM in. OT detected after PM out reference.
   </div>
   <!-- Wrap the results table in a scrollable container so horizontal overflow
        is always visible. Without this wrapper some layouts (especially when
        embedding this page in an iframe or within a limited-width container)
        can hide the horizontal scroll bar and make it appear as if columns
        are missing. -->
   <div class="results-wrapper">
   <!-- DTR Date Finder Controls -->
<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;">
  <label style="display:flex;align-items:center;gap:.35rem;">
    <span>Date:</span>
    <input id="dtrDateFrom" type="date" />
  </label>
  <span>—</span>
  <label>
    <input id="dtrDateTo" type="date" />
  </label>
  <button id="dtrDateClear" type="button">Clear</button>
</div>
<table aria-live="polite" id="resultsTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Project
      </th>
      <th>
       Schedule
      </th>
      <th>
       Date
      </th>
      <th>
       Clock In 1
      </th>
      <th>
       Clock Out 1
      </th>
      <th>
       Clock In 2
      </th>
      <th>
       Clock Out 2
      </th>
      <th>
       OT In
      </th>
      <th>
       OT Out
      </th>
      <th>
       Total Regular Hrs
      </th>
      <th>
       OT Hrs
      </th>
      <th>
       Split
      </th>
      <!-- Added explicit Actions column to ensure consistent header structure -->
      <th class="actions-header">
       Actions
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
   </div>
  </section>
  
  <section class="panel" id="panelSchedule">
   <h3>
    Schedules
   </h3>
   <div class="controls">
    <label>
     Choose schedule:
     <select id="scheduleSelect">
     </select>
    </label>
    <button id="addScheduleBtn">
     Add
    </button>
    <button id="deleteScheduleBtn">
     Delete
    </button>
    <button id="setDefaultScheduleBtn">
     Set Default
    </button>
   </div>
   <div class="section-title">
    Schedule segments
   </div>
   <table id="scheduleTable">
    <thead>
     <tr>
      <th>
       Segment
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       AM
      </td>
      <td>
       <input class="cell" data-key="sch_am_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_am_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       PM
      </td>
      <td>
       <input class="cell" data-key="sch_pm_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_pm_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday</td>
      <td><input class="cell" data-key="sch_sat_start" type="time"/></td>
      <td><input class="cell" data-key="sch_sat_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <label>
     Grace Minutes:
     <input class="cell" data-key="sch_grace" min="0" style="width:90px" type="number"/>
    </label>
    <label style="margin-left:8px">
     Schedule name:
     <input class="cell" id="scheduleName" style="width:200px"/>
    </label>
    <button id="saveScheduleBtn">
     Save
    </button>
   </div>
   <div class="section-title">
    Ranges (detection per schedule)
   </div>
   <table id="rangesTable">
    <thead>
     <tr>
      <th>
       Slot
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       Clock In 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock In 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT In
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT Out
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday OT In</td>
      <td><input class="cell" data-key="rng_sat_ot_start" type="time"/></td>
      <td><input class="cell" data-key="rng_sat_ot_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <button id="saveRangesBtn">
     Save Ranges
    </button>
    <button id="resetRangesBtn">
     Reset Ranges
    </button>
   </div>
  </section>
  
  <section class="panel" id="panelEmployees">
   <h3>
    Employees
   </h3>
   <div class="controls">
    <input class="cell" id="empIdInput" placeholder="ID" style="width:120px"/>
    <input class="cell" id="empNameInput" placeholder="Name" style="width:220px"/>
    <input class="cell" id="empRateInput" min="0" placeholder="Hourly Rate" step="0.01" style="width:140px" type="number"/>
    <input class="cell" id="empBankInput" placeholder="Bank Account" style="width:220px"/>
    <label>
     Schedule:
     <select id="empScheduleSelect">
     </select>
    </label>
    <label>
     Project:
     <select id="empProjectSelect">
     </select>
    </label>
    <button id="addEmployeeBtn">
     Add
    </button>
    <button id="clearEmployeesBtn">
     Clear All Employees
    </button>
   </div>
   <div class="controls" style="margin-top:6px;align-items:center;">
    <label style="font-weight:600">
     Upload employee list (no header):
    </label>
    <input accept=".xlsx,.xls,.csv" id="empFileInput" type="file"/>
    <button id="downloadEmployeesCSV">
     Download Employees CSV
    </button>
    <div class="muted">
     Cols: A = ID, B = Name, C = Hourly Rate (optional), D = Schedule Name (optional), E = Project Name (optional), F = Bank Account (optional). Imported employees get default schedule and no project unless set.
    </div>
   </div>

<div class="controls" style="margin-top:6px;align-items:center;">
  <button id="backupAllBtn">Backup All Data</button>
  <label style="display:flex;gap:8px;align-items:center;">
    Restore All Data:
    <input type="file" id="restoreAllFile" accept="application/json"/>
  </label>
  <small class="hint">Backs up everything stored in localStorage (employees, logs, schedules, projects, payroll, etc.). Restoring will overwrite current data.</small>
</div>

   <table id="employeesTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Hourly Rate
      </th>
      <th>
       Schedule
      </th>
      <th>
       Project
      </th>
      <th>Bank Account</th><th>Action</th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  
  <section class="panel" id="panelProjects">
   <h3>
    Projects
   </h3>
   <div class="controls">
    <input class="cell" id="projectNameInput" placeholder="Project Name" style="width:220px"/>
    <button id="addProjectBtn">
     Add
    </button>
    <button id="clearProjectsBtn">
     Clear All Projects
    </button>
   </div>
   <table id="projectsTable">
    <thead>
     <tr>
      <th>
       Project Name
      </th>
      <th>
       Action
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  <section class="panel" id="panelPayroll">
<!-- Active Payroll selector (non-dashboard) -->
<div class="active-week-bar" style="display:flex;gap:8px;align-items:center;margin:10px 0;">
  <label><strong>Payroll:</strong>
    <select class="activeWeekSelect"></select>
  </label>
  <button type="button" class="refreshActiveWeek">Apply</button>
</div>

   <div id="payrollWrapper">
    <header>
     <h2>
      Payroll
     </h2>
     <div class="tabs">
      <button class="tab-btn active" data-tab="payrollTab">
       Payroll
      </button>
      <button class="tab-btn" data-tab="sssTab">
       SSS Table
      </button>
      <button class="tab-btn" data-tab="deductionsTab">
       Deductions
      </button>
     </div>
    </header>
    <div class="tab active" id="payrollTab">
     <div class="controls">
      <label>
       OT Multiplier
       <br/>
       <input id="otMultiplier" step="0.01" style="width:100px" type="number" value="1.50"/>
      </label>
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisor">
        <option value="1">
         1
        </option>
        <option value="2">
         2
        </option>
        <option value="3">
         3
        </option>
        <option value="4">
         4
        </option>
        <option value="5">
         5
        </option>
       </select>
      </label>
      <div style="flex:1 1 auto">
      </div>
      <button class="primary" id="downloadPayrollCSV">
       Download Payroll CSV
      </button>
      <button id="printPayrollBtn" type="button">
       Print Report
      </button>
     </div>
     <div class="section note">
      Pag-IBIG = Regular Pay &times; 2% &divide; Divisor, PhilHealth = Regular Pay &times; 2.5% &divide; Divisor,
    SSS = (Employee Share by Monthly Income) &divide; Divisor. Loans &amp; Vales are manual (not divided).
     </div>
     <table id="payrollTable">
      <thead>
       <tr>
        <th>
         ID
        </th>
        <th>
         Name
        </th>
        <th>
         Regular Hours
        </th>
        <th>
         OT Hours
        </th>
        <th>
         Hourly Rate
        </th>
        <th>
         Regular Pay
        </th>
        <th>
         OT Pay
        </th>
        <th>
         Gross Pay
        </th>
        <th>
         Pag-IBIG
        </th>
        <th>
         PhilHealth
        </th>
        <th>
         SSS
        </th>
        <th>
         SSS Loan
        </th>
        <th>
         Pag-IBIG Loan
        </th>
        <th>
         Vale
        </th>
        <th>
         Wed Vale
        </th>
        <th>
         Total Deductions
        </th>
        <th>
         Net Pay
        </th>
        <th>
         Payslip
        </th>
       </tr>
      </thead>
      <tbody>
      </tbody>
      <tfoot id="payrollTotalsFoot">
        <tr>
          <td colspan="2" class="label-cell">Grand Total</td>
          <td class="num" data-col="regHrs">0.00</td>
          <td class="num" data-col="otHrs">0.00</td>
          <td class="num" data-col="rate">0.00</td>
          <td class="num" data-col="regPay">0.00</td>
          <td class="num" data-col="otPay">0.00</td>
          <td class="num" data-col="grossPay">0.00</td>
          <td class="num" data-col="pagibig">0.00</td>
          <td class="num" data-col="philhealth">0.00</td>
          <td class="num" data-col="sss">0.00</td>
          <td class="num" data-col="loanSSS">0.00</td>
          <td class="num" data-col="loanPI">0.00</td>
          <td class="num" data-col="vale">0.00</td>
          <td class="num" data-col="valeWed">0.00</td>
          <td class="num" data-col="totalDed">0.00</td>
          <td class="num" data-col="netPay">0.00</td>
          <td></td>
        </tr>
      </tfoot>

     </table>
     <div class="section note">
      Reads employees from localStorage key
      <code>
       att_employees_v2
      </code>
      (id&rarr;{name}). If none found, shows a sample row.
     </div>
    </div>
    <div class="tab" id="sssTab">
     <div class="controls">
      <button id="addSssRow">
       Add Row
      </button>
      <button class="primary" id="resetSss">
       Reset to Defaults (Custom)
      </button>
      <button class="danger" id="clearSss">
       Clear SSS Table
      </button>
      <button id="exportSss">
       Export CSV
      </button>
      <label>
       Import CSV (min,max,employeeShare)
       <br/>
       <input accept=".csv,text/csv" id="importSss" type="file"/>
      </label>
     </div>
     <table id="sssTable">
      <thead>
       <tr>
        <th>
         Range From (₱)
        </th>
        <th>
         Range To (₱)
        </th>
        <th>
         Employee Share (₱)
        </th>
        <th>
         Actions
        </th>
       </tr>
      </thead>
      <tbody>
      </tbody>
     </table>
     <div class="section note">
      Monthly Income = Hourly Rate &times; 8 &times; 24. We pick the row where
      <i>
       min &le; income &le; max
      </i>
      and use the Employee Share.
     </div>
    </div>
    <div class="tab" id="deductionsTab">
     <div class="controls">
      <label>
       Upload Excel/CSV (ID, Pag-IBIG Loan, SSS Loan, Vale, Wed Vale):
       <br/>
       <input accept=".xlsx,.xls,.csv" id="deductionsFileInput" type="file"/>
      </label>
      <button id="exportDeductionsCSV">Export CSV</button>
     </div>
     <div class="section note">
      <strong>File Format:</strong> Use the exported CSV from this table, then edit only these columns:
      <br/>• <strong>Column 6:</strong> SSS Loan (edit this value)
      <br/>• <strong>Column 7:</strong> Pag-IBIG Loan (edit this value)  
      <br/>• <strong>Column 8:</strong> Vale (edit this value)
      <br/>• <strong>Column 9:</strong> Wed Vale (edit this value)
      <br/><strong>Important:</strong> Don't change columns 1-5 or 10 (they're calculated automatically)
      <br/><strong>Note:</strong> If employee names are split into 2 columns, the system automatically adjusts
     </div>
     <table id="deductionsTable">
      <thead>
       <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Pag-IBIG</th>
        <th>PhilHealth</th>
        <th>SSS</th>
        <th>SSS Loan</th>
        <th>Pag-IBIG Loan</th>
        <th>Vale</th>
        <th>Wed Vale</th>
        <th>Total Deductions</th>
       </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="deductionsTable_foot">
        <tr>
          <td class="label-cell" colspan="2">Grand Total</td>
          <td class="num" data-col="pagibig">0.00</td>
          <td class="num" data-col="philhealth">0.00</td>
          <td class="num" data-col="sss">0.00</td>
          <td class="num" data-col="loanSSS">0.00</td>
          <td class="num" data-col="loanPI">0.00</td>
          <td class="num" data-col="vale">0.00</td>
          <td class="num" data-col="valeWed">0.00</td>
          <td class="num" data-col="total">0.00</td>
        </tr>
      </tfoot>

     </table>
    </div>

    <script>
const LS_RATES='payroll_rates', LS_REG_HRS='payroll_reg_hours', LS_OT_HRS='payroll_ot_hours';
const LS_OTMULT='payroll_ot_multiplier', LS_WEEKSTART='payroll_week_start', LS_WEEKEND='payroll_week_end';
const LS_DIVISOR='payroll_deduction_divisor', LS_SSS_TABLE='payroll_sss_table';
const LS_LOAN_SSS='payroll_loan_sss', LS_LOAN_PI='payroll_loan_pagibig';
const LS_VALE='payroll_vale', LS_VALE_WED='payroll_vale_wed';
const SSS_SEED_2025 = [
  [1, 5249.99, 250],
  [5250, 5749.99, 275],
  [5750, 6249.99, 300],
  [6250, 6749.99, 325],
  [6750, 7249.99, 350],
  [7250, 7749.99, 375],
  [7750, 8249.99, 400],
  [8250, 8749.99, 425],
  [8750, 9249.99, 450],
  [9250, 9749.99, 475],
  [9750, 10249.99, 500],
  [10250, 10749.99, 525],
  [10750, 11249.99, 550],
  [11250, 11749.99, 575],
  [11750, 12249.99, 600],
  [12250, 12749.99, 625],
  [12750, 13249.99, 650],
  [13250, 13749.99, 675],
  [13750, 14249.99, 700],
  [14250, 14749.99, 725],
  [14750, 15249.99, 750],
  [15250, 15749.99, 775],
  [15750, 16249.99, 800],
  [16250, 16749.99, 825],
  [16750, 17249.99, 850],
  [17250, 17749.99, 875],
  [17750, 18249.99, 900],
  [18250, 18749.99, 925],
  [18750, 19249.99, 950],
  [19250, 19749.99, 975],
  [19750, 20249.99, 1000],
  [20250, 20749.99, 1025],
  [20750, 21249.99, 1050],
  [21250, 21749.99, 1075],
  [21750, 22249.99, 1100],
  [22250, 22749.99, 1125],
  [22750, 23249.99, 1150],
  [23250, 23749.99, 1175],
  [23750, 24249.99, 1200],
  [24250, 24749.99, 1225],
  [24750, 25249.99, 1250],
  [25250, 25749.99, 1275],
  [25750, 26249.99, 1300],
  [26250, 26749.99, 1325],
  [26750, 27249.99, 1350],
  [27250, 27749.99, 1375],
  [27750, 28249.99, 1400],
  [28250, 28749.99, 1425],
  [28750, 29249.99, 1450],
  [29250, 29749.99, 1475],
  [29750, 30249.99, 1500],
  [30250, 30749.99, 1525],
  [30750, 31249.99, 1550],
  [31250, 31749.99, 1575],
  [31750, 32249.99, 1600],
  [32250, 32749.99, 1625],
  [32750, 33249.99, 1650],
  [33250, 33749.99, 1675],
  [33750, 34249.99, 1700],
  [34250, 34749.99, 1725],
  [34750, 100000000, 1750]
];

function ensureSeededSSS() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
      localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
    localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededSSS();
let payrollRates = JSON.parse(localStorage.getItem(LS_RATES) || '{}');
let regHours = JSON.parse(localStorage.getItem(LS_REG_HRS) || '{}');
let otHours = JSON.parse(localStorage.getItem(LS_OT_HRS) || '{}');
let loanSSS = JSON.parse(localStorage.getItem(LS_LOAN_SSS) || '{}');
let loanPI = JSON.parse(localStorage.getItem(LS_LOAN_PI) || '{}');
let vale = JSON.parse(localStorage.getItem(LS_VALE) || '{}');
let valeWed = JSON.parse(localStorage.getItem(LS_VALE_WED) || '{}');

let otMultiplier = parseFloat(localStorage.getItem(LS_OTMULT)) || 1.50;
let weekStartSaved = localStorage.getItem(LS_WEEKSTART) || '';
let weekEndSaved = localStorage.getItem(LS_WEEKEND) || '';
let divisor = parseInt(localStorage.getItem(LS_DIVISOR) || '1', 10);
const weekStartEl = document.getElementById('weekStart');
const weekEndEl = document.getElementById('weekEnd');
const otMultiplierEl = document.getElementById('otMultiplier');
const divisorEl = document.getElementById('deductionDivisor');
const tbody = document.querySelector('#payrollTable tbody');
document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('#panelPayroll .tab').forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    const panel = document.querySelector('#panelPayroll #' + btn.dataset.tab);
    if (panel) panel.classList.add('active');
  });
});
otMultiplierEl.value = otMultiplier;
weekStartEl.value = weekStartSaved;
weekEndEl.value = weekEndSaved;
divisorEl.value = divisor;

otMultiplierEl.addEventListener('input', ()=>{ otMultiplier = parseFloat(otMultiplierEl.value)||0; localStorage.setItem(LS_OTMULT, otMultiplier); calculateAll(); });
weekStartEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKSTART, weekStartEl.value));
weekEndEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKEND, weekEndEl.value));
divisorEl.addEventListener('change', ()=>{ divisor = parseInt(divisorEl.value,10)||1; localStorage.setItem(LS_DIVISOR, String(divisor)); calculateAll(); });
function loadEmployees() {
  const stored = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
  let list = Object.keys(stored).map(id=>({id, name: stored[id]?.name || ''}));
  if (list.length === 0) list = [{id:'001', name:'Sample Employee'}];
  list.sort((a,b)=> (a.name||'').localeCompare(b.name||''));
  return list;
}
const employeeList = loadEmployees();
function getSssTable(){
  let arr = [];
  try { arr = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]'); }
  catch(e){ arr = []; }
  if (!Array.isArray(arr)) arr = [];
  arr = arr.map(r=>({min:Number(r.min)||0, max:Number(r.max)||0, employee:Number(r.employee)||0}))
           .sort((a,b)=> a.min - b.min);
  return arr;
}
function setSssTable(rows){
  localStorage.setItem(LS_SSS_TABLE, JSON.stringify(rows));
}

function renderDeductionsTable(){
  const dtbody = document.querySelector('#deductionsTable tbody');
  if (!dtbody) return;
  dtbody.innerHTML = '';
  employeeList.forEach(emp => {
    const rH = Number(regHours[emp.id] ?? 0);
    const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
    payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
const lSSS = Number(loanSSS[emp.id] ?? 0);
    const lPI = Number(loanPI[emp.id] ?? 0);
    const v = Number(vale[emp.id] ?? 0);
    const vW = Number(valeWed[emp.id] ?? 0);
    const regPay = +(rH * rate).toFixed(2);
    const pagibig = +(regPay * 0.02).toFixed(2);
    const philhealth = +(regPay * 0.025).toFixed(2);
    const monthly = rate * 8 * 24;
    const sssFull = sssShareByMonthly(monthly);
    const sss = +(sssFull / (Number(divisor)||1)).toFixed(2);
    const sssLoan = +(lSSS / (Number(divisor)||1)).toFixed(2);
    const piLoan = +(lPI / (Number(divisor)||1)).toFixed(2);
    const total = +(pagibig + philhealth + sss + sssLoan + piLoan + v + vW).toFixed(2);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${emp.id}</td><td class="wrap">${emp.name}</td>
      <td class="num">${pagibig.toFixed(2)}</td>
      <td class="num">${philhealth.toFixed(2)}</td>
      <td class="num">${sss.toFixed(2)}</td>
      <td class="num">${sssLoan.toFixed(2)}</td>
      <td class="num">${piLoan.toFixed(2)}</td>
      <td class="num">${v.toFixed(2)}</td>
      <td class="num">${vW.toFixed(2)}</td>
      <td class="num">${total.toFixed(2)}</td>`;
    dtbody.appendChild(tr);
  });
}
document.addEventListener('click', (e)=>{
  if(e.target && e.target.id === 'exportDeductionsCSV'){
    const header = ['ID','Name','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Deductions'];
    const rows=[header];
    document.querySelectorAll('#deductionsTable tbody tr').forEach(tr=>{
      const cells = Array.from(tr.children).map(td=>td.textContent.trim());
      rows.push(cells);
    });
    const csv = rows.map(r=>r.map(s=>{
      s = String(s ?? '');
      return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    }).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='deductions.csv'; document.body.appendChild(a); a.click(); a.remove();
  }
});

// Handle deductions file upload
document.addEventListener('change', (e)=>{
  if(e.target && e.target.id === 'deductionsFileInput'){
    const file = e.target.files && e.target.files[0]; 
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        let rows = [];
        
        // Check if employeeList is available
        if (!employeeList || employeeList.length === 0) {
          alert('No employees found. Please add employees first in the Employees tab.');
          return;
        }
        
        console.log('Available employees:', employeeList.map(e => e.id));
        
        if (file.name.toLowerCase().endsWith('.csv')) {
          // Handle CSV files
          
          const text = String(e.target.result || '');
          // Robust CSV parsing with quoted field support
          rows = text.split(/\r?\n/).filter(line => line.trim().length>0).map(line => {
            const out = []; let cur = ''; let inQ = false;
            for (let i=0;i<line.length;i++){
              const ch = line[i]; const nx = line[i+1];
              if (ch === '"'){
                if (inQ && nx === '"'){ cur += '"'; i++; } 
                else { inQ = !inQ; }
              } else if (ch === ',' && !inQ){
                out.push(cur); cur = '';
              } else {
                cur += ch;
              }
            }
            out.push(cur);
            return out.map(cell => cell.trim());
          });
    } else {
          // Handle Excel files
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        }
        
        if (rows.length < 2) {
          alert('File must have at least a header row and one data row.');
          return;
        }
        
        // Process the data
        let updated = 0;
        let errors = [];
        
        console.log('Processing file with rows:', rows.length);
        console.log('First row (headers):', rows[0]);
        console.log('Second row (sample data):', rows[1]);
        
        
        // Map column indexes by header names to tolerate column reordering
        const header = rows[0].map(h => String(h).trim().toLowerCase());
        const IDX = {
          id: header.indexOf('id'),
          name: header.indexOf('name'),
          sssloan: header.indexOf('sss loan'),
          pagibigloan: header.indexOf('pag-ibig loan'),
          vale: header.indexOf('vale'),
          wedvale: header.indexOf('wed vale')
        };
        const req = ['id','sssloan','pagibigloan','vale','wedvale'];
        for (const k of req){ if (IDX[k] < 0){ alert('Upload missing column: ' + k); return; } }
for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (row.length < 10) {
            console.log(`Row ${i} too short (${row.length} columns):`, row);
            continue;
          }
          
          const empId = String(row[0] || '').trim();
          
          // Only read the specific columns we need for loans and vales
          // Skip the calculated fields (Pag-IBIG, PhilHealth, SSS, Total Deductions)
          // Note: If name is split into 2 columns, adjust accordingly
          const sssLoan = parseFloat(row[IDX.sssloan]) || 0; const pagibigLoan = parseFloat(row[IDX.pagibigloan]) || 0; const valeVal = parseFloat(row[IDX.vale]) || 0; const wedValeVal = parseFloat(row[IDX.wedvale]) || 0;       // Column 9: Wed Vale (was 8)
          
          console.log(`Row ${i}: ID=${empId}, SSS Loan=${sssLoan}, Pag-IBIG Loan=${pagibigLoan}, Vale=${valeVal}, Wed Vale=${wedValeVal}`);
          
          if (!empId) continue;
          
          // Check if employee exists in employeeList
          const employeeExists = employeeList.some(emp => emp.id === empId);
          if (employeeExists) {
            // Update the loan and vale amounts
            loanPI[empId] = pagibigLoan;
            loanSSS[empId] = sssLoan;
            vale[empId] = valeVal;
            valeWed[empId] = wedValeVal;
            updated++;
            console.log(`Updated employee ${empId}:`, { pagibigLoan, sssLoan, vale: valeVal, wedVale: wedValeVal });
          } else {
            errors.push(`Employee ID ${empId} not found`);
            console.log(`Employee ${empId} not found in:`, employeeList.map(e => e.id));
          }
        }
        
        // Save to localStorage
        localStorage.setItem(LS_LOAN_PI, JSON.stringify(loanPI));
        localStorage.setItem(LS_LOAN_SSS, JSON.stringify(loanSSS));
        localStorage.setItem(LS_VALE, JSON.stringify(vale));
        localStorage.setItem(LS_VALE_WED, JSON.stringify(valeWed));
        
        // Refresh displays
        if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
        if (typeof renderTable === 'function') renderTable();
        
        // Show results
        let message = `Updated ${updated} employees.`;
        if (errors.length > 0) {
          message += `\n\nErrors:\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) message += `\n...and ${errors.length - 5} more.`;
        }
        alert(message);
        
      } catch (err) { 
        console.error(err); 
        alert('Error reading file. Please check the file format.'); 
      } finally { 
        e.target.value = ''; 
      }
    };
    
    if (file.name.toLowerCase().endsWith('.csv')) {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  }
});
function renderTable(){
  tbody.innerHTML = '';
  employeeList.forEach(emp=>{
    const tr = document.createElement('tr');
    const rH = Number(regHours[emp.id] ?? 0);
    const oH = Number(otHours[emp.id] ?? 0);
    const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
    payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
const lSSS = Number(loanSSS[emp.id] ?? 0);
    const lPI = Number(loanPI[emp.id] ?? 0);
    const v = Number(vale[emp.id] ?? 0);
    const vW = Number(valeWed[emp.id] ?? 0);
    tr.innerHTML = `
      <td>${emp.id}</td>
      <td class="wrap">${emp.name}</td>
      <td><input class="cell regHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${rH}" readonly></td>
      <td><input class="cell otHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${oH}" readonly></td>
      <td><input class="cell rate" title="Non-editable in Payroll" type="number" step="0.01" value="${rate}" readonly></td>
      <td class="regPay num">0.00</td>
      <td class="otPay num">0.00</td>
      <td class="grossPay num">0.00</td>
      <td class="pagibig num">0.00</td>
      <td class="philhealth num">0.00</td>
      <td class="sss num">0.00</td>
      <td><input class="cell loanSSS" type="number" step="0.01" value="${lSSS}"></td>
      <td><input class="cell loanPI" type="number" step="0.01" value="${lPI}"></td>
      <td><input class="cell vale" type="number" step="0.01" value="${v}"></td>
      <td><input class="cell valeWed" type="number" step="0.01" value="${vW}"></td>
      <td class="totalDed num">0.00</td>
      <td class="netPay num">0.00</td>
      <td><button type="button" class="payslipBtn">Payslip</button></td>`;
    tbody.appendChild(tr);
  });
  attachRowEvents();
  calculateAll();
}

function attachRowEvents(){
  tbody.querySelectorAll('tr').forEach(row=>{
    const id = row.cells[0].textContent.trim();
    const regI = row.querySelector('.regHrs');
    const otI = row.querySelector('.otHrs');
    const rateI = row.querySelector('.rate');
    const lSSSI = row.querySelector('.loanSSS');
    const lPII = row.querySelector('.loanPI');
    const vI = row.querySelector('.vale');
    const vWI = row.querySelector('.valeWed');
    [regI, otI, rateI, lSSSI, lPII, vI, vWI].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        regHours[id] = +(Number(regI.value)||0).toFixed(2);
        otHours[id] = +(Number(otI.value)||0).toFixed(2);
        payrollRates[id] = +(Number(rateI.value)||0).toFixed(2);
        loanSSS[id] = +(Number(lSSSI.value)||0).toFixed(2);
        loanPI[id] = +(Number(lPII.value)||0).toFixed(2);
        vale[id] = +(Number(vI.value)||0).toFixed(2);
        valeWed[id] = +(Number(vWI.value)||0).toFixed(2);
        localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
        localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
        localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
        localStorage.setItem(LS_LOAN_SSS, JSON.stringify(loanSSS));
        localStorage.setItem(LS_LOAN_PI, JSON.stringify(loanPI));
        localStorage.setItem(LS_VALE, JSON.stringify(vale));
        localStorage.setItem(LS_VALE_WED, JSON.stringify(valeWed));
        calculateRow(row);
      });
    });
  });
}
function renderSssTable(){
  const tbodyS = document.querySelector('#sssTable tbody');
  tbodyS.innerHTML='';
  const rows = getSssTable();
  rows.forEach((r, i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell sssMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell sssMax" value="${r.max}"></td>
      <td><input type="number" step="0.01" class="cell sssEmp" value="${r.employee}"></td>
      <td><button class="delRow">Delete</button></td>`;
    tbodyS.appendChild(tr);
    const minI = tr.querySelector('.sssMin');
    const maxI = tr.querySelector('.sssMax');
    const empI = tr.querySelector('.sssEmp');
    minI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    maxI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    empI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    tr.querySelector('.delRow').addEventListener('click', ()=>{
      const cur = getSssTable();
      cur.splice(i,1);
      setSssTable(cur);
      renderSssTable();
      calculateAll();
    });
  });
}
function updateRow(i, minI, maxI, empI){
  const cur = getSssTable();
  cur[i] = {min:Number(minI.value)||0, max:Number(maxI.value)||0, employee:Number(empI.value)||0};
  setSssTable(cur);
  calculateAll();
}

document.getElementById('addSssRow').addEventListener('click', ()=>{
  const cur = getSssTable(); cur.push({min:0,max:0,employee:0}); setSssTable(cur); renderSssTable();
});
document.getElementById('resetSss').addEventListener('click', ()=>{
  if(confirm('Reset SSS table to 2025 defaults?')){
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
    setSssTable(mapped);
    renderSssTable();
    calculateAll();
  }
});
document.getElementById('clearSss').addEventListener('click', ()=>{
  if(confirm('Clear all SSS ranges?')){ setSssTable([]); renderSssTable(); calculateAll(); }
});
document.getElementById('exportSss').addEventListener('click', ()=>{
  const rows = getSssTable();
  const csv = ['min,max,employeeShare'].concat(rows.map(r=>[r.min,r.max,r.employee].join(','))).join('\n');
  const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='sss_table.csv'; document.body.appendChild(a); a.click(); a.remove();
});
document.getElementById('importSss').addEventListener('change', ev=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = e=>{
    const text = e.target.result;
    const lines = text.split(/\r?\n/).filter(Boolean);
    const out=[];
    for(let i=0;i<lines.length;i++){ const line = lines[i].trim();
      if(i===0 && /min/i.test(line) && /max/i.test(line)) continue;
      const p = line.split(',');
      if(p.length>=3) out.push({min:Number(p[0])||0,max:Number(p[1])||0,employee:Number(p[2])||0});
    }
    setSssTable(out); renderSssTable(); calculateAll();
  };
  reader.readAsText(f);
});
function sssShareByMonthly(monthly){
  const rows = getSssTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].employee)||0;
  for(const r of rows){ if(monthly >= r.min && monthly <= r.max) return Number(r.employee)||0; }
  return Number(rows[rows.length-1].employee)||0;
}

function calculateRow(tr){
  const id = tr.cells[0].textContent.trim();
  const reg = Number(tr.querySelector('.regHrs').value)||0;
  const ot = Number(tr.querySelector('.otHrs').value)||0;
  const rate = Number(tr.querySelector('.rate').value)||0;
  const lSSS = Number(tr.querySelector('.loanSSS').value)||0;
  const lPI = Number(tr.querySelector('.loanPI').value)||0;
  const v = Number(tr.querySelector('.vale').value)||0;
  const vW = Number(tr.querySelector('.valeWed').value)||0;

  const regPay = +(reg * rate).toFixed(2);
  const otPay = +(ot * rate * (Number(otMultiplier)||0)).toFixed(2);
  const gross = +(regPay + otPay).toFixed(2);
  const pagibig = +(regPay * 0.02).toFixed(2);
  const philhealth = +(regPay * 0.025).toFixed(2);
  const monthly = rate * 8 * 24;
  const sssFull = sssShareByMonthly(monthly);
  const sss = sssFull / (Number(divisor)||1);
  const sssLoan = lSSS / (Number(divisor)||1);
  const piLoan = lPI / (Number(divisor)||1);
  const valeAmt = v;
  const wedValeAmt = vW;

  const total = pagibig + philhealth + sss + sssLoan + piLoan + valeAmt + wedValeAmt;
  const net = gross - total;

  tr.querySelector('.regPay').textContent = regPay.toFixed(2);
  tr.querySelector('.otPay').textContent = otPay.toFixed(2);
  tr.querySelector('.grossPay').textContent = gross.toFixed(2);
  tr.querySelector('.pagibig').textContent = pagibig.toFixed(2);
  tr.querySelector('.philhealth').textContent = philhealth.toFixed(2);
  tr.querySelector('.sss').textContent = sss.toFixed(2);
  tr.querySelector('.totalDed').textContent = total.toFixed(2);
  tr.querySelector('.netPay').textContent = net.toFixed(2);
}

function calculateAll(){
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=> calculateRow(tr));
  renderDeductionsTable();
}
document.getElementById('downloadPayrollCSV').addEventListener('click', ()=>{
  const header = ['Week Start','Week End','OT Multiplier','Divisor','ID','Name','Regular Hours','OT Hours','Hourly Rate','Regular Pay','OT Pay','Gross Pay','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Deductions','Net Pay'];
  const rows=[header];
  const ws = weekStartEl.value||''; const we = weekEndEl.value||''; const otm = String(otMultiplierEl.value||''); const div = String(divisorEl.value||'1');
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
    const tds = tr.querySelectorAll('td');
    const id = tds[0].textContent.trim(); const name = tds[1].textContent.trim();
    const regI = tr.querySelector('.regHrs'); const otI = tr.querySelector('.otHrs'); const rateI = tr.querySelector('.rate');
    const regPay = tr.querySelector('.regPay').textContent.trim();
    const otPay = tr.querySelector('.otPay').textContent.trim();
    const grossPay = tr.querySelector('.grossPay').textContent.trim();
    const pagibig = tr.querySelector('.pagibig').textContent.trim();
    const philhealth = tr.querySelector('.philhealth').textContent.trim();
    const sss = tr.querySelector('.sss').textContent.trim();
    const lSSS = tr.querySelector('.loanSSS').value; const lPI = tr.querySelector('.loanPI').value;
    const v = tr.querySelector('.vale').value; const vW = tr.querySelector('.valeWed').value;
    const total = tr.querySelector('.totalDed').textContent.trim(); const net = tr.querySelector('.netPay').textContent.trim();
    rows.push([ws,we,otm,div,id,name,regI.value,otI.value,rateI.value,regPay,otPay,grossPay,pagibig,philhealth,sss,lSSS,lPI,v,vW,total,net]);
  });
  const csv = rows.map(r=>r.map(s=>{
    s = String(s ?? '');
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='payroll.csv'; document.body.appendChild(a); a.click(); a.remove();
});
renderTable();
renderSssTable();
    
  // Wire Project Totals CSV download button (global)
  if (document.getElementById('downloadProjectTotalsCSV')) {
    document.getElementById('downloadProjectTotalsCSV').addEventListener('click', exportProjectTotalsCSV);
  }
</script>

<!-- Modal report functionality for project totals -->
<script>
// Display a modal dialog with a detailed breakdown of a single project's totals.
// Takes a row object (result of computeProjectTotals) and builds a table of
// per-day hours per employee along with grand totals for regular hours, OT,
// total hours and gross pay. Uses the global weekStart/weekEnd inputs to
// construct the day labels. The modal is hidden by default and can be
// dismissed by clicking on the close button or outside the modal.
function showProjectReport(row) {
  if (!row || !row.breakdown || !row.breakdown.length) return;
  const modal = document.getElementById('projectReportModal');
  const content = document.getElementById('projectReportContent');
  if (!modal || !content) return;
  const wsEl = document.getElementById('weekStart');
  const weEl = document.getElementById('weekEnd');
  const startDate = wsEl && wsEl.value ? wsEl.value : '';
  const endDate = weEl && weEl.value ? weEl.value : '';
  // Helper to build a list of dates between start and end inclusive
  function dateRangeList(s, e) {
    const out = [];
    if (!s || !e) return out;
    const sd = new Date(s);
    const ed = new Date(e);
    for (let d = new Date(sd); d <= ed; d.setDate(d.getDate() + 1)) {
      out.push(new Date(d));
    }
    return out;
  }
  const days = dateRangeList(startDate, endDate);
  let html = '';
  html += '<h3 style="margin-top:0;">' + (row.project || 'Project') + ' (' + (startDate || '') + ' to ' + (endDate || '') + ')</h3>';
  html += '<div style="overflow-x:auto;">';
  html += '<table style="width:100%;border-collapse:collapse;margin-bottom:12px;">';
  html += '<thead><tr>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">ID</th>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">Name</th>';
  days.forEach(function(dt) {
    const label = (dt.getMonth() + 1) + '/' + dt.getDate();
    html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + label + '</th>';
  });
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Hrs</th>';
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Amount</th>';
  html += '</tr></thead><tbody>';
  row.breakdown.forEach(function(emp) {
    html += '<tr>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.id || '') + '</td>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.name || '') + '</td>';
    days.forEach(function(dt) {
      const key = dt.toISOString().slice(0, 10);
      const val = parseFloat((emp.perDay && emp.perDay[key]) || 0).toFixed(2);
      html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + val + '</td>';
    });
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.total || 0).toFixed(2)) + '</td>';
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.gross || 0).toFixed(2)) + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  html += '</div>';
  // Grand totals section
  html += '<div style="font-weight:600;">Grand Totals:</div>';
  html += '<table style="border-collapse:collapse;margin-top:4px;">';
  html += '<tr><td style="padding:4px;">Regular Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.reg || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">OT Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.ot || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Total Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.total || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Gross Amount:</td><td style="padding:4px;text-align:right;">' + ((row.gross != null) ? Number(row.gross).toFixed(2) : '0.00') + '</td></tr>';
  html += '</table>';
  content.innerHTML = html;
  modal.style.display = 'flex';
}
// Attach close handlers once DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('projectReportModal');
  const closeBtn = document.getElementById('closeProjectReport');
  if (closeBtn) closeBtn.addEventListener('click', function() { if (modal) modal.style.display = 'none'; });
  if (modal) modal.addEventListener('click', function(e) { if (e.target === modal) modal.style.display = 'none'; });
});
</script>

<!--
  Dashboard functionality
  This script defines utilities for managing payroll history snapshots. It is intentionally
  separated from the existing payroll logic to avoid altering core calculations.
  The dashboard allows users to select a date range, generate a snapshot of the current payroll table,
  lock it to prevent further edits, view past snapshots, download CSV versions, and compare (diff) two snapshots.
-->
<script>
// Print Payroll Report: generate a print-friendly view of the payroll table and open
// a new window for printing. Inputs are converted to plain text and the final
// payslip column is removed to preserve confidentiality.
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('printPayrollBtn');
  if (btn) btn.addEventListener('click', function(){
    const srcTable = document.getElementById('payrollTable');
    if (!srcTable) {
      alert('Payroll table is missing or empty.');
      return;
    }
    // Clone table so we can modify it without affecting the live DOM
    const clone = srcTable.cloneNode(true);
    // Remove the last column (Payslip) from thead, tbody and tfoot
    const removeLastCell = row => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
    clone.querySelectorAll('thead tr').forEach(removeLastCell);
    clone.querySelectorAll('tbody tr').forEach(removeLastCell);
    clone.querySelectorAll('tfoot tr').forEach(removeLastCell);
    // Convert input fields to plain text within the cloned table
    clone.querySelectorAll('input').forEach(inp => {
      const td = inp.parentElement;
      const val = (inp.value || inp.textContent || '').toString();
      td.textContent = val;
    });
    // Build a new window for printing
    const w = window.open('', '', 'width=900,height=700');
    if (!w) return;
    w.document.write('<html><head><meta charset="utf-8"><title>Payroll Report</title>');
    // Basic styles: borders and alignment
    w.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;margin:20px;} table{border-collapse:collapse;width:100%;} th,td{border:1px solid #ddd;padding:6px;} th{background:#f1f5f9;} td.num{text-align:right;} th:nth-child(1),td:nth-child(1),th:nth-child(2),td:nth-child(2){text-align:left;} tfoot td{font-weight:700;background:#fff7ed;border-top:2px solid #e2e8f0;} </style>');
    w.document.write('</head><body>');
    // Header with date range if available
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const startDate = ws && ws.value ? ws.value : '';
    const endDate = we && we.value ? we.value : '';
    if (startDate && endDate) {
      w.document.write('<h2>Payroll Report (' + startDate + ' to ' + endDate + ')</h2>');
    } else {
      w.document.write('<h2>Payroll Report</h2>');
    }
    w.document.write(clone.outerHTML);
    w.document.write('</body></html>');
    w.document.close();
    w.focus();
    w.print();
    // Optionally close after printing (comment out if you don't want auto-close)
    // w.close();
  });
});
document.addEventListener('DOMContentLoaded', () => {
  // Key used to persist payroll history snapshots in localStorage
  const PAYROLL_HIST_KEY = 'payroll_hist';
  // Load existing history from localStorage or default to an empty array
  let payrollHistory;
  try {
    payrollHistory = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
    if (!Array.isArray(payrollHistory)) payrollHistory = [];
  } catch (err) {
    payrollHistory = [];
  }
  // Expose payrollHistory on the window so other scripts (like the Active Payroll dropdown) can
  // append to it directly. Without this, new snapshots added via custom UI would only update
  // localStorage and would not appear in the current session until a full page reload.
  window.payrollHistory = payrollHistory;
  // Grab references to dashboard elements
  // Use the global weekStart/weekEnd inputs instead of the removed dashStartDate/dashEndDate fields.
  const dashStart = document.getElementById('weekStart');
  const dashEnd = document.getElementById('weekEnd');
  const dashGenerateBtn = document.getElementById('dashGenerate');
  // The global lock button has been removed; per-row lock buttons are provided in the Active Payrolls table.
  const dashLockBtn = document.getElementById('dashLock');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const snapshotView = document.getElementById('snapshotView');
  const diffBtn = document.getElementById('diffBtn');

  // Reference to the Active Payrolls table body
  const activeTableBody = document.querySelector('#activePayrollTable tbody');

  /**
   * Render the active payrolls table.
   * Lists snapshots that are not yet locked with Edit and Lock actions.
   */
  window.renderActivePayrolls = function renderActivePayrolls() {
    if (!activeTableBody) return;
    activeTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      if (snap.locked) return;
      const tr = document.createElement('tr');
      // Build the Active Payroll row. Include Edit, Lock and Delete actions. Deleting
      // prompts confirmation and removes the snapshot from payrollHistory.
      tr.innerHTML = `
        <td>${snap.startDate || ''}</td>
        <td>${snap.endDate || ''}</td>
        <td>
          <button type="button" class="editActive" data-index="${index}">Edit</button>
          <button type="button" class="lockActive" data-index="${index}">Lock</button>
          <button type="button" class="deleteActive" data-index="${index}">Delete</button>
        </td>
      `;
      activeTableBody.appendChild(tr);
    });
  };

  // Delegate edit/lock actions on the Active Payrolls table
  activeTableBody && activeTableBody.addEventListener('click', async (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('editActive')) {
      // Set the global date range to the snapshot dates and switch to Payroll tab
      const wsEl = document.getElementById('weekStart');
      const weEl = document.getElementById('weekEnd');
      if (wsEl) wsEl.value = snap.startDate || '';
      if (weEl) weEl.value = snap.endDate || '';
      try { if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords(); } catch (err) {}
      // Show the payroll panel
      try { showTab('payroll'); } catch (err) {}
    } else if (target.classList.contains('lockActive')) {
      // Lock this active payroll: update its snapshot and mark locked
      const startDate = snap.startDate;
      const endDate = snap.endDate;
      if (!startDate || !endDate) {
        alert('Invalid snapshot dates.');
        return;
      }
      const newSnap = await buildSnapshot(startDate, endDate);
      if (!newSnap) {
        alert('Payroll table is missing or empty.');
        return;
      }
      const json = JSON.stringify(newSnap);
      const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      const now = new Date().toISOString();
      snap.rows = newSnap.rows;
      snap.totals = newSnap.totals;
      snap.hash = hashHex;
      snap.lockedAt = now;
      snap.locked = true;
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      // Disable payroll inputs and dashboard controls until date range changes
      document.querySelectorAll('#panelPayroll input').forEach(inp => { inp.disabled = true; });
      const wsEl2 = document.getElementById('weekStart');
      const weEl2 = document.getElementById('weekEnd');
      const genBtn = document.getElementById('dashGenerate');
      if (wsEl2) {
        wsEl2.disabled = true;
        wsEl2.dataset.forced = 'true';
      }
      if (weEl2) {
        weEl2.disabled = true;
        weEl2.dataset.forced = 'true';
      }
      if (genBtn) genBtn.disabled = true;
      function enableOnChange() {
        if (wsEl2) wsEl2.removeEventListener('change', enableOnChange);
        if (weEl2) weEl2.removeEventListener('change', enableOnChange);
        document.querySelectorAll('#panelPayroll input').forEach(inp => { inp.disabled = false; });
        // Remove forced flags and re-enable date range and generate button
        if (wsEl2) {
          delete wsEl2.dataset.forced;
          wsEl2.disabled = false;
        }
        if (weEl2) {
          delete weEl2.dataset.forced;
          weEl2.disabled = false;
        }
        if (genBtn) genBtn.disabled = false;
      }
      if (wsEl2) wsEl2.addEventListener('change', enableOnChange);
      if (weEl2) weEl2.addEventListener('change', enableOnChange);
    } else if (target.classList.contains('deleteActive')) {
      // Delete active (unlocked) snapshot after confirmation
      if (!snap) return;
      const ok = confirm('Are you sure you want to delete this payroll snapshot? This action cannot be undone.');
      if (!ok) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
  });

  /**
   * Render the payroll history table.
   * Each snapshot row contains a checkbox for diffing, start/end dates, lock timestamp,
   * truncated hash, and action buttons for opening and downloading the snapshot.
   */
  window.renderHistory = function renderHistory() {
    if (!historyTableBody) return;
    historyTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      const tr = document.createElement('tr');
      // Build row HTML; note small hash display for brevity
      // Build the actions column depending on lock status. Only locked snapshots show Open/Unlock buttons.
      const actions = [];
      if (snap.locked) {
        actions.push(`<button type="button" class="openSnapshot" data-index="${index}">Open</button>`);
        actions.push(`<button type="button" class="unlockSnapshot" data-index="${index}">Unlock</button>`);
        // For locked snapshots, show a disabled delete button to indicate it cannot be removed
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}" disabled>Delete</button>`);
      } else {
        // For unlocked snapshots, allow deletion
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}">Delete</button>`);
      }
      // Always provide a download button
      actions.push(`<button type="button" class="downloadSnapshot" data-index="${index}">Download CSV</button>`);
      tr.innerHTML = `
        <td><input type="checkbox" class="diff-select" data-index="${index}"></td>
        <td>${snap.startDate || ''}</td>
        <td>${snap.endDate || ''}</td>
        <td>${snap.lockedAt ? new Date(snap.lockedAt).toLocaleString() : ''}</td>
        <td><span style="font-size:10px;">${snap.hash ? snap.hash.slice(0, 12) + '...' : ''}</span></td>
        <td>${actions.join(' ')}</td>
      `;
      historyTableBody.appendChild(tr);
    });
  };

  /**
   * Build a snapshot from the current payroll table. This captures all row values
   * and totals in a structured JSON object for persistence.
   */
  async function buildSnapshot(startDate, endDate) {
    const table = document.getElementById('payrollTable');
    if (!table) return null;
    const rows = [];
    table.querySelectorAll('tbody tr').forEach(row => {
      const data = {};
      data.id = (row.cells[0]?.textContent || '').trim();
      data.name = (row.cells[1]?.textContent || '').trim();
      // Helper to read numeric input or fallback text
      function readNum(sel, cellIndex) {
        const input = row.querySelector(sel);
        if (input) return parseFloat(input.value) || 0;
        const cellVal = row.cells[cellIndex] && row.cells[cellIndex].textContent;
        return parseFloat(cellVal) || 0;
      }
      data.regHrs = readNum('.regHrs', 2);
      data.otHrs = readNum('.otHrs', 3);
      data.rate = readNum('.rate', 4);
      data.regPay = readNum('.regPay', 5);
      data.otPay = readNum('.otPay', 6);
      data.grossPay = readNum('.grossPay', 7);
      data.pagibig = readNum('.pagibig', 8);
      data.philhealth = readNum('.philhealth', 9);
      data.sss = readNum('.sss', 10);
      data.loanSSS = readNum('.loanSSS', 11);
      data.loanPI = readNum('.loanPI', 12);
      data.vale = readNum('.vale', 13);
      data.valeWed = readNum('.valeWed', 14);
      data.totalDed = readNum('.totalDed', 15);
      data.netPay = readNum('.netPay', 16);
      rows.push(data);
    });
    // Read totals from footer
    const totals = {};
    const footRow = document.querySelector('#payrollTable tfoot tr');
    if (footRow) {
      footRow.querySelectorAll('[data-col]').forEach(td => {
        const key = td.dataset.col;
        totals[key] = parseFloat(td.textContent.trim()) || 0;
      });
    }
    return { startDate, endDate, rows, totals };
  }
  // Expose buildSnapshot globally so it can be called from other scripts
  window.buildSnapshot = buildSnapshot;

  /**
   * Convert a snapshot into a CSV string. Header names correspond to payroll columns.
   */
  function snapshotToCSV(snap) {
    const header = [
      'ID','Name','Regular Hours','OT Hours','Rate','Regular Pay','OT Pay','Gross Pay',
      'Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Deductions','Net Pay'
    ];
    const lines = [header.join(',')];
    snap.rows.forEach(row => {
      const values = [
        row.id, row.name,
        row.regHrs, row.otHrs, row.rate,
        row.regPay, row.otPay, row.grossPay,
        row.pagibig, row.philhealth, row.sss,
        row.loanSSS, row.loanPI, row.vale, row.valeWed,
        row.totalDed, row.netPay
      ];
      lines.push(values.map(v => {
        const s = String(v ?? '');
        return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
      }).join(','));
    });
    return lines.join('\n');
  }

  // Persist payrollHistory to localStorage
  function saveHistory() {
    localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(payrollHistory));
  }
  // Expose saveHistory globally so it can be called from other scripts
  window.saveHistory = saveHistory;

  // Handler for Generate button: build and save a snapshot without locking
  dashGenerateBtn && dashGenerateBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    // Prevent duplicate snapshots for the same date range. If any snapshot (locked or active)
    // already exists with this start/end, alert the user and skip creation. This avoids
    // double‑entry payroll for the same period.
    const exists = Array.isArray(payrollHistory) && payrollHistory.some(snap =>
      snap && snap.startDate === start && snap.endDate === end);
    if (exists) {
      alert('A payroll snapshot for this date range already exists. Please choose a different range or delete the existing entry.');
      return;
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false });
    saveHistory();
    // Update both history and active payroll tables after creating a new snapshot
    renderHistory();
    if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
  });

  // Handler for Lock button: build snapshot, mark locked and disable payroll editing
  dashLockBtn && dashLockBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: true });
    saveHistory();
    renderHistory();
    // Disable payroll inputs and dashboard controls until date range changes
    document.querySelectorAll('#panelPayroll input').forEach(inp => { inp.disabled = true; });
    if (dashStart) dashStart.disabled = true;
    if (dashEnd) dashEnd.disabled = true;
    if (dashGenerateBtn) dashGenerateBtn.disabled = true;
    if (dashLockBtn) dashLockBtn.disabled = true;
    // Listener to re-enable controls on date change
    function enableOnChange() {
      if (dashStart) dashStart.removeEventListener('change', enableOnChange);
      if (dashEnd) dashEnd.removeEventListener('change', enableOnChange);
      document.querySelectorAll('#panelPayroll input').forEach(inp => { inp.disabled = false; });
      if (dashStart) dashStart.disabled = false;
      if (dashEnd) dashEnd.disabled = false;
      if (dashGenerateBtn) dashGenerateBtn.disabled = false;
      if (dashLockBtn) dashLockBtn.disabled = false;
    }
    if (dashStart) dashStart.addEventListener('change', enableOnChange);
    if (dashEnd) dashEnd.addEventListener('change', enableOnChange);
  });

  // Delegate open/download actions on history table
  historyTableBody && historyTableBody.addEventListener('click', (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('openSnapshot')) {
      // Only allow opening locked snapshots
      if (!snap.locked) return;
      // Clear existing view then render snapshot as a read-only table
      if (snapshotView) snapshotView.innerHTML = '';
      const table = document.createElement('table');
      table.style.borderCollapse = 'collapse';
      table.style.width = '100%';
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const hdrs = ['ID','Name','Regular Hrs','OT Hrs','Rate','Reg Pay','OT Pay','Gross','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Ded','Net Pay'];
      hdrs.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h;
        th.style.border = '1px solid #e2e8f0';
        th.style.background = '#f1f5f9';
        th.style.padding = '4px';
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbodyEl = document.createElement('tbody');
      snap.rows.forEach(r => {
        const tr = document.createElement('tr');
        const vals = [r.id,r.name,r.regHrs,r.otHrs,r.rate,r.regPay,r.otPay,r.grossPay,r.pagibig,r.philhealth,r.sss,r.loanSSS,r.loanPI,r.vale,r.valeWed,r.totalDed,r.netPay];
        vals.forEach(v => {
          const td = document.createElement('td');
          td.textContent = v;
          td.style.border = '1px solid #e2e8f0';
          td.style.padding = '4px';
          td.style.textAlign = (typeof v === 'number') ? 'right' : 'left';
          tr.appendChild(td);
        });
        tbodyEl.appendChild(tr);
      });
      table.appendChild(tbodyEl);
      if (snapshotView) snapshotView.appendChild(table);
      // Disable editing across DTR, payroll, and project totals until date range changes
      const disableSelectors = [
        '#panelPayroll input', '#panelPayroll button', '#panelPayroll select',
        '#panelMain input', '#panelMain button', '#panelMain select',
        '#panelProjects input', '#panelProjects button', '#panelProjects select',
        '#panelProjectTotals input', '#panelProjectTotals button', '#panelProjectTotals select'
      ];
      disableSelectors.forEach(sel => {
        document.querySelectorAll(sel).forEach(el => { el.disabled = true; });
      });
      // Disable date range inputs and Generate button, and mark them as forced
      const ws = document.getElementById('weekStart');
      const we = document.getElementById('weekEnd');
      const gen = document.getElementById('dashGenerate');
      if (ws) {
        ws.disabled = true;
        ws.dataset.forced = 'true';
      }
      if (we) {
        we.disabled = true;
        we.dataset.forced = 'true';
      }
      if (gen) gen.disabled = true;
      function enableOnDateChange() {
        // Remove listeners
        if (ws) ws.removeEventListener('change', enableOnDateChange);
        if (we) we.removeEventListener('change', enableOnDateChange);
        // Re-enable all disabled inputs/buttons/selects
        disableSelectors.forEach(sel => {
          document.querySelectorAll(sel).forEach(el => { el.disabled = false; });
        });
        // Clear forced flags and re-enable date range inputs and Generate button
        if (ws) {
          delete ws.dataset.forced;
          ws.disabled = false;
        }
        if (we) {
          delete we.dataset.forced;
          we.disabled = false;
        }
        if (gen) gen.disabled = false;
      }
      if (ws) ws.addEventListener('change', enableOnDateChange);
      if (we) we.addEventListener('change', enableOnDateChange);
    }
    if (target.classList.contains('deleteSnapshot')) {
      // Delete a snapshot from history if it is not locked
      if (snap.locked) return; // Skip deletion for locked snapshots
      const confirmDel = confirm('Are you sure you want to delete this payroll record? This cannot be undone.');
      if (!confirmDel) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      return;
    }
    if (target.classList.contains('unlockSnapshot')) {
      // Unlock this locked snapshot: mark as unlocked and remove timestamp
      if (!snap.locked) return;
      snap.locked = false;
      snap.lockedAt = '';
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
    if (target.classList.contains('downloadSnapshot')) {
      const csv = snapshotToCSV(snap);
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `payroll_${snap.startDate}_${snap.endDate}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  });

  // Compare two snapshots and display net pay differences
  diffBtn && diffBtn.addEventListener('click', () => {
    const selected = Array.from(document.querySelectorAll('.diff-select')).filter(cb => cb.checked);
    if (selected.length !== 2) {
      alert('Please select exactly two snapshots to compare.');
      return;
    }
    const idx1 = parseInt(selected[0].dataset.index, 10);
    const idx2 = parseInt(selected[1].dataset.index, 10);
    const s1 = payrollHistory[idx1];
    const s2 = payrollHistory[idx2];
    if (!s1 || !s2) return;
    const map1 = {};
    s1.rows.forEach(r => { map1[r.id] = r; });
    const map2 = {};
    s2.rows.forEach(r => { map2[r.id] = r; });
    const allIds = new Set([...Object.keys(map1), ...Object.keys(map2)]);
    if (snapshotView) snapshotView.innerHTML = '';
    const table = document.createElement('table');
    table.style.borderCollapse = 'collapse';
    table.style.width = '100%';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['ID','Name',`Net (${s1.startDate} - ${s1.endDate})`,`Net (${s2.startDate} - ${s2.endDate})`,'Difference'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    allIds.forEach(id => {
      const r1 = map1[id] || {};
      const r2 = map2[id] || {};
      const name = r2.name || r1.name || '';
      const net1 = parseFloat(r1.netPay) || 0;
      const net2 = parseFloat(r2.netPay) || 0;
      const diff = (net2 - net1).toFixed(2);
      const tr = document.createElement('tr');
      [id, name, net1.toFixed(2), net2.toFixed(2), diff].forEach((val, i) => {
        const td = document.createElement('td');
        td.textContent = val;
        td.style.border = '1px solid #e2e8f0';
        td.style.padding = '4px';
        if (i >= 2) td.style.textAlign = 'right';
        tr.appendChild(td);
      });
      // Highlight difference cell
      const diffVal = parseFloat(diff);
      const diffCell = tr.children[4];
      if (diffVal > 0) diffCell.style.background = '#dcfce7';
      else if (diffVal < 0) diffCell.style.background = '#fee2e2';
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    if (snapshotView) snapshotView.appendChild(table);
  });

  // Initial render on page load
  renderHistory();
  if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
});
</script>
   </div>
  </section>
  <section class="panel" id="panelProjectTotals">
    <h3>Reports</h3>
    <div class="controls" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <div class="muted">Uses the global Start/End dates in the header and includes per-day project/schedule overrides.</div>
      <div style="flex:1 1 auto"></div>
      <button id="downloadProjectTotalsCSV">Download CSV</button>
      <button id="printProjectTotalsBtn">Print Reports</button>
    </div>
    <table id="projectTotalsTable">
      <thead>
        <tr>
          <th>Project</th>
          <th>Regular Hours</th>
          <th>OT Hours</th>
          <th>Total Hours</th>
          <th>Gross Amount</th>
          <th>Employees (count)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <!-- Modal for detailed project report -->
    <div id="projectReportModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;z-index:10000;">
      <div style="background:white;padding:20px;border-radius:10px;max-height:80vh;overflow:auto;width:90%;max-width:800px;position:relative;">
        <button type="button" id="closeProjectReport" style="position:absolute;top:10px;right:10px;font-size:20px;border:none;background:transparent;cursor:pointer;">&times;</button>
        <div id="projectReportContent"></div>
      </div>
    </div>
  </section>
      </main>
    </div>
    <!-- Sidebar navigation behaviour -->
    <script>
    document.querySelectorAll('.nav-link').forEach(function(link){
        link.addEventListener('click', function(e){
            e.preventDefault();
            document.querySelectorAll('.nav-link').forEach(function(l){ l.classList.remove('active'); });
            this.classList.add('active');
            var icon = this.querySelector('.nav-icon').textContent;
            var text = this.textContent.trim();
            var pageTitle = document.querySelector('.page-title');
            if(pageTitle){
                pageTitle.innerHTML = '<span style="font-size: 32px;">' + icon + '</span> ' + text;
            }
        });
    });
    function toggleSidebar(){
        var sidebar = document.getElementById('sidebar');
        if(sidebar) sidebar.classList.toggle('active');
    }
    document.addEventListener('click', function(e){
        var sidebar = document.getElementById('sidebar');
        var mobileBtn = document.querySelector('.mobile-menu-btn');
        if(window.innerWidth <= 768 && sidebar && sidebar.classList.contains('active') && !sidebar.contains(e.target) && mobileBtn && !mobileBtn.contains(e.target)){
            sidebar.classList.remove('active');
        }
    });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
   
const LS_RECORDS = 'att_records_v2';

const LS_SCHEDULES = 'att_schedules_v2';
const LS_SCHEDULES_DEFAULT = 'att_schedules_default';
const LS_EMPLOYEES = 'att_employees_v2';
const LS_PROJECTS = 'att_projects_v1';
const LS_FILTER_PROJECT = 'att_filter_project_v1';
const LS_OVERRIDES_SCHEDULES = 'att_overrides_schedules';
const LS_OVERRIDES_PROJECTS = 'att_overrides_projects';

let overridesSchedules = JSON.parse(localStorage.getItem(LS_OVERRIDES_SCHEDULES) || '{}');
let overridesProjects = JSON.parse(localStorage.getItem(LS_OVERRIDES_PROJECTS) || '{}');
// Store per-date split flags for half-day display. When true for an empId+date,
// the DTR entry is rendered as two separate rows (AM and PM) rather than a
// single combined row. The split state is persisted in localStorage under
// LS_SPLITS. Keys are formatted as empId + '___' + date.
const LS_SPLITS = 'att_splits_v1';
let splits = {};
try {
  splits = JSON.parse(localStorage.getItem(LS_SPLITS) || '{}');
} catch (e) {
  splits = {};
}
function saveSplits() {
  try {
    localStorage.setItem(LS_SPLITS, JSON.stringify(splits));
  } catch (e) {
    console.warn('Saving splits failed', e);
  }
}
function saveOverrides(){
  localStorage.setItem(LS_OVERRIDES_SCHEDULES, JSON.stringify(overridesSchedules));
  localStorage.setItem(LS_OVERRIDES_PROJECTS, JSON.stringify(overridesProjects));
}


const DEFAULT_RANGES = {
  rng_am_in_start:"05:00", rng_am_in_end:"09:00",
  rng_am_out_start:"11:30", rng_am_out_end:"12:30",
  rng_pm_in_start:"12:30", rng_pm_in_end:"14:30",
  rng_pm_out_start:"15:00", rng_pm_out_end:"20:00",
  rng_ot_in_start:"19:00", rng_ot_in_end:"22:00",
  rng_ot_out_start:"19:00", rng_ot_out_end:"23:59",
  rng_sat_ot_start:"11:00", rng_sat_ot_end:"23:59"
};
const DEFAULT_SCHEDULE = {
  name: "Default",
  sch_am_start:"08:00", sch_am_end:"12:00",
  sch_pm_start:"13:00", sch_pm_end:"17:00",
  
  sch_sat_start:"", sch_sat_end:"",
  sch_grace:15,
  ...DEFAULT_RANGES

};

let storedRecords = JSON.parse(localStorage.getItem(LS_RECORDS) || '[]');
let storedEmployees = JSON.parse(localStorage.getItem(LS_EMPLOYEES) || '{}');
let storedSchedules = JSON.parse(localStorage.getItem(LS_SCHEDULES) || 'null');
let defaultScheduleId = localStorage.getItem(LS_SCHEDULES_DEFAULT) || null;
let storedProjects = JSON.parse(localStorage.getItem(LS_PROJECTS) || '{}');
document.getElementById('downloadEmployeesCSV').addEventListener('click', () => {
  const rows = [['ID','Name','Hourly Rate','Schedule','Project','Bank Account']];
  Object.keys(storedEmployees).forEach(id => {
    const emp = storedEmployees[id] || {};
    const schedName = storedSchedules[emp.scheduleId]?.name || '';
    const projName = storedProjects[emp.projectId]?.name || '';
    const bank = emp.bankAccount || ''; rows.push([id, emp.name || '', emp.hourlyRate || '', schedName, projName, bank]);
  });
// === Backup/Restore All Data ===
(function(){
  function safeParse(str){
    try { return JSON.parse(str) } catch { return str }
  }
  function safeString(v){
    try {
      if (typeof v === "string") return v
      return JSON.stringify(v)
    } catch { return String(v) }
  }
  function downloadFile(name, dataStr){
    const blob = new Blob([dataStr], {type:"application/json"})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = name
    document.body.appendChild(a)
    a.click()
    a.remove()
    URL.revokeObjectURL(url)
  }
  function currentStamp(){
    const d = new Date()
    const pad = n => String(n).padStart(2,'0')
    return d.getFullYear() + pad(d.getMonth()+1) + pad(d.getDate()) + "_" + pad(d.getHours()) + pad(d.getMinutes()) + pad(d.getSeconds())
  }
  function collectAll(){
    const out = {}
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i)
      out[k] = safeParse(localStorage.getItem(k))
    }
    return out
  }
  function hydrateAll(obj){
    const KEYS = Object.keys(obj || {})
    KEYS.forEach(k => {
      const v = obj[k]
      try { localStorage.setItem(k, safeString(v)) } catch {}
    })
  }
  const backupBtn = document.getElementById('backupAllBtn')
  const restoreInput = document.getElementById('restoreAllFile')
  if (backupBtn) {
    backupBtn.addEventListener('click', () => {
      const payload = {
        meta: { exportedAt: new Date().toISOString(), origin: location.origin },
        data: collectAll()
      }
      downloadFile('payroll_backup_' + currentStamp() + '.json', JSON.stringify(payload, null, 2))
    })
  }
  if (restoreInput) {
    restoreInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0]
      if (!f) return
      const reader = new FileReader()
      reader.onload = (ev) => {
        try {
          const text = String(ev.target.result || '')
          const parsed = JSON.parse(text)
          const data = parsed && parsed.data ? parsed.data : parsed
          hydrateAll(data)
          alert('Restore complete. The page will reload to apply data.')
          location.reload()
        } catch (err) {
          console.error(err)
          alert('Invalid backup file.')
        } finally {
          e.target.value = ''
        }
      }
      reader.readAsText(f)
    })
  }
})();
// === / Backup/Restore All Data ===

  const csv = rows.map(r => r.map(v => {
    const s = String(v ?? '');
    return (s.includes(',') || s.includes('"') || s.includes('\n')) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'employees_backup.csv';
  a.click();
});

let currentProjectFilter = localStorage.getItem(LS_FILTER_PROJECT) || 'all';

function ensureSchedules(){
  if(!storedSchedules || typeof storedSchedules !== 'object'){
    const id = 'sched_' + Date.now();
    storedSchedules = {};
    storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE);
    storedSchedules[id].name = DEFAULT_SCHEDULE.name;
    defaultScheduleId = id;
    saveSchedulesToLS();
  } else {
    Object.keys(storedSchedules).forEach(id=>{
      storedSchedules[id] = { ...DEFAULT_RANGES, ...storedSchedules[id] };
      storedSchedules[id].sch_am_start = storedSchedules[id].sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
      storedSchedules[id].sch_am_end   = storedSchedules[id].sch_am_end   || DEFAULT_SCHEDULE.sch_am_end;
      storedSchedules[id].sch_pm_start = storedSchedules[id].sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
      storedSchedules[id].sch_pm_end   = storedSchedules[id].sch_pm_end   || DEFAULT_SCHEDULE.sch_pm_end;
      if(typeof storedSchedules[id].sch_grace !== 'number') storedSchedules[id].sch_grace = DEFAULT_SCHEDULE.sch_grace;
      storedSchedules[id].name = storedSchedules[id].name || 'Schedule';
    });
    if(!defaultScheduleId || !storedSchedules[defaultScheduleId]){
      const keys = Object.keys(storedSchedules);
      if(keys.length) defaultScheduleId = keys[0];
      saveSchedulesToLS();
    }
  }
}
function saveSchedulesToLS(){
  localStorage.setItem(LS_SCHEDULES, JSON.stringify(storedSchedules));
  localStorage.setItem(LS_SCHEDULES_DEFAULT, defaultScheduleId);
}

const tabs = {
  tabMain: document.getElementById('tabMain'),
  // Dashboard tab/button for high-level summary and payroll history
  tabDashboard: document.getElementById('tabDashboard'),
  tabSchedule: document.getElementById('tabSchedule'),
  tabEmployees: document.getElementById('tabEmployees'),
  tabProjects: document.getElementById('tabProjects'),
  panelMain: document.getElementById('panelMain'),
  // Corresponding Dashboard panel
  panelDashboard: document.getElementById('panelDashboard'),
  panelSchedule: document.getElementById('panelSchedule'),
  panelEmployees: document.getElementById('panelEmployees'),
  panelProjects: document.getElementById('panelProjects'),
  tabPayroll: document.getElementById('tabPayroll'),
  panelPayroll: document.getElementById('panelPayroll')
};
function showTab(name){
  Object.values(tabs).forEach(el => el && el.classList && el.classList.remove('active'));

  // Manage date range controls: disable on non-dashboard tabs, enable on dashboard unless forced
  (() => {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (wsEl && weEl) {
      const isDash = (name === 'dashboard');
      // Only toggle if the inputs are not forcibly disabled (e.g., due to lock/open)
      const forced = wsEl.dataset.forced === 'true' || weEl.dataset.forced === 'true';
      if (!forced) {
        wsEl.disabled = !isDash;
        weEl.disabled = !isDash;
      }
    }
  })();
  if(name==='main'){ tabs.tabMain.classList.add('active'); tabs.panelMain.classList.add('active'); }
  // When the dashboard is selected, activate its tab and panel
  if(name==='dashboard'){ tabs.tabDashboard && tabs.tabDashboard.classList.add('active'); tabs.panelDashboard && tabs.panelDashboard.classList.add('active'); }
  if(name==='schedule'){ tabs.tabSchedule.classList.add('active'); tabs.panelSchedule.classList.add('active'); renderScheduleEditor(); }
  if(name==='employees'){ tabs.tabEmployees.classList.add('active'); tabs.panelEmployees.classList.add('active'); renderEmployees(); }
  if(name==='projects'){ tabs.tabProjects.classList.add('active'); tabs.panelProjects.classList.add('active'); renderProjects(); }

  if(name==='payroll'){ tabs.tabPayroll && tabs.tabPayroll.classList.add('active'); tabs.panelPayroll && tabs.panelPayroll.classList.add('active'); }
}
tabs.tabMain.addEventListener('click', ()=>{ showTab('main'); try{ renderResults(); }catch(e){} });
tabs.tabSchedule.addEventListener('click', ()=>showTab('schedule'));
tabs.tabEmployees.addEventListener('click', ()=>showTab('employees'));
tabs.tabProjects.addEventListener('click', ()=>showTab('projects'));

tabs.tabPayroll.addEventListener('click', ()=>{
  try {
    const defaultBtn = document.querySelector('#panelPayroll .tabs .tab-btn[data-tab="payrollTab"]');
    if (defaultBtn) defaultBtn.click();
  } catch (e) {}

  showTab('payroll');
  try { if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); } catch(e){}
  try { if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); } catch(e){}
});

// Switch to the dashboard tab when clicked. Render payroll history if available.
if (tabs.tabDashboard) {
  tabs.tabDashboard.addEventListener('click', () => {
    showTab('dashboard');
    try {
      if (typeof renderHistory === 'function') renderHistory();
    } catch (e) {}
  });
}

const scheduleSelect = document.getElementById('scheduleSelect');
const scheduleNameInput = document.getElementById('scheduleName');

function renderScheduleSelector(){
  scheduleSelect.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = (storedSchedules[id].name || id) + (id === defaultScheduleId ? " (Default)" : "");
    scheduleSelect.appendChild(opt);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) scheduleSelect.value = defaultScheduleId;
  else if(scheduleSelect.options.length) scheduleSelect.selectedIndex = 0;
  renderEmpScheduleDropdowns();
  renderEmpScheduleDropdownsInTable();
}

function renderScheduleEditor(){
  const sel = scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  const s = storedSchedules[sel];
  document.querySelector('[data-key="sch_am_start"]').value = s.sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
  document.querySelector('[data-key="sch_am_end"]').value = s.sch_am_end || DEFAULT_SCHEDULE.sch_am_end;
  document.querySelector('[data-key="sch_pm_start"]').value = s.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
  document.querySelector('[data-key="sch_pm_end"]').value = s.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end;
  
  const satStartInp = document.querySelector('[data-key="sch_sat_start"]');
  const satEndInp   = document.querySelector('[data-key="sch_sat_end"]');
  if (satStartInp) satStartInp.value = (s.sch_sat_start || "");
  if (satEndInp)   satEndInp.value   = (s.sch_sat_end   || "");
document.querySelector('[data-key="sch_grace"]').value = (s.sch_grace !== undefined ? s.sch_grace : DEFAULT_SCHEDULE.sch_grace);
  scheduleNameInput.value = s.name || ("Schedule " + sel);
  document.querySelectorAll('#rangesTable input[data-key]').forEach(inp=>{
    const key = inp.dataset.key;
    inp.value = s[key] || (DEFAULT_RANGES && DEFAULT_RANGES[key]) || "";
  });
}

function gatherScheduleFromEditor(){
  return {
    name: scheduleNameInput.value.trim() || ("Schedule " + Date.now()),
    sch_am_start: document.querySelector('[data-key="sch_am_start"]').value || DEFAULT_SCHEDULE.sch_am_start,
    sch_am_end: document.querySelector('[data-key="sch_am_end"]').value || DEFAULT_SCHEDULE.sch_am_end,
    sch_pm_start: document.querySelector('[data-key="sch_pm_start"]').value || DEFAULT_SCHEDULE.sch_pm_start,
    sch_pm_end: document.querySelector('[data-key="sch_pm_end"]').value || DEFAULT_SCHEDULE.sch_pm_end,
    
    sch_sat_start: (document.querySelector('[data-key="sch_sat_start"]')?.value || ""),
    sch_sat_end:   (document.querySelector('[data-key="sch_sat_end"]')?.value   || ""),
sch_grace: Number(document.querySelector('[data-key="sch_grace"]').value || DEFAULT_SCHEDULE.sch_grace),
    ...Object.fromEntries([...document.querySelectorAll('#rangesTable input[data-key]')].map(i=>[i.dataset.key, i.value || DEFAULT_RANGES[i.dataset.key] || ""]))
  };
}

document.getElementById('addScheduleBtn').addEventListener('click', ()=>{
  const id = 'sched_' + Date.now();
  storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE); storedSchedules[id].name = 'New schedule';
  saveSchedulesToLS(); renderScheduleSelector(); scheduleSelect.value = id; renderScheduleEditor();
});
document.getElementById('deleteScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  if(Object.keys(storedSchedules).length === 1){ alert('Cannot delete the only schedule.'); return; }
  if(!confirm('Delete schedule "' + storedSchedules[sel].name + '"?')) return;
  delete storedSchedules[sel];
  if(!storedSchedules[defaultScheduleId]) defaultScheduleId = Object.keys(storedSchedules)[0];
  Object.keys(storedEmployees).forEach(eid=>{
    if(storedEmployees[eid].scheduleId === sel) storedEmployees[eid].scheduleId = defaultScheduleId;
  });
  saveSchedulesToLS(); saveEmployeesToLS(); renderScheduleSelector(); renderEmployees(); renderResults();
});
document.getElementById('setDefaultScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return; defaultScheduleId = sel; saveSchedulesToLS(); renderScheduleSelector();
});
document.getElementById('saveScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  const oldRanges = {};
  Object.keys(DEFAULT_RANGES).forEach(k=> oldRanges[k] = (storedSchedules[sel] && storedSchedules[sel][k]) || DEFAULT_RANGES[k]);
  storedSchedules[sel] = { ...gatherScheduleFromEditor(), ...oldRanges, name: document.getElementById('scheduleName').value.trim() || storedSchedules[sel].name || 'Schedule' };
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || DEFAULT_RANGES[i.dataset.key] || "";
  });
  saveSchedulesToLS(); renderScheduleSelector(); renderEmpScheduleDropdowns(); renderResults();
});
scheduleSelect.addEventListener('change', ()=>{ renderScheduleEditor(); });

function saveRangesFromUI(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || "";
  });
  saveSchedulesToLS();
  renderResults();
}
function resetRanges(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  Object.keys(DEFAULT_RANGES).forEach(k=>{
    storedSchedules[sel][k] = DEFAULT_RANGES[k];
  });
  saveSchedulesToLS();
  renderScheduleEditor();
  renderResults();
}
document.getElementById('saveRangesBtn').addEventListener('click', saveRangesFromUI);
document.getElementById('resetRangesBtn').addEventListener('click', resetRanges);

function saveEmployeesToLS(){ localStorage.setItem(LS_EMPLOYEES, JSON.stringify(storedEmployees)); }
function renderEmpScheduleDropdowns(){
  const sel = document.getElementById('empScheduleSelect'); if(!sel) return;
  sel.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const o=document.createElement('option'); o.value=id;
    o.textContent=storedSchedules[id].name + (id===defaultScheduleId?' (Default)':'');
    sel.appendChild(o);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) sel.value = defaultScheduleId;
}
function renderEmpScheduleDropdownsInTable(){
  document.querySelectorAll('.emp-sel-schedule').forEach(sel=>{
    const id = sel.dataset.id;
    sel.innerHTML = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      const o = document.createElement('option'); o.value = sid; o.textContent = label;
      if(storedEmployees[id] && storedEmployees[id].scheduleId === sid) o.selected = true;
      sel.appendChild(o);
    });
  });
}

function saveProjectsToLS(){ localStorage.setItem(LS_PROJECTS, JSON.stringify(storedProjects)); renderProjects(); renderProjectDropdowns(); renderProjectFilterOptions(); renderResults(); }
function renderProjects(){
  const tbody = document.querySelector('#projectsTable tbody'); tbody.innerHTML = '';
  Object.keys(storedProjects).forEach(pid=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td><input class="cell proj-name-input" data-id="${pid}" value="${storedProjects[pid].name}"></td>
      <td><button class="del-proj" data-id="${pid}">Delete</button></td>`;
    tbody.appendChild(tr);
  });
  document.querySelectorAll('.del-proj').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const id = e.target.dataset.id;
      if(confirm('Delete project "' + storedProjects[id].name + '"?')){
        delete storedProjects[id];
        Object.keys(storedEmployees).forEach(eid=>{ if(storedEmployees[eid].projectId === id) storedEmployees[eid].projectId = null; });
        saveProjectsToLS(); saveEmployeesToLS(); renderEmployees(); renderResults();
      }
    });
  });
  document.querySelectorAll('.proj-name-input').forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.dataset.id;
      storedProjects[id].name = e.target.value;
      saveProjectsToLS();
    });
  });

}
function renderProjectDropdowns(){
  const sel = document.getElementById('empProjectSelect');
  if(!sel) return;
  sel.innerHTML = '';
  const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid=>{
    const o=document.createElement('option'); o.value=pid; o.textContent=storedProjects[pid].name; sel.appendChild(o);
  });
}
function renderEmpProjectDropdownsInTable(){
  document.querySelectorAll('.emp-sel-project').forEach(sel=>{
    const id = sel.dataset.id;
    const prev = sel.value;
    sel.innerHTML = '';
    const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
    Object.keys(storedProjects).forEach(pid=>{
      const o = document.createElement('option'); o.value = pid; o.textContent = storedProjects[pid].name;
      if(storedEmployees[id] && storedEmployees[id].projectId === pid) o.selected = true;
      sel.appendChild(o);
    });
    if(prev) sel.value = prev;
  });
}

const filterProjectSel = document.getElementById('filterProject');
function renderProjectFilterOptions(){
  if(!filterProjectSel) return;
  const prev = currentProjectFilter || 'all';
  filterProjectSel.innerHTML = '';
  const make = (value, label)=>{ const o=document.createElement('option'); o.value=value; o.textContent=label; return o; };
  filterProjectSel.appendChild(make('all','All Projects'));
  filterProjectSel.appendChild(make('none','(No project)'));
  Object.keys(storedProjects).forEach(pid=>{
    filterProjectSel.appendChild(make(pid, storedProjects[pid].name));
  });
  if([...filterProjectSel.options].some(o=>o.value===prev)) filterProjectSel.value = prev;
  else filterProjectSel.value = 'all';
  currentProjectFilter = filterProjectSel.value;
}
filterProjectSel && filterProjectSel.addEventListener('change', ()=>{
  currentProjectFilter = filterProjectSel.value || 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);
  renderResults();
});

function renderEmployees(){
  renderEmpScheduleDropdowns();
  renderProjectDropdowns();
  const tbody = document.querySelector('#employeesTable tbody'); tbody.innerHTML = '';
  const ids = Object.keys(storedEmployees).sort((a,b)=>{
    const na = /^\d+$/.test(a), nb = /^\d+$/.test(b);
    if (na && nb) return Number(a) - Number(b);
    return String(a).localeCompare(String(b));
  });
ids.forEach(id => {
    const emp = storedEmployees[id];
    let scheduleOptionsHtml = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      scheduleOptionsHtml += `<option value="${sid}" ${emp.scheduleId===sid ? 'selected' : ''}>${label}</option>`;
    });
    let projectOptionsHtml = `<option value="">(None)</option>`;
    Object.keys(storedProjects).forEach(pid=>{
      projectOptionsHtml += `<option value="${pid}" ${emp.projectId===pid ? 'selected' : ''}>${storedProjects[pid].name}</option>`;
    });
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${id}</td>
      <td><input class="cell emp-name-input" data-id="${id}" value="${emp.name}"></td>
      <td><input class="cell emp-rate-input" type="number" step="0.01" min="0" data-id="${id}" value="${emp.hourlyRate != null ? emp.hourlyRate : ''}"></td>
      <td><select class="emp-sel-schedule" data-id="${id}">${scheduleOptionsHtml}</select></td>
      <td><select class="emp-sel-project" data-id="${id}">${projectOptionsHtml}</select></td>
      <td><input class="cell emp-bank-input" data-id="${id}" value="${emp.bankAccount != null ? emp.bankAccount : ''}"></td>
      <td><button class="del-emp" data-id="${id}">Delete</button></td>`;
    tbody.appendChild(tr);
  });

  document.querySelectorAll('.emp-name-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].name = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-rate-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    const id = e.target.dataset.id;
    const val = parseFloat(e.target.value) || 0;
    storedEmployees[id].hourlyRate = val; saveEmployeesToLS();
    try { payrollRates[id] = val; localStorage.setItem(LS_RATES, JSON.stringify(payrollRates)); } catch(err) {}
    renderResults();
  }));
document.querySelectorAll('.emp-sel-schedule').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].scheduleId = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-sel-project').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].projectId = e.target.value || null; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.del-emp').forEach(btn=> btn.addEventListener('click', (e)=>{
    const id=e.target.dataset.id;
    if(confirm(`Delete employee ${id} — ${storedEmployees[id].name}?`)){
      delete storedEmployees[id]; saveEmployeesToLS(); renderEmployees(); renderResults();
    }
  }));
}

document.getElementById('addEmployeeBtn').addEventListener('click', ()=>{
  const id = document.getElementById('empIdInput').value.trim();
  const name = document.getElementById('empNameInput').value.trim();
  const rate = parseFloat(document.getElementById('empRateInput').value) || 0;
  const scheduleId = document.getElementById('empScheduleSelect').value || defaultScheduleId;
  const projectId = document.getElementById('empProjectSelect').value || null;
  const bank = document.getElementById('empBankInput').value.trim();
  if(!id){ alert('Enter ID'); return; } if(!name){ alert('Enter Name'); return; }
  storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId };
  saveEmployeesToLS();
  document.getElementById('empIdInput').value=''; document.getElementById('empNameInput').value=''; document.getElementById('empRateInput').value=''; document.getElementById('empBankInput').value='';
  renderEmployees(); renderResults();
});
document.getElementById('clearEmployeesBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all employees?')) return;
  storedEmployees = {}; saveEmployeesToLS(); renderEmployees(); renderResults();
});

document.getElementById('empFileInput').addEventListener('change', (evt) => {
  const file = evt.target.files && evt.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      
const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
let added = 0, updated = 0;
rows.slice(1).forEach(row => {
  if (row && row.length >= 2) {
    const id = String(row[0] ?? '').trim();
    const name = String(row[1] ?? '').trim();
    const rate = row.length >= 3 ? parseFloat(row[2]) || 0 : 0;
    const schedName = row.length >= 4 ? String(row[3] ?? '').trim().toLowerCase() : '';
    const projName = row.length >= 5 ? String(row[4] ?? '').trim().toLowerCase() : '';

    const bank = row.length >= 6 ? String(row[5] ?? '').trim() : '';
    if (id && name) {
      if (!storedEmployees[id]) { added++; } else { updated++; }
      let scheduleId = Object.keys(storedSchedules).find(k => storedSchedules[k].name.toLowerCase() === schedName) || defaultScheduleId;
      let projectId = Object.keys(storedProjects).find(k => storedProjects[k].name.toLowerCase() === projName) || null;

      storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId };
    }
  }
});
saveEmployeesToLS();
renderEmployees();
renderResults();
if (added || updated) alert(`Imported: ${added}, Updated: ${updated}`);
 renderResults();
      if(added || updated) alert('Imported: ' + added + ' added, ' + updated + ' updated.');
    } catch (err) { console.error(err); alert('Error reading file.'); }
    finally { evt.target.value = ''; }
  };
  reader.readAsArrayBuffer(file);
});

function parseLine(line){
  if(!line || !line.trim()) return null;
  const parts = line.trim().split(/\t+/);
  if(parts.length >= 2){
    const id = parts[0].trim(); const dt = parts[1].trim();
    const m = dt.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})(:\d{2})?$/);
    if(m) return { empId: id, date: m[1], time: m[2] };
  }
  const m2 = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
  if(m2){
    const before = line.slice(0, m2.index); const idm = before.match(/(\d+)/);
    if(!idm) return null; return { empId: idm[1], date: m2[1], time: m2[2].slice(0,5) };
  }
  return null;
}



document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const inputEl = ev.target;
  const files = inputEl.files;
  if (!files || !files.length) return;

  let processed = 0, totalAdded = 0, errors = 0;
  const total = files.length;
  inputEl.disabled = true;

  Array.from(files).forEach(file=>{
    const r = new FileReader();
    r.onload = (e)=>{
      try {
        const content = String(e.target.result || '');
        const lines = content.split(/\r?\n/);
        let added = 0;
        for(const ln of lines){
          const p = (typeof parseLine === 'function') ? parseLine(ln) : null;
          if(p && p.empId && p.date && p.time){
            storedRecords.push({ empId: String(p.empId), date: p.date, time: padHM(p.time) });
            added++;
          }
        }
        try { localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords)); } catch(e){}
        if (typeof renderResults === 'function') renderResults();
        totalAdded += added;
      } catch(err){
        console.error('Error reading', file.name, err);
        errors++;
      } finally {
        processed++;
        if (processed === total){
          inputEl.disabled = false; inputEl.value = '';
          if (errors > 0){
            alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
          } else {
            alert(`Upload successful: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}.`);
          }
        }
      }
    };
    r.onerror = ()=>{
      errors++; processed++;
      if (processed === total){
        inputEl.disabled = false; inputEl.value = '';
        alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
      }
    };
    r.readAsText(file);
  });
});


document.getElementById('clearData').addEventListener('click', ()=>{
  if(!confirm('Clear all saved attendance data?')) return;
  storedRecords = []; localStorage.removeItem(LS_RECORDS); renderResults();
});
document.getElementById('downloadCSV').addEventListener('click', ()=>{
  const rows = [['ID','Name','Project','Schedule','Date','AM In','AM Out','PM In','PM Out','OT In','OT Out','Total Regular Hrs','OT Hrs']];
  document.querySelectorAll('#resultsTable tbody tr').forEach(tr=>{
  const cells = Array.from(tr.querySelectorAll('td')).filter(td=>!td.classList.contains('actions-cell'));
  const rowVals = cells.map(td => {
    const sel = td.querySelector && td.querySelector('select');
    if (sel && sel.options && sel.selectedIndex >= 0) {
      const opt = sel.options[sel.selectedIndex];
      return (opt && opt.textContent) ? opt.textContent.trim() : '';
    }
    return td.textContent.trim();
  });
  rows.push(rowVals);
});
const csv = rows.map(r=>r.map(c=> (c.includes('"')||c.includes(',')||c.includes('\n')) ? '"' + c.replace(/"/g,'""') + '"' : c ).join(',')).join('\n');
  const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'attendance_with_ot.csv'; document.body.appendChild(a); a.click(); a.remove();
});
function padHM(hm){ if(!hm) return ''; const [h,m]=hm.split(':').map(x=>String(Number(x)).padStart(2,'0')); return h.padStart(2,'0')+':'+m.padStart(2,'0'); }
function toMins(hm){ if(!hm) return null; const [h,m]=hm.split(':').map(Number); return h*60+m; }
function minsToDecimal(mins){ return (mins/60).toFixed(2); }

function buildScheduleDropdown(empId, date, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesSchedules[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}
function buildProjectDropdown(empId, date, currentProjectId){
  const sel = document.createElement('select');
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesProjects[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

// Build a project dropdown for half-day (AM/PM) rows. Uses a key that
// appends the half identifier (e.g. '123___2023-08-19___AM') so that
// overrides can be stored separately for morning and afternoon entries.
function buildProjectDropdownHalf(empId, date, half, currentProjectId){
  const sel = document.createElement('select');
  // Include a none/default option
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    // Persist override keyed by empId + date + half
    overridesProjects[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    // Re-render to apply changes
    renderResults();
  });
  return sel;
}

// Build a schedule dropdown for half-day (AM/PM) rows. Similar to
// buildScheduleDropdown but stores overrides using a half-specific key.
function buildScheduleDropdownHalf(empId, date, half, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    overridesSchedules[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

function renderResults(){
  renderScheduleSelector();
  renderProjectFilterOptions();

  const startDate = document.getElementById('weekStart').value || null;
  const endDate = document.getElementById('weekEnd').value || null;
  currentProjectFilter = document.getElementById('filterProject') ? document.getElementById('filterProject').value : 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);

  
  const nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
const groups = {};
  for(const r of storedRecords){
    if(startDate && r.date < startDate) continue;
    if(endDate && r.date > endDate) continue;
    const key = r.date + '___' + r.empId;
    if(!groups[key]) groups[key]=[];
    groups[key].push(r.time);
  }

  const keys = Object.keys(groups).sort((a,b)=>{
    const [da,ea]=a.split('___'), [db,eb]=b.split('___');
    const nameA=(storedEmployees[ea] ? storedEmployees[ea].name : '').toLowerCase();
    const nameB=(storedEmployees[eb] ? storedEmployees[eb].name : '').toLowerCase();
    if(nameA && nameB){ if(nameA!==nameB) return nameA.localeCompare(nameB); if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb)); }
    if(nameA && !nameB) return -1; if(!nameA && nameB) return 1; if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb));
  });

  const tbody = document.querySelector('#resultsTable tbody'); tbody.innerHTML='';

  const __nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
  for(const key of keys){
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId] || null;
      if (__nameQuery) { const _nm = (emp && emp.name ? String(emp.name).toLowerCase() : ''); if (_nm.indexOf(__nameQuery) === -1) continue; }
let empProjId = emp ? (emp.projectId || '') : '';
    const overrideKeyProj = empId + '___' + date;
    if(overridesProjects[overrideKeyProj] !== undefined) empProjId = overridesProjects[overrideKeyProj];
    const passesProject =
      currentProjectFilter === 'all' ||
      (currentProjectFilter === 'none' && !empProjId) ||
      currentProjectFilter === empProjId;
    if(!passesProject) continue;

    const times = Array.from(new Set(groups[key])).sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if(overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = storedSchedules[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);
    const rangesForEmp = {
      amIn: { start: schedule.rng_am_in_start || DEFAULT_RANGES.rng_am_in_start, end: schedule.rng_am_in_end || DEFAULT_RANGES.rng_am_in_end },
      amOut:{ start: schedule.rng_am_out_start || DEFAULT_RANGES.rng_am_out_start, end: schedule.rng_am_out_end || DEFAULT_RANGES.rng_am_out_end },
      pmIn: { start: schedule.rng_pm_in_start || DEFAULT_RANGES.rng_pm_in_start, end: schedule.rng_pm_in_end || DEFAULT_RANGES.rng_pm_in_end },
      pmOut:{ start: schedule.rng_pm_out_start || DEFAULT_RANGES.rng_pm_out_start, end: schedule.rng_pm_out_end || DEFAULT_RANGES.rng_pm_out_end },
      otIn: { start: schedule.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start, end: schedule.rng_ot_in_end || DEFAULT_RANGES.rng_ot_in_end },
      otOut:{ start: schedule.rng_ot_out_start || DEFAULT_RANGES.rng_ot_out_start, end: schedule.rng_ot_out_end || DEFAULT_RANGES.rng_ot_out_end }
    };

    const amInActual = pickEarliest(rangesForEmp.amIn), amOutActual = pickLatest(rangesForEmp.amOut);
    const pmInActual = pickEarliest(rangesForEmp.pmIn), pmOutActual = pickLatest(rangesForEmp.pmOut);

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otCandidates = times.filter(t => {
      const mins = toMins(t);
      return mins > pmOutRefMins && mins >= toMins(rangesForEmp.otIn.start) && mins <= toMins(rangesForEmp.otIn.end);
    });
    // --- Patched OT In/Out picking (DTR) ---
const otInCandidates = times.filter(t => {
  const m = toMins(t);
  return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otIn.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otIn.end);
});
const otInActual = otInCandidates.length ? otInCandidates[0] : null;

const otOutCandidates = times
  .filter(t => {
    const m = toMins(t);
    return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otOut.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otOut.end);
  })
  .filter(t => !otInActual || toMins(t) >= toMins(otInActual));
const otOutActual = otOutCandidates.length ? otOutCandidates[otOutCandidates.length - 1] : null;
// --- end patch ---

// Saturday fallback: if only a single OUT exists beyond the Saturday end, treat OT as (satEnd -> lastOut)
let otInCalc = otInActual;
let otOutCalc = otOutActual;
try {
  if (__isSaturday && __satEnd) {
    const lastOut = pmOutActual || amOutActual || null;
    const lastOutM = lastOut ? toMins(lastOut) : null;
    const satEndM = toMins(__satEnd);
    if (lastOutM !== null && lastOutM > satEndM) {
      if (!otInCalc) otInCalc = __satEnd;
      if (!otOutCalc) otOutCalc = lastOut;
    }
  }
} catch(e){ console.warn('Saturday OT fallback failed', e); }


    
    
    
    // Recompute regular time deterministically (no dependency on raw 'times' array)
    let totalMins = 0; const grace = Number(schedule.sch_grace) || 0;

    const clampSeg = (inStr, outStr, segStartStr, segEndStr) => {
      // Helper to add minutes
      const addMin = (m, d) => /* no-op placeholder removed */ m; // placeholder
    
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const segStart = toMins(segStartStr), segEndRaw = toMins(segEndStr);
      let segEnd = segEndRaw;
      // Auto-correct common input mistake: PM End typed as AM (e.g., 06:00 instead of 18:00)
      if (segEnd <= segStart && segStart >= 12*60 && segEnd <= 12*60) {
        segEnd += 12*60; // push to PM
      }
      if (segEnd <= segStart) return 0;
      if (inM <= segStart + grace) inM = segStart;
      const endM = Math.min(outM, segEnd);
      return Math.max(0, endM - inM);
    };

    if (__isSaturday && __satStart && __satEnd) {
      // Use the earliest actual IN and latest actual OUT between AM/PM within the Saturday window
      const firstIn  = amInActual || pmInActual || null;
      const lastOut  = pmOutActual || amOutActual || null;
      totalMins = clampSeg(firstIn, lastOut, __satStart, __satEnd);
    } else {
      // Weekdays: compute AM and PM independently; add them
      const hasBridge = !!(amInActual && !amOutActual && !pmInActual && pmOutActual);
      if (hasBridge) {
        const synthAmOut = schedule.sch_am_end || "12:00";
        const synthPmIn  = schedule.sch_pm_start || "13:00";
        totalMins =
          clampSeg(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
          clampSeg(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
      } else {
        const amMins = clampSeg(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
        const pmMins = clampSeg(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
        totalMins = amMins + pmMins;
      }
    }

    const totalRegularDecimal = minsToDecimal(totalMins);
let otMins = 0;
    if(otInCalc && otOutCalc){
      const otStartClamp = Math.max(toMins(otInCalc), toMins(__isSaturday ? (__satEnd || rangesForEmp.otIn.start) : rangesForEmp.otIn.start));
      const otEndClamp   = Math.min(toMins(otOutCalc), toMins(__isSaturday ? '23:59' : (rangesForEmp.otOut.end || rangesForEmp.otIn.end)));
      if(otEndClamp > otStartClamp) otMins = otEndClamp - otStartClamp;
    }
    
    // Saturday definitive OT computation: last OUT beyond Saturday end is OT
    try {
      if (__isSaturday && __satEnd) {
        const lastOut = (pmOutActual || amOutActual || null);
        if (lastOut) {
          const satEndM = toMins(__satEnd);
          const satStartClamp = Math.max(satEndM, toMins(schedule.rng_sat_ot_start || __satEnd || DEFAULT_RANGES.rng_sat_ot_start));
          const satEndClamp   = toMins(schedule.rng_sat_ot_end || DEFAULT_RANGES.rng_sat_ot_end);
          const lastOutM = toMins(lastOut);
          const startM = satStartClamp;
          const endM   = Math.min(lastOutM, satEndClamp);
          const diff = endM - startM;
          if (diff > 0) otMins = diff;
        }
      }
    } catch(e){ console.warn('Saturday OT direct compute failed', e); }
    const otDecimal = minsToDecimal(otMins);

    // --- Begin AM/PM Split Logic ---
    // If this record is flagged for split, render two separate rows (AM and PM)
    // instead of one combined row. A split is recorded in the `splits` object
    // keyed by the employee/date (empId + '___' + date). When a record is
    // split we compute the regular hours and overtime separately for the
    // morning and afternoon using the schedule assigned to that half (any
    // overrides are honoured). Each half has its own project and schedule
    // dropdowns. Grace periods are applied according to the selected schedule.
    const splitKey = empId + '___' + date;
    if (splits && splits[splitKey]) {
      // The employee name used for both halves
      const name = emp ? emp.name : '';
      // Helper to compute minutes for a segment using a specific schedule and grace
      const clampSegHalf = (inStr, outStr, segStartStr, segEndStr, sched) => {
        if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
        let inM = toMins(inStr);
        const outM = toMins(outStr);
        const segStart = toMins(segStartStr);
        let segEnd = toMins(segEndStr);
        // If a PM end is entered as an AM time (e.g., 06:00 instead of 18:00), fix it
        if (segEnd <= segStart && segStart >= 12 * 60 && segEnd <= 12 * 60) segEnd += 12 * 60;
        if (segEnd <= segStart) return 0;
        const g = Number(sched && sched.sch_grace) || 0;
        if (inM <= segStart + g) inM = segStart;
        const endM = Math.min(outM, segEnd);
        return Math.max(0, endM - inM);
      };
      // Computes OT minutes and the actual OT in/out times for the PM half
      const computeOtHalf = (sched) => {
        let otM = 0, otIn = null, otOut = null;
        // Reference end of the PM shift for deciding when OT starts
        let pmOutRef = pmOutActual ? toMins(pmOutActual) : toMins(sched.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end);
        // Check if the date is Saturday and fetch Saturday start/end times
        let isSat = false, satStart = null, satEnd = null;
        try {
          const dow = (function(d){
            const dt = new Date(d + 'T00:00');
            return (isNaN(dt) ? new Date(d) : dt).getDay();
          })(date);
          if (dow === 6) {
            isSat = true;
            satStart = sched.sch_sat_start || sched.sch_am_start || '08:00';
            satEnd   = sched.sch_sat_end   || sched.sch_pm_end || sched.sch_am_end || '11:00';
            pmOutRef = toMins(satEnd);
          }
        } catch(e) { /* ignore errors */ }
        // Build OT range windows using schedule or defaults
        const rng = {
          otIn: {
            start: sched.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start,
            end:   sched.rng_ot_in_end   || DEFAULT_RANGES.rng_ot_in_end
          },
          otOut: {
            start: sched.rng_ot_out_start || DEFAULT_RANGES.rng_ot_out_start,
            end:   sched.rng_ot_out_end   || DEFAULT_RANGES.rng_ot_out_end
          }
        };
        // Identify candidate OT IN times (first punch beyond pmOutRef in window)
        const otInCands = times.filter(t => {
          const m = toMins(t);
          return m > pmOutRef && m >= toMins(isSat ? satEnd : rng.otIn.start) && m <= toMins(isSat ? '23:59' : rng.otIn.end);
        });
        otIn = otInCands.length ? otInCands[0] : null;
        // Identify candidate OT OUT times (last punch beyond pmOutRef in window and after OT IN)
        const otOutCands = times.filter(t => {
          const m = toMins(t);
          return m > pmOutRef && m >= toMins(isSat ? satEnd : rng.otOut.start) && m <= toMins(isSat ? '23:59' : rng.otOut.end);
        }).filter(t => !otIn || toMins(t) >= toMins(otIn));
        otOut = otOutCands.length ? otOutCands[otOutCands.length - 1] : null;
        // Saturday fallback: treat a single OUT beyond Saturday end as OT
        if (isSat && satEnd) {
          const lastOut = pmOutActual || amOutActual || null;
          const lastOutM = lastOut ? toMins(lastOut) : null;
          const satEndM = toMins(satEnd);
          if (lastOutM !== null && lastOutM > satEndM) {
            if (!otIn) otIn = satEnd;
            if (!otOut) otOut = lastOut;
          }
        }
        // Compute OT minutes within clamped OT window
        if (otIn && otOut) {
          const startClamp = Math.max(toMins(otIn), toMins(isSat ? (satEnd || rng.otIn.start) : rng.otIn.start));
          const endClamp   = Math.min(toMins(otOut), toMins(isSat ? '23:59' : (rng.otOut.end || rng.otIn.end)));
          if (endClamp > startClamp) otM = endClamp - startClamp;
        }
        // Extra Saturday computation: last out beyond Saturday end counts fully as OT
        try {
          if (isSat && satEnd) {
            const lastOut = (pmOutActual || amOutActual || null);
            if (lastOut) {
              const satEndM = toMins(satEnd);
              const satStartClamp = Math.max(satEndM, toMins(sched.rng_sat_ot_start || DEFAULT_RANGES.rng_sat_ot_start));
              const satEndClamp   = toMins(sched.rng_sat_ot_end || DEFAULT_RANGES.rng_sat_ot_end);
              const lastOutM = toMins(lastOut);
              const startM = satStartClamp;
              const endM   = Math.min(lastOutM, satEndClamp);
              const diff = endM - startM;
              if (diff > 0) otM = diff;
            }
          }
        } catch(e) { /* ignore */ }
        return { mins: otM, otIn: otIn, otOut: otOut };
      };
      // Build two rows for AM and PM
      ['AM', 'PM'].forEach(function(half) {
        // Build keys for schedule and project overrides for this half
        const halfKey = empId + '___' + date + '___' + half;
        const schedIdHalf = (overridesSchedules && overridesSchedules[halfKey]) ? overridesSchedules[halfKey] : scheduleIdForEmp;
        const schedHalf = storedSchedules[schedIdHalf] || DEFAULT_SCHEDULE;
        // Regular minutes with grace for this half
        let regMinsHalf = 0;
        if (half === 'AM') {
          regMinsHalf = clampSegHalf(amInActual, amOutActual, schedHalf.sch_am_start || DEFAULT_SCHEDULE.sch_am_start, schedHalf.sch_am_end || DEFAULT_SCHEDULE.sch_am_end, schedHalf);
        } else {
          regMinsHalf = clampSegHalf(pmInActual, pmOutActual, schedHalf.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start, schedHalf.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end, schedHalf);
        }
        const regDecHalf = minsToDecimal(regMinsHalf);
        // OT calculation only applies to PM half
        let otDecHalf = '0.00';
        let otInHalf = null, otOutHalf = null;
        if (half === 'PM') {
          const otRes = computeOtHalf(schedHalf);
          otDecHalf = minsToDecimal(otRes.mins);
          otInHalf = otRes.otIn;
          otOutHalf = otRes.otOut;
        }
        // Determine project override for this half
        let projIdHalf;
        if (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey)) {
          projIdHalf = overridesProjects[halfKey];
        } else {
          projIdHalf = empProjId;
        }
        const trHalf = document.createElement('tr');
        let html = '';
        html += '<td>' + empId + '</td>';
        html += '<td>' + (name || '') + '</td>';
        // Placeholder cells for project and schedule dropdowns
        html += '<td></td><td></td>';
        html += '<td>' + date + '</td>';
        // Clock in/out for this half; blank for the other half
        if (half === 'AM') {
          html += (amInActual ? '<td>' + amInActual + '</td>' : '<td class="missing">—</td>');
          html += (amOutActual ? '<td>' + amOutActual + '</td>' : '<td class="missing">—</td>');
          html += '<td class="missing">—</td><td class="missing">—</td>';
        } else {
          html += '<td class="missing">—</td><td class="missing">—</td>';
          html += (pmInActual ? '<td>' + pmInActual + '</td>' : '<td class="missing">—</td>');
          html += (pmOutActual ? '<td>' + pmOutActual + '</td>' : '<td class="missing">—</td>');
        }
        // OT columns: only filled in for PM row
        if (half === 'PM') {
          html += (otInHalf ? '<td>' + otInHalf + '</td>' : '<td class="missing">—</td>');
          html += (otOutHalf ? '<td>' + otOutHalf + '</td>' : '<td class="missing">—</td>');
        } else {
          html += '<td class="missing">—</td><td class="missing">—</td>';
        }
        // Regular hours and OT hours columns
        html += '<td>' + regDecHalf + '</td><td>' + otDecHalf + '</td>';
        // Split action (unsplit) button
        html += '<td><button type="button" onclick="(function(){ splits[\'' + splitKey + '\'] = false; saveSplits(); renderResults(); })()">Unsplit</button></td>';
        trHalf.innerHTML = html;
        // Highlight if half-specific overrides are set
        const hasOverride = (overridesSchedules && overridesSchedules[halfKey]) || (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey));
        if (hasOverride) {
          trHalf.style.backgroundColor = '#fff3cd';
        }
        // Replace project cell with dropdown
        const pc = trHalf.cells[2];
        if (pc) {
          pc.innerHTML = '';
          pc.appendChild(buildProjectDropdownHalf(empId, date, half, projIdHalf));
        }
        // Replace schedule cell with dropdown
        const sc = trHalf.cells[3];
        if (sc) {
          sc.innerHTML = '';
          sc.appendChild(buildScheduleDropdownHalf(empId, date, half, schedIdHalf));
        }
        tbody.appendChild(trHalf);
      });
      // Skip default combined row rendering
      continue;
    }
    // --- End AM/PM Split Logic ---

    const name = emp ? emp.name : '';
    const scheduleName = storedSchedules[scheduleIdForEmp] ? storedSchedules[scheduleIdForEmp].name + (scheduleIdForEmp===defaultScheduleId ? ' (Default)' : '') : '';
    const projectName = (empProjId && storedProjects[empProjId]) ? storedProjects[empProjId].name : (emp && !emp.projectId ? '' : '');

    const cell = (v) => v ? '<td>'+v+'</td>' : '<td class="missing">—</td>';
    const tr = document.createElement('tr');
    tr.innerHTML =
      '<td>'+empId+'</td><td>'+name+'</td><td>'+projectName+'</td><td>'+scheduleName+'</td><td>'+date+'</td>' +
      cell(amInActual) + cell(amOutActual) + cell(pmInActual) + cell(pmOutActual) +
      (otInCalc ? '<td>'+otInCalc+'</td>' : '<td class=\"missing\">—</td>') +
      (otOutCalc ? '<td>'+otOutCalc+'</td>' : '<td class=\"missing\">—</td>') +
      '<td>'+totalRegularDecimal+'</td><td>'+otDecimal+'</td>' +
      '<td><button type="button" onclick="(function(){ splits[\'' + empId + '___' + date + '\'] = true; saveSplits(); renderResults(); })()">Split</button></td>';
    if(overridesSchedules[overrideKey] || overridesProjects[overrideKeyProj] !== undefined){
      tr.style.backgroundColor = '#fff3cd';
    }
    const projCell = tr.cells[2];
    if(projCell){ projCell.innerHTML = ''; projCell.appendChild(buildProjectDropdown(empId, date, empProjId)); }
    const schedCell = tr.cells[3];
    if(schedCell){ schedCell.innerHTML = ''; schedCell.appendChild(buildScheduleDropdown(empId, date, scheduleIdForEmp)); }
    tbody.appendChild(tr);
  }

  document.getElementById('downloadCSV').style.display = document.querySelectorAll('#resultsTable tbody tr').length ? 'inline-block' : 'none';
}

document.getElementById('addProjectBtn').addEventListener('click', ()=>{
  const name = document.getElementById('projectNameInput').value.trim();
  if(!name) return alert('Enter project name');
  const id = 'proj_' + Date.now();
  storedProjects[id] = { name };
  document.getElementById('projectNameInput').value='';
  saveProjectsToLS();
});
document.getElementById('clearProjectsBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all projects?')) return;
  storedProjects = {}; saveProjectsToLS();
});

ensureSchedules();
renderScheduleSelector();
renderScheduleEditor();
renderEmployees();
renderProjects();
renderProjectFilterOptions();
const savedFilter = localStorage.getItem(LS_FILTER_PROJECT);
if(document.getElementById('filterProject') && savedFilter && [...document.getElementById('filterProject').options].some(o=>o.value===savedFilter)){
  document.getElementById('filterProject').value = savedFilter;
  currentProjectFilter = savedFilter;
}
renderResults();
document.addEventListener('DOMContentLoaded', function () {
  const dlBtn = document.getElementById('downloadEmployeesCSV');
  if (dlBtn) {
    dlBtn.addEventListener('click', () => {
      const rows = [['ID','Name','Hourly Rate','Bank Account','Schedule','Project']];
      Object.keys(storedEmployees).forEach(id => {
        const emp = storedEmployees[id] || {};
        const schedName = storedSchedules[emp.scheduleId]?.name || '';
        const projName = storedProjects[emp.projectId]?.name || '';
        const bank = emp.bankAccount || '';
      rows.push([id, emp.name || '', emp.hourlyRate || '', bank, schedName, projName]);
      });
      const csv = rows.map(r => r.map(v => {
        const s = String(v ?? '');
        return (s.includes(',') || s.includes('"') || s.includes('\\n'))
          ? '"' + s.replace(/"/g,'""') + '"'
          : s;
      }).join(',')).join('\\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'employees_backup.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
  }
});
  </script>
  <script>
function computeHoursForDateRange(startDate, endDate) {
  const totalsReg = {};
  const totalsOT = {};
  Object.keys(storedEmployees).forEach(id => {
    totalsReg[id] = 0;
    totalsOT[id] = 0;
  });

  const keys = Object.keys(storedSchedules).length ? storedSchedules : {default: DEFAULT_SCHEDULE};
  const grouped = {};

  for (const r of storedRecords) {
    if (startDate && r.date < startDate) continue;
    if (endDate && r.date > endDate) continue;
    const emp = storedEmployees[r.empId];
    if (!emp) continue;
    const dayKey = r.date + '___' + r.empId;
    if (!grouped[dayKey]) grouped[dayKey] = [];
    grouped[dayKey].push(r.time);
  }

  const toMins = hm => { const [h,m] = hm.split(':').map(Number); return h*60+m; };
  const minsToDec = mins => mins / 60;

  for (const key in grouped) {
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId];
    if (!emp) continue;

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if (overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = keys[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);

    const times = [...new Set(grouped[key])].sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    const amInActual = pickEarliest({start: schedule.rng_am_in_start, end: schedule.rng_am_in_end});
    const amOutActual = pickLatest({start: schedule.rng_am_out_start, end: schedule.rng_am_out_end});
    const pmInActual = pickEarliest({start: schedule.rng_pm_in_start, end: schedule.rng_pm_in_end});
    const pmOutActual = pickLatest({start: schedule.rng_pm_out_start, end: schedule.rng_pm_out_end});

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otInActual = pickEarliest({start: schedule.rng_ot_in_start, end: schedule.rng_ot_in_end});
    const otOutActual = pickLatest({start: schedule.rng_ot_out_start, end: schedule.rng_ot_out_end});

    let regMins = 0;
    const grace = Number(schedule.sch_grace) || 0;
    const segMins = (inStr, outStr, segStartStr, segEndStr) => {
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const sS = toMins(segStartStr), sEraw = toMins(segEndStr);
      let sE = sEraw;
      if (sE <= sS && sS >= 12*60 && sE <= 12*60) sE += 12*60; // fix 06:00 vs 18:00 typo
      if (sE <= sS) return 0;
      if (inM <= sS + grace) inM = sS; // grace on start
      const endM = Math.min(outM, sE);
      return Math.max(0, endM - inM);
    };
    // Normal pairs
    regMins += segMins(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
    regMins += segMins(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
    // Bridge case: AM IN + PM OUT only
    if (regMins === 0 && amInActual && !amOutActual && !pmInActual && pmOutActual) {
      const synthAmOut = schedule.sch_am_end || "12:00";
      const synthPmIn  = schedule.sch_pm_start || "13:00";
      regMins =
        segMins(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
        segMins(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
    }
    totalsReg[empId] += minsToDec(regMins);

    if (otInActual && otOutActual && toMins(otInActual) > pmOutRefMins) {
      totalsOT[empId] += minsToDec(toMins(otOutActual) - toMins(otInActual));
    }
  }
  return { totalsReg, totalsOT };
}
const dtrStartEl = document.getElementById('filterStart');
const dtrEndEl = document.getElementById('filterEnd');

function calculatePayrollFromRecords(){
  try { if (typeof renderResults === 'function') renderResults(); } catch(e){ console.warn('renderResults failed', e); }

  regHours = {};
  otHours = {};

  const tbody = document.querySelector('#resultsTable tbody');

  if (tbody) {
    [...tbody.querySelectorAll('tr')].forEach(tr => {
      const cells = tr.cells || [];
      const empId = (cells[0]?.textContent || '').trim();
      const reg = parseFloat((cells[11]?.textContent || '0').replace(/[^0-9.\-]/g,'')) || 0;
      const ot  = parseFloat((cells[12]?.textContent || '0').replace(/[^0-9.\-]/g,'')) || 0;
      if (!empId) return;
      regHours[empId] = (regHours[empId] || 0) + reg;
      otHours[empId]  = (otHours[empId]  || 0) + ot;
    });
  }
  try {
    localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
    localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
  } catch(e){ console.warn('LS save failed', e); }
  Object.keys(storedEmployees||{}).forEach(id => {
    if (!payrollRates[id] || payrollRates[id] === 0) {
      payrollRates[id] = storedEmployees[id]?.hourlyRate || 0;
    }
  });

  try { localStorage.setItem(LS_RATES, JSON.stringify(payrollRates)); } catch(e){}
  try { if (typeof renderTable==='function') renderTable(); } catch(e){ console.warn('renderTable failed', e); }
}

weekStartEl.addEventListener('change', () => {
  if (dtrStartEl) dtrStartEl.value = weekStartEl.value;
  calculatePayrollFromRecords();
  try { renderResults(); } catch(e){}
});
weekEndEl.addEventListener('change', () => {
  if (dtrEndEl) dtrEndEl.value = weekEndEl.value;
  calculatePayrollFromRecords();
  try { renderResults(); } catch(e){}
});
if (dtrStartEl) {
  dtrStartEl.addEventListener('change', () => {
    weekStartEl.value = dtrStartEl.value;
    calculatePayrollFromRecords();
  });
}
if (dtrEndEl) {
  dtrEndEl.addEventListener('change', () => {
    weekEndEl.value = dtrEndEl.value;
    calculatePayrollFromRecords();
  });
}

tabs.tabPayroll.addEventListener('click', () => {
  if (dtrStartEl && !weekStartEl.value) weekStartEl.value = dtrStartEl.value;
  if (dtrEndEl && !weekEndEl.value) weekEndEl.value = dtrEndEl.value;
  calculatePayrollFromRecords();
});
function backupData() {
  const data = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    data[key] = localStorage.getItem(key);
  }
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'payroll_backup.json';
  a.click();
}

function restoreData(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      for (const key in data) {
        localStorage.setItem(key, data[key]);
      }
      alert('Data restored! Reloading...');
      location.reload();
    } catch (err) {
      alert('Invalid backup file.');
    }
  };
  reader.readAsText(file);
}
document.addEventListener('DOMContentLoaded', () => {
  const container = document.createElement('div');
  container.style.marginTop = '20px';
  container.innerHTML = `
    <hr>
    <h3>Data Backup & Restore</h3>
    <button id="backupBtn">Backup Data</button>
    <input type="file" id="restoreInput" style="display:none;" />
    <button id="restoreBtn">Restore Data</button>
  `;
  document.body.appendChild(container);

  document.getElementById('backupBtn').addEventListener('click', backupData);
  document.getElementById('restoreBtn').addEventListener('click', () => {
    document.getElementById('restoreInput').click();
  });
  document.getElementById('restoreInput').addEventListener('change', function(){
    if (this.files.length) restoreData(this.files[0]);
  });
});
  </script>
 
<!-- Manual DTR Modal -->
<div id="manualDtrModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:1000; align-items:center; justify-content:center;">
  <div style="background:white; padding:20px; border-radius:8px; width:320px; max-width:95vw;">
    <h3 style="margin-top:0;">Enter Manual DTR</h3>
    <label>Employee:<br/>
      <select id="manualEmpSelect" style="width:100%;"></select>
    </label><br/><br/>
    <label>Date:<br/>
      <input type="date" id="manualDate" style="width:100%;"/>
    </label><br/><br/>
    <label>Time:<br/>
      <input type="time" id="manualTime" style="width:100%;"/>
    </label><br/><br/>
    <div style="text-align:right; display:flex; gap:8px; justify-content:flex-end;">
      <button id="cancelManualDtr">Cancel</button>
      <button id="saveManualDtr" class="primary">Save</button>
    </div>
  </div>
</div>

<script>
(function(){
  function openManualModal(){
    const modal = document.getElementById('manualDtrModal');
    const empSelect = document.getElementById('manualEmpSelect');
    const manualDate = document.getElementById('manualDate');
    const manualTime = document.getElementById('manualTime');
    if(!modal || !empSelect) return;
    empSelect.innerHTML = '';
    try {
      Object.keys(storedEmployees || {}).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        const nm = (storedEmployees[id] && storedEmployees[id].name) ? storedEmployees[id].name : '';
        opt.textContent = nm ? `${nm} (${id})` : id;
        empSelect.appendChild(opt);
      });
    } catch(e) {}
    manualDate.value = '';
    manualTime.value = '';
    modal.style.display = 'flex';
  }
  function closeManualModal(){
    const modal = document.getElementById('manualDtrModal');
    if(modal) modal.style.display = 'none';
  }
  function wireManualDTR(){
    const btn = document.getElementById('manualDtrBtn');
    const cancelBtn = document.getElementById('cancelManualDtr');
    const saveBtn = document.getElementById('saveManualDtr');
    if(btn) btn.addEventListener('click', openManualModal);
    if(cancelBtn) cancelBtn.addEventListener('click', closeManualModal);
    if(saveBtn) saveBtn.addEventListener('click', function(){
      const empId = (document.getElementById('manualEmpSelect')||{}).value;
      const dateVal = (document.getElementById('manualDate')||{}).value;
      const timeVal = (document.getElementById('manualTime')||{}).value;
      if(!empId || !dateVal || !timeVal){
        alert('Please fill all fields.');
        return;
      }
      try {
        storedRecords.push({ empId: String(empId), date: dateVal, time: timeVal });
        localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
      } catch(e) { console.error('Saving manual DTR failed', e); }
      closeManualModal();
      if(typeof renderResults === 'function') renderResults();
    });
  }
  function ensureActionsHeader(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const theadRow = table.querySelector('thead tr');
    if(theadRow && !theadRow.querySelector('.actions-header')){
      const th = document.createElement('th');
      th.textContent = 'Actions';
      th.classList.add('actions-header');
      theadRow.appendChild(th);
    }
  }
  function addDtrDeleteButtons(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    ensureActionsHeader();
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => {
      if(tr.querySelector('.dtr-del-btn')) return;
      const td = document.createElement('td');
      td.className = 'actions-cell';
      const btn = document.createElement('button');
      btn.textContent = 'Delete';
      btn.className = 'dtr-del-btn';
      btn.addEventListener('click', () => {
        // Get empId and date from row cells (empId at col 0, date at col 4)
        const empIdCell = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
        const dateCell  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
        if(!empIdCell || !dateCell) return;
        if(!confirm(`Delete all DTR entries for ${empIdCell} on ${dateCell}?`)) return;
        try {
          for(let i = storedRecords.length - 1; i >= 0; i--){
            const rec = storedRecords[i];
            if(String(rec.empId) === String(empIdCell) && rec.date === dateCell){
              storedRecords.splice(i, 1);
            }
          }
          localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
          renderResults();
        } catch(e){ console.error('DTR delete failed', e); }
      });
      td.appendChild(btn);
      tr.appendChild(td);
    });
  }
  function patchRenderResults(){
    if(typeof renderResults !== 'function') return false;
    const original = renderResults;
    window.renderResults = function(){
      const res = original.apply(this, arguments);
      try { addDtrDeleteButtons(); } catch(e){}
      return res;
    };
    try { addDtrDeleteButtons(); } catch(e){}
    return true;
  }
  function init(){
    wireManualDTR();
    if(!patchRenderResults()){
      const iv = setInterval(() => {
        if(patchRenderResults()) clearInterval(iv);
      }, 200);
      setTimeout(() => clearInterval(iv), 6000);
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<script>
(function(){
  function q(id){ return document.getElementById(id); }
  function toMins(hm){ if(!hm) return null; var p=hm.split(':'), h=+p[0]||0, m=+p[1]||0; return h*60+m; }
  function minsToDec(mins){ return Math.round((mins/60)*100)/100; }
  function uniqSort(arr){ var seen={}, out=[]; for(var i=0;i<arr.length;i++){ var v=arr[i]; if(!seen[v]){ seen[v]=1; out.push(v);} } out.sort(); return out; }
  function max0(x){ return x>0?x:0; }

  // Extend tabs registry
  if (typeof tabs !== 'undefined' && tabs){
    tabs.tabProjectTotals   = document.getElementById('tabProjectTotals');
    tabs.panelProjectTotals = document.getElementById('panelProjectTotals');
  }

  // Wrap showTab to support projectTotals
  if (typeof showTab === 'function'){
    var _showTab = showTab;
    window.showTab = function(name){
      _showTab(name);
      if (name === 'projectTotals'){
        if (tabs.tabProjectTotals) tabs.tabProjectTotals.classList.add('active');
        if (tabs.panelProjectTotals) tabs.panelProjectTotals.classList.add('active');
        renderProjectTotals();
      }
    };
  }

  // Click to open our tab
  if (tabs && tabs.tabProjectTotals){
    tabs.tabProjectTotals.addEventListener('click', function(){ showTab('projectTotals'); });
  }

  // Re-render when date range changes while active
  ['weekStart','weekEnd'].forEach(function(id){
    var el = q(id);
    if (el) el.addEventListener('change', function(){
      if (tabs && tabs.tabProjectTotals && tabs.tabProjectTotals.classList.contains('active')) renderProjectTotals();
    });
  });

  
  // DTR name search live filter
  if (document.getElementById('dtrSearchName')) {
    document.getElementById('dtrSearchName').addEventListener('input', ()=>{
      renderResults();
    });
  }
// CSV export
  var dl = q('downloadProjectTotalsCSV');
  if (dl) dl.addEventListener('click', exportProjectTotalsCSV);

  // Core compute: honors date range + per-day project/schedule overrides + schedule windows, grace, OT windows
  function computeProjectTotals(startDate, endDate){
    var empMap = (typeof storedEmployees!=='undefined' && storedEmployees) || {};
    var schedMap = (typeof storedSchedules!=='undefined' && storedSchedules) || {};
    var defSchedId = (typeof defaultScheduleId!=='undefined' && defaultScheduleId) || null;
    var records = (typeof storedRecords!=='undefined' && storedRecords) || [];
    var projMap = (typeof storedProjects!=='undefined' && storedProjects) || {};
    var ovSched = (typeof overridesSchedules!=='undefined' && overridesSchedules) || {};
    var ovProj  = (typeof overridesProjects!=='undefined' && overridesProjects) || {};
    var DEF     = (typeof DEFAULT_SCHEDULE!=='undefined' && DEFAULT_SCHEDULE) || {};

    var dayGroups = {};
    for (var i=0;i<records.length;i++){
      var r = records[i];
      if (startDate && r.date < startDate) continue;
      if (endDate && r.date > endDate) continue;
      if (!empMap[r.empId]) continue;
      var key = r.date + '___' + r.empId;
      if (!dayGroups[key]) dayGroups[key] = [];
      dayGroups[key].push(r.time);
    }

    var totals = {}; // projectId => { name, reg, ot, total, employees:{} }
    var keys = Object.keys(dayGroups);
    for (var k=0;k<keys.length;k++){
      var key = keys[k];
      var parts = key.split('___');
      var date = parts[0], empId = parts[1];
      var emp = empMap[empId]; if (!emp) continue;

      var ovKey = empId + '___' + date;
      var projId = (ovProj.hasOwnProperty(ovKey) ? ovProj[ovKey] : (emp.projectId || '')) || '';
      var projName = (projId && projMap[projId]) ? (projMap[projId].name || projId) : '(No project)';

      var schedId = emp.scheduleId || defSchedId;
      if (ovSched[ovKey]) schedId = ovSched[ovKey];
      var S = (schedId && schedMap[schedId]) ? schedMap[schedId] : DEF;

      var times = uniqSort(dayGroups[key]);

      var win = {
        amIn:  {start:S.rng_am_in_start||'05:00', end:S.rng_am_in_end||'09:00'},
        amOut: {start:S.rng_am_out_start||'11:30', end:S.rng_am_out_end||'12:30'},
        pmIn:  {start:S.rng_pm_in_start||'12:30', end:S.rng_pm_in_end||'14:30'},
        pmOut: {start:S.rng_pm_out_start||'15:00', end:S.rng_pm_out_end||'20:00'},
        otIn:  {start:S.rng_ot_in_start||'19:00', end:S.rng_ot_in_end||'22:00'},
        otOut: {start:S.rng_ot_out_start||'19:00', end:S.rng_ot_out_end||'23:59'}
      };
      function pickEarliest(w){ for(var i2=0;i2<times.length;i2++){ var t=times[i2]; if(t>=w.start && t<=w.end) return t; } return null; }
      function pickLatest(w){ var last=null; for(var j2=0;j2<times.length;j2++){ var t2=times[j2]; if(t2>=w.start && t2<=w.end) last=t2; } return last; }

      var amIn  = pickEarliest(win.amIn);
      var amOut = pickLatest(win.amOut);
      var pmIn  = pickEarliest(win.pmIn);
      var pmOut = pickLatest(win.pmOut);

      var pmOutRefMins = pmOut ? toMins(pmOut) : toMins(S.sch_pm_end || '17:00');

      var otIn = null, otOut = null;
      for (var x=0;x<times.length;x++){
        var tt = times[x]; var m = toMins(tt);
        if (m>pmOutRefMins && m>=toMins(win.otIn.start) && m<=toMins(win.otIn.end)){ otIn = tt; break; }
      }
      for (var y=times.length-1;y>=0;y--){
        var tt2 = times[y]; var m2 = toMins(tt2);
        if (m2>pmOutRefMins && m2>=toMins(win.otOut.start) && m2<=toMins(win.otOut.end)){ otOut = tt2; if(!otIn || toMins(otOut)>=toMins(otIn)) break; }
      }

      var grace = Number(S.sch_grace)||0;
      var regMins = 0;

      if (amIn && pmOut && !amOut && !pmIn){
        var saS = toMins(S.sch_am_start||'08:00'), saE = toMins(S.sch_am_end||'12:00');
        var spS = toMins(S.sch_pm_start||'13:00'), spE = toMins(S.sch_pm_end||'17:00');
        var amInM = toMins(amIn), pmOutM = toMins(pmOut);
        var late = Math.max(0, amInM - saS);
        var under = Math.max(0, spE - pmOutM);
        var full = max0(saE-saS) + max0(spE-spS);
        regMins = (late <= grace) ? max0(full - under) : max0(full - late - under);
      } else {
        if (amIn && amOut){
          var inM = toMins(amIn), sS = toMins(S.sch_am_start||'08:00'), sE = toMins(S.sch_am_end||'12:00');
          if (inM <= sS + grace) inM = sS;
          var endM = Math.min(toMins(amOut), sE);
          if (endM > inM) regMins += (endM - inM);
        }
        if (pmIn && pmOut){
          var inM2 = toMins(pmIn), sS2 = toMins(S.sch_pm_start||'13:00'), sE2 = toMins(S.sch_pm_end||'17:00');
          if (inM2 <= sS2 + grace) inM2 = sS2;
          var endM2 = Math.min(toMins(pmOut), sE2);
          if (endM2 > inM2) regMins += (endM2 - inM2);
        }
      }

      var otMins = 0;
      if (otIn && otOut){
        var startClamp = Math.max(toMins(otIn), toMins(win.otIn.start));
        var endClamp   = Math.min(toMins(otOut), toMins(win.otOut.end));
        if (endClamp > startClamp) otMins = endClamp - startClamp;
      }

      var regDec = minsToDec(regMins);
      var otDec  = minsToDec(otMins);

      if (!totals[projId]) totals[projId] = { name: projName, reg: 0, ot: 0, total: 0, gross: 0, employees: {} };
      totals[projId].reg   = Math.round((totals[projId].reg + regDec)*100)/100;
      totals[projId].ot    = Math.round((totals[projId].ot  + otDec )*100)/100;
      totals[projId].total = Math.round((totals[projId].total + regDec + otDec)*100)/100;
      var rate = (emp && typeof emp.hourlyRate==='number') ? emp.hourlyRate : (+emp.hourlyRate||0);
      var otp = (document.getElementById('otMultiplier')&&parseFloat(document.getElementById('otMultiplier').value)) || 1.5;
      var grossInc = (regDec*rate) + (otDec*rate*otp);
      totals[projId].gross = Math.round((totals[projId].gross + grossInc)*100)/100;
      if (!totals[projId].employees[empId]) totals[projId].employees[empId] = { id: empId, name: (emp && emp.name) || '', reg: 0, ot: 0, total: 0, gross: 0, perDay: {} };
totals[projId].employees[empId].reg = Math.round((totals[projId].employees[empId].reg + regDec)*100)/100;
totals[projId].employees[empId].ot  = Math.round((totals[projId].employees[empId].ot  + otDec )*100)/100;
totals[projId].employees[empId].total = Math.round((totals[projId].employees[empId].total + regDec + otDec)*100)/100;
totals[projId].employees[empId].gross = Math.round((totals[projId].employees[empId].gross + grossInc)*100)/100;
// NEW: record per-day total hours (reg + OT) for this date
var _dTot = Math.round(((regDec + otDec))*100)/100;
if (!totals[projId].employees[empId].perDay) totals[projId].employees[empId].perDay = {};
totals[projId].employees[empId].perDay[date] = Math.round(((totals[projId].employees[empId].perDay[date]||0) + _dTot)*100)/100;
    }

    var rows = [];
    var pids = Object.keys(totals).sort(function(a,b){ var A=totals[a].name||''; var B=totals[b].name||''; return A.localeCompare(B); });
    for (var z=0; z<pids.length; z++){
      var pid = pids[z];
      var _emps = Object.values(totals[pid].employees || {}).sort(function(a,b){return (a.name||'').localeCompare(b.name||'') || String(a.id).localeCompare(String(b.id));});
rows.push({ projectId: pid, project: totals[pid].name, reg: totals[pid].reg, ot: totals[pid].ot, total: totals[pid].total, gross: totals[pid].gross, employees: Object.keys(totals[pid].employees).length , breakdown: _emps });
    }
    if (rows.length){
      var g = {reg:0, ot:0, total:0, gross:0, employees:0};
      for (var r=0;r<rows.length;r++){ g.reg+=rows[r].reg; g.ot+=rows[r].ot; g.total+=rows[r].total; g.gross+=rows[r].gross; g.employees+=rows[r].employees; }
      rows.push({ projectId: '__grand__', project: 'Grand Total', reg: Math.round(g.reg*100)/100, ot: Math.round(g.ot*100)/100, total: Math.round(g.total*100)/100, gross: Math.round(g.gross*100)/100, employees: g.employees });
    }
    return rows;
  }

  function renderProjectTotals(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var tbody = document.querySelector('#projectTotalsTable tbody'); if (!tbody) return;
    var data = computeProjectTotals(ws, we);
    tbody.innerHTML = '';
    if (!data.length){
      var tr = document.createElement('tr'); tr.innerHTML = '<td colspan="5" class="muted">No data for the selected date range.</td>'; tbody.appendChild(tr); return;
    }
    for (var i=0;i<data.length;i++){
      var row = data[i]; var tr = document.createElement('tr');
      tr.className = 'proj-row';
      if (row.projectId==='__grand__') tr.style.fontWeight = '700';
      tr.innerHTML = '<td>'+row.project+'</td>'
                   + '<td style="text-align:right">'+row.reg.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.ot.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.total.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+(row.gross!=null?row.gross.toFixed(2):'0.00')+'</td>'
                   + '<td style="text-align:right">'+row.employees+'</td>';
      tbody.appendChild(tr);
      if (row.projectId !== '__grand__' && Array.isArray(row.breakdown) && row.breakdown.length){
        tr.classList.add('has-breakdown');
        var dtr = document.createElement('tr');
        dtr.className = 'proj-emp-breakdown';
        var inner = '<td colspan="6" style="background:#f9fafb">'
  + '<div style="padding:8px 6px">'
  + '<strong>Employees (per-day hours):</strong>';

function dateRangeList(s, e){
  var out = []; if(!s || !e) return out;
  var d = new Date(s); var end = new Date(e);
  while (d <= end){ out.push(new Date(d)); d.setDate(d.getDate()+1); }
  return out;
}
var days = dateRangeList(ws, we);

inner += '<table style="width:100%;margin-top:6px;border-collapse:collapse">'
      + '<thead><tr>'
      + '<th style="text-align:left">ID</th>'
      + '<th style="text-align:left">Name</th>';
for (var di=0; di<days.length; di++){
  var dt = days[di];
  var label = (dt.getMonth()+1)+'/'+dt.getDate();
  inner += '<th style="text-align:right">'+label+'</th>';
}
inner += '<th style="text-align:right">Total Hrs</th>';
inner += '<th style="text-align:right">Total Amount</th>';
inner += '</tr></thead><tbody>';

for (var k=0;k<row.breakdown.length;k++){
  var e = row.breakdown[k];
  var totalRow = Number(e.total||0);
  var grossRow = Number(e.gross||0);
  inner += '<tr>'
        + '<td>'+(e.id ?? '')+'</td>'
        + '<td>'+(e.name ?? '')+'</td>';
  var perDay = (e.perDay||{});
  for (var di=0; di<days.length; di++){
    var dkey = days[di].toISOString().slice(0,10);
    var val = Number(perDay[dkey]||0).toFixed(2);
    inner += '<td style="text-align:right">'+val+'</td>';
  }
  inner += '<td style="text-align:right">'+ totalRow.toFixed(2) +'</td>';
  inner += '<td style="text-align:right">'+ grossRow.toFixed(2) +'</td>';
  inner += '</tr>';
}
inner += '</tbody></table></div></td>';
        dtr.innerHTML = inner;
        dtr.style.display = 'none';
        tbody.appendChild(dtr);
        // toggle and show detailed modal when a project row is clicked. The modal
        // provides a comprehensive breakdown and grand totals for the selected project.
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (function(detailRow, rowObj){
          return function(){
            // Show modal with project breakdown if available
            if (typeof showProjectReport === 'function') showProjectReport(rowObj);
            // Toggle the inline breakdown row visibility for quick reference
            if (detailRow) {
              detailRow.style.display = (detailRow.style.display === 'none' ? 'table-row' : 'none');
            }
          };
        })(dtr, row));
      }

    }
  }

  function exportProjectTotalsCSV(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var data = computeProjectTotals(ws, we);
    var rows = [['Week Start','Week End','Project','Regular Hours','OT Hours','Total Hours','Gross Amount','Employees']];
    for (var i=0;i<data.length;i++){ var r = data[i]; rows.push([ws,we,r.project,r.reg.toFixed(2),r.ot.toFixed(2),r.total.toFixed(2),(r.gross!=null?r.gross.toFixed(2):'0.00'),r.employees]); }
var csv = rows.map(function(r){
      return r.map(function(s){
        s = String(s==null?'':s);
        var needs = (s.indexOf('"')>=0) || (s.indexOf(',')>=0) || (s.indexOf('\n')>=0);
        if (needs) s = '"' + s.split('"').join('""') + '"';
        return s;
      }).join(',');
    }).join('\n');
    var blob = new Blob([csv], {type:'text/csv'}); var url = URL.createObjectURL(blob);
    var a = document.createElement('a'); a.href=url; a.download='project_totals.csv'; document.body.appendChild(a); a.click(); a.remove();
  }
})();
</script>


<script>
// --- Employees: small UX helpers ---
document.addEventListener('DOMContentLoaded', () => {
  const panel = document.querySelector('#panelEmployees');
  if (!panel) return;
  const form = panel.querySelector('form');
  if (!form) return;

  // Wrap form in a card if not already
  if (!form.closest('.form-card')) {
    const card = document.createElement('div');
    card.className = 'form-card';
    form.parentNode.insertBefore(card, form);
    card.appendChild(form);
  }

  // Enter-to-submit (except textarea)
  form.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
      e.preventDefault();
      const submit = form.querySelector('button[type="submit"], input[type="submit"]');
      if (submit) submit.click();
    }
  });

  // Auto-mark dangerous buttons
  form.querySelectorAll('button, input[type="button"]').forEach(el => {
    const text = (el.textContent || el.value || '').toLowerCase();
    if (/(clear|reset|delete|remove)/.test(text)) el.classList.add('btn-danger');
    if (/(save|add|submit|create)/.test(text)) el.classList.add('btn-primary');
  });

  // Group actions into a row if not already
  const actions = Array.from(form.querySelectorAll('button, input[type="submit"], input[type="button"]'));
  if (actions.length) {
    let bar = form.querySelector('.form-actions');
    if (!bar) {
      bar = document.createElement('div');
      bar.className = 'form-actions';
      // move trailing buttons into actions
      actions.forEach(btn => {
        if (!btn.closest('.form-actions')) bar.appendChild(btn);
      });
      form.appendChild(bar);
    }
  }
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('printProjectTotalsBtn');
  if (btn) btn.addEventListener('click', function(){ window.print(); });
});
</script>

<!-- Enhanced DTR Print -->
<script>
// Enhanced DTR print: clones the results table, removes 'Split' or 'Actions' columns,
// replaces dropdowns with selected text, and shows date range/project filter.
(function(){
  function printDTR(){
    try{
      var table = document.getElementById('resultsTable');
      if(!table){ alert('No DTR records to print.'); return; }
      // Capture selected texts from original selects
      var selectedTexts = [];
      var origSelects = table.querySelectorAll('select');
      origSelects.forEach(function(osel){
        var txt = '';
        try{
          var idx = osel.selectedIndex;
          if(idx >= 0 && osel.options[idx]){
            var opt = osel.options[idx];
            txt = (opt.textContent || opt.innerText || opt.value || '');
          }
        }catch(e){}
        selectedTexts.push(txt);
      });
      // Clone table
      var clone = table.cloneNode(true);
      // Remove columns labelled 'Split' or 'Actions'
      var dropIdx = [];
      clone.querySelectorAll('thead th').forEach(function(th, idx){
        var t = (th.textContent || '').trim().toLowerCase();
        if(t === 'split' || t === 'actions') dropIdx.push(idx);
      });
      if(dropIdx.length){
        // Remove header cells
        var headers = clone.querySelectorAll('thead th');
        headers.forEach(function(th, idx){
          if(dropIdx.indexOf(idx) !== -1){ th.remove(); }
        });
        // Remove columns from each row (in reverse order)
        clone.querySelectorAll('tbody tr').forEach(function(tr){
          var cells = tr.children;
          var sorted = dropIdx.slice().sort(function(a,b){ return b - a; });
          sorted.forEach(function(i){
            if(cells[i]) cells[i].remove();
          });
        });
      }
      // Replace select dropdowns in the clone with the captured text values
      var cloneSelects = clone.querySelectorAll('select');
      cloneSelects.forEach(function(csel, i){
        var td = csel.closest('td');
        if(td){ td.textContent = selectedTexts[i] || ''; }
      });
      // Remove any buttons inside the cloned table (e.g., split buttons)
      clone.querySelectorAll('button').forEach(function(btn){ btn.remove(); });
      // Build header for print
      var start = (document.getElementById('weekStart') || {}).value || '';
      var end = (document.getElementById('weekEnd') || {}).value || '';
      var hdr = 'Daily Time Records';
      if(start || end){
        hdr += ' — ' + (start || '') + (end ? (' to ' + end) : '');
      }
      // Determine project filter text
      var filterSel = document.getElementById('filterProject');
      var filterTxt = '';
      if(filterSel){
        try{
          if(!filterSel.value || filterSel.value === 'all'){
            filterTxt = 'All Projects';
          } else {
            var o = filterSel.options[filterSel.selectedIndex];
            filterTxt = (o && (o.textContent || o.innerText || '')) || '';
          }
        }catch(e){}
      }
      var w = window.open('', '_blank', 'width=900,height=700');
      w.document.write('<!DOCTYPE html><html><head><meta charset="utf-8"><title>DTR Records</title>');
      w.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;margin:16px} h2{margin:0 0 6px} .muted{color:#555;margin:0 0 12px;font-size:12px} table{width:100%;border-collapse:collapse} th,td{border:1px solid #000;padding:6px;text-align:center;font-size:12px} th{background:#eee}</style>');
      w.document.write('</head><body>');
      w.document.write('<h2>' + hdr.replace(/</g, '&lt;') + '</h2>');
      if(filterTxt){
        w.document.write('<div class="muted">Project filter: ' + filterTxt.replace(/</g, '&lt;') + '</div>');
      }
      w.document.write(clone.outerHTML);
      w.document.write('</body></html>');
      w.document.close();
      w.focus();
      w.print();
    }catch(err){
      alert('Unable to print DTR: ' + err);
    }
  }
  window.printDTR = printDTR;
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id === 'printDtrBtn'){
      printDTR();
    }
  });
})();
</script>



<script>
(function(){
  function _parse(n){ var x=parseFloat(String(n||'').replace(/[^0-9.\-]/g,'')); return isNaN(x)?0:x; }
  function _fmt(n){
    var v = Math.round((n||0)*100)/100;
    try { return v.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }
    catch(e){ return v.toFixed(2); }
  }

  // === Payroll ===
  function updatePayrollGrandTotals(){
    var tb = document.querySelector('#payrollTable tbody');
    var foot = document.querySelector('#payrollTotalsFoot');
    if (!tb || !foot) return;
    var t = {regHrs:0, otHrs:0, rate:0, regPay:0, otPay:0, grossPay:0, pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, totalDed:0, netPay:0};
    tb.querySelectorAll('tr').forEach(function(tr){
      t.regHrs   += _parse(tr.querySelector('.regHrs')?.value);
      t.otHrs    += _parse(tr.querySelector('.otHrs')?.value);
      t.rate     += _parse(tr.querySelector('.rate')?.value);
      t.regPay   += _parse(tr.querySelector('.regPay')?.textContent);
      t.otPay    += _parse(tr.querySelector('.otPay')?.textContent);
      t.grossPay += _parse(tr.querySelector('.grossPay')?.textContent);
      t.pagibig  += _parse(tr.querySelector('.pagibig')?.textContent);
      t.philhealth += _parse(tr.querySelector('.philhealth')?.textContent);
      t.sss      += _parse(tr.querySelector('.sss')?.textContent);
      t.loanSSS  += _parse(tr.querySelector('.loanSSS')?.value);
      t.loanPI   += _parse(tr.querySelector('.loanPI')?.value);
      t.vale     += _parse(tr.querySelector('.vale')?.value);
      t.valeWed  += _parse(tr.querySelector('.valeWed')?.value);
      t.totalDed += _parse(tr.querySelector('.totalDed')?.textContent);
      t.netPay   += _parse(tr.querySelector('.netPay')?.textContent);
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updatePayrollGrandTotals = updatePayrollGrandTotals;

  // === Deductions ===
  function _dedHeadMap(){
    var ths = Array.from(document.querySelectorAll('#deductionsTable thead th')).map(function(th){return (th.textContent||'').trim().toLowerCase();});
    function findIdx(keys){
      for (var i=0;i<ths.length;i++){
        for (var j=0;j<keys.length;j++){
          if (ths[i] === keys[j]) return i;
        }
        // loose contains for variants like "vale wed" vs "wed vale"
        for (var j=0;j<keys.length;j++){
          if (ths[i].indexOf(keys[j]) !== -1) return i;
        }
      }
      return -1;
    }
    return {
      id: findIdx(['id','emp id','employee id']),
      name: findIdx(['name','employee name']),
      pagibig: findIdx(['pag-ibig','pag ibig','pagibig']),
      philhealth: findIdx(['philhealth','phil health']),
      sss: findIdx(['sss']),
      loanSSS: findIdx(['sss loan','loan sss']),
      loanPI: findIdx(['pag-ibig loan','pag ibig loan','loan pi','pi loan']),
      vale: findIdx(['vale']),
      valeWed: findIdx(['vale wed','wed vale']),
      total: findIdx(['total','total deductions','total ded'])
    };
  }

  function updateDeductionsGrandTotals(){
    var tb = document.querySelector('#deductionsTable tbody');
    var foot = document.querySelector('#deductionsTable_foot');
    if (!tb || !foot) return;
    var map = _dedHeadMap();
    var t = {pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, total:0};
    tb.querySelectorAll('tr').forEach(function(tr){
      var c = tr.cells||[];
      function cell(idx){ return (idx>=0 && idx<c.length) ? c[idx].textContent : ''; }
      t.pagibig   += _parse(cell(map.pagibig));
      t.philhealth+= _parse(cell(map.philhealth));
      t.sss       += _parse(cell(map.sss));
      t.loanSSS   += _parse(cell(map.loanSSS));
      t.loanPI    += _parse(cell(map.loanPI));
      t.vale      += _parse(cell(map.vale));
      t.valeWed   += _parse(cell(map.valeWed));
      t.total     += _parse(cell(map.total));
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updateDeductionsGrandTotals = updateDeductionsGrandTotals;

  // Run on load
  function _initTotals(){
    try{ updatePayrollGrandTotals(); }catch(e){}
    try{ updateDeductionsGrandTotals(); }catch(e){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', _initTotals);
  } else { _initTotals(); }

  // Observe table changes to keep totals fresh
  try {
    var mo = new MutationObserver(function(){ try{updatePayrollGrandTotals();}catch(e){}; try{updateDeductionsGrandTotals();}catch(e){}; });
    var ptb = document.querySelector('#payrollTable tbody');
    var dtb = document.querySelector('#deductionsTable tbody');
    if (ptb) mo.observe(ptb, {childList:true, subtree:true, characterData:true});
    if (dtb) mo.observe(dtb, {childList:true, subtree:true, characterData:true});
  } catch(e){}

  // Also recalc on payroll inputs
  document.addEventListener('input', function(ev){
    if ((ev.target && ev.target.closest('#payrollTable'))) {
      try{ updatePayrollGrandTotals(); }catch(e){}
    }
  });

  // Patch into existing functions if present
  try {
    var _calcAll = window.calculateAll;
    if (typeof _calcAll === 'function'){
      window.calculateAll = function(){ var r = _calcAll.apply(this, arguments); try{updatePayrollGrandTotals();}catch(e){}; try{updateDeductionsGrandTotals();}catch(e){}; return r; };
    }
  } catch(e){}
  try {
    var _renderDed = window.renderDeductionsTable;
    if (typeof _renderDed === 'function'){
      window.renderDeductionsTable = function(){ var r = _renderDed.apply(this, arguments); try{updateDeductionsGrandTotals();}catch(e){}; return r; };
    }
  } catch(e){}

})();</script>

<script>
// Custom Payroll CSV export: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay)
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // If "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = parts[0].trim();
      var rhs = (parts.slice(1).join(',')).trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Else assume "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){
    var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,''));
    return isNaN(n) ? 0 : n;
  }
  function csvEscape(val){
    var s = String(val==null?'':val);
    var needs = /[",\n]/.test(s);
    if (needs) s = '"' + s.replace(/"/g,'""') + '"';
    return s;
  }
  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};
    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || '';
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });
    // Serialize
    return rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n');
  }
  function attachPayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    btn.addEventListener('click', function(){
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(e){
        console.error('Payroll CSV export failed', e);
        alert('Failed to build Payroll CSV.');
      }
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachPayrollCsv);
  } else {
    attachPayrollCsv();
  }
})();
</script>

<script>
// === Override Payroll CSV to: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay) ===
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // Handle "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = (parts.shift()||'').trim();
      var rhs = (parts.join(',')||'').trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Default "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){ var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,'')); return isNaN(n)?0:n; }
  function csvEscape(val){ var s=String(val==null?'':val); return /[",\n]/.test(s) ? ('"'+s.replace(/"/g,'""')+'"') : s; }

  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};

    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || ''; // Employee Account Number
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });

    return rows.map(r => r.map(csvEscape).join(',')).join('\n');
  }

  function overridePayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    // Remove all existing listeners by cloning
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(err){
        console.error('Payroll CSV export failed', err);
        alert('Failed to build Payroll CSV.');
      }
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', overridePayrollCsv);
  } else {
    overridePayrollCsv();
  }
})();
</script>


</div>






<link rel="preconnect" href="https://cdn.jsdelivr.net"/>


</div>




<script>
document.addEventListener('DOMContentLoaded', function(){
  var nodes = document.querySelectorAll('#cloudSyncCard');
  for (var i=1;i<nodes.length;i++){ nodes[i].remove(); }
});
</script>

<!-- Payslip Button functionality -->
<script>
// Add click listener for payslip buttons on payroll table
document.addEventListener('click', function(e) {
  var target = e.target;
  if (target && target.classList && target.classList.contains('payslipBtn')) {
    // Find the row for this button
    var row = target.closest('tr');
    if (!row) return;
    // Extract basic employee info
    var id = (row.cells[0]?.textContent || '').trim();
    var name = (row.cells[1]?.textContent || '').trim();
    // Helper to get value from input or text content
    function getVal(sel, prop) {
      var el = row.querySelector(sel);
      if (!el) return '';
      if (prop === 'value') return el.value || '';
      return el.textContent || '';
    }
    var reg = getVal('.regHrs', 'value');
    var ot = getVal('.otHrs', 'value');
    var rate = getVal('.rate', 'value');
    var regPay = getVal('.regPay', 'textContent');
    var otPay = getVal('.otPay', 'textContent');
    var gross = getVal('.grossPay', 'textContent');
    var pagibig = getVal('.pagibig', 'textContent');
    var philhealth = getVal('.philhealth', 'textContent');
    var sss = getVal('.sss', 'textContent');
    var sssLoan = getVal('.loanSSS', 'value');
    var piLoan = getVal('.loanPI', 'value');
    var valeAmt = getVal('.vale', 'value');
    var wedValeAmt = getVal('.valeWed', 'value');
    var total = getVal('.totalDed', 'textContent');
    var net = getVal('.netPay', 'textContent');
    // Period from week start/end inputs if available
    var ws = (typeof weekStartEl !== 'undefined' && weekStartEl) ? (weekStartEl.value || '') : '';
    var we = (typeof weekEndEl !== 'undefined' && weekEndEl) ? (weekEndEl.value || '') : '';
    // Build payslip HTML
    var html = '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Payslip - ' + name + '</title>' +
      '<style>body{font-family:Arial,Helvetica,sans-serif;padding:20px;line-height:1.4;} h2{text-align:center;}' +
      'table{border-collapse:collapse;width:100%;margin-top:12px;} th,td{border:1px solid #e2e8f0;padding:8px;text-align:left;font-size:14px;}' +
      'th{background:#f1f5f9;}</style></head><body>' +
      '<h2>Payslip</h2>' +
      '<p><strong>Employee ID:</strong> ' + id + '</p>' +
      '<p><strong>Name:</strong> ' + name + '</p>' +
      '<p><strong>Period:</strong> ' + ws + (we ? (' to ' + we) : '') + '</p>' +
      '<table>' +
      '<tr><th>Description</th><th>Value</th></tr>' +
      '<tr><td>Regular Hours</td><td>' + reg + '</td></tr>' +
      '<tr><td>OT Hours</td><td>' + ot + '</td></tr>' +
      '<tr><td>Hourly Rate</td><td>' + rate + '</td></tr>' +
      '<tr><td>Regular Pay</td><td>' + regPay + '</td></tr>' +
      '<tr><td>OT Pay</td><td>' + otPay + '</td></tr>' +
      '<tr><td>Gross Pay</td><td>' + gross + '</td></tr>' +
      '<tr><td>Pag-IBIG</td><td>' + pagibig + '</td></tr>' +
      '<tr><td>PhilHealth</td><td>' + philhealth + '</td></tr>' +
      '<tr><td>SSS</td><td>' + sss + '</td></tr>' +
      '<tr><td>SSS Loan</td><td>' + sssLoan + '</td></tr>' +
      '<tr><td>Pag-IBIG Loan</td><td>' + piLoan + '</td></tr>' +
      '<tr><td>Vale</td><td>' + valeAmt + '</td></tr>' +
      '<tr><td>Wed Vale</td><td>' + wedValeAmt + '</td></tr>' +
      '<tr><td>Total Deductions</td><td>' + total + '</td></tr>' +
      '<tr><th>Net Pay</th><th>' + net + '</th></tr>' +
      '</table>' +
      '</body></html>';
    // Open new window and write payslip content
    var w = window.open('', '', 'width=600,height=800');
    if (!w) return; // popup blocked
    w.document.open();
    w.document.write(html);
    w.document.close();
    w.focus();
    // Uncomment the line below to automatically trigger print dialog
    // setTimeout(function(){ w.print(); }, 0);
  }
});
</script>







<script>
(function(){
  const LS_FROM = 'dtr_filter_from';
  const LS_TO   = 'dtr_filter_to';

  function getEl(id){ return document.getElementById(id); }
  function loadSaved(){
    const from = localStorage.getItem(LS_FROM) || '';
    const to   = localStorage.getItem(LS_TO) || '';
    const f = getEl('dtrDateFrom'), t = getEl('dtrDateTo');
    if (f) f.value = from;
    if (t) t.value = to;
  }

  function withinRange(dateStr, from, to){
    if (!dateStr) return false;
    const s = dateStr.trim();
    if (!s) return false;
    if (from && s < from) return false;
    if (to   && s > to)   return false;
    return true;
  }

  function applyDtrDateFilter(){
    const f = getEl('dtrDateFrom')?.value || '';
    const t = getEl('dtrDateTo')?.value || '';
    try { localStorage.setItem(LS_FROM, f); } catch(e){}
    try { localStorage.setItem(LS_TO, t); } catch(e){}

    const tbody = document.querySelector('#resultsTable tbody');
    if (!tbody) return;
    const hasRange = !!(f || t);

    Array.from(tbody.rows).forEach(tr=>{
      // Adjust the index below if your Date column index is different.
      // Assuming the "Date" column is 4 (0-based), change as necessary.
      const dateStr = (tr.cells[4]?.textContent || '').trim();
      const show = !hasRange || withinRange(dateStr, f, t);
      tr.style.display = show ? '' : 'none';
    });
  }

  function hookUI(){
    const f = getEl('dtrDateFrom');
    const t = getEl('dtrDateTo');
    const c = getEl('dtrDateClear');
    if (f) f.addEventListener('change', applyDtrDateFilter);
    if (t) t.addEventListener('change', applyDtrDateFilter);
    if (c) c.addEventListener('click', ()=>{
      if (f) f.value = '';
      if (t) t.value = '';
      try { localStorage.removeItem(LS_FROM); } catch(e){}
      try { localStorage.removeItem(LS_TO); } catch(e){}
      applyDtrDateFilter();
    });
  }

  function monkeyPatchRender(){
    const orig = window.renderResults;
    if (typeof orig === 'function') {
      window.renderResults = function(){
        orig.apply(this, arguments);
        applyDtrDateFilter();
      };
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    // Inject controls right before #resultsTable if not already in DOM.
    if (!document.getElementById('dtrDateControls')){
      const table = document.getElementById('resultsTable');
      if (table && table.parentNode){
        const wrapper = document.createElement('div');
        wrapper.innerHTML = '<!-- DTR Date Finder Controls -->\n<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;">\n  <label style="display:flex;align-items:center;gap:.35rem;">\n    <span>Date:</span>\n    <input id="dtrDateFrom" type="date" />\n  </label>\n  <span>—</span>\n  <label>\n    <input id="dtrDateTo" type="date" />\n  </label>\n  <button id="dtrDateClear" type="button">Clear</button>\n</div>';
        table.parentNode.insertBefore(wrapper.firstElementChild, table);
      }
    }
    loadSaved();
    hookUI();
    monkeyPatchRender();
    applyDtrDateFilter();
  });
})();
</script>


<script>
// === Thousands Separator Formatting for Amounts (Payroll & Deductions) ===
(function(){
  // Format helper: 1,234.56
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function formatAllNumbers(){
    var sels = '#payrollTable td.num, #payrollTable tfoot td.num, #deductionsTable td.num';
    document.querySelectorAll(sels).forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g, '').trim();
      var num = parseFloat(raw);
      if (isFinite(num)) td.textContent = fmt(num);
    });
  }

  // Patch calculateAll to apply formatting after calculations
  function patchCalculateAll(){
    try{
      var orig = window.calculateAll;
      if (typeof orig === 'function'){
        window.calculateAll = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      } else {
        // If not defined yet, retry after load
        document.addEventListener('DOMContentLoaded', function(){
          if (typeof window.calculateAll === 'function'){
            patchCalculateAll(); 
            try { formatAllNumbers(); } catch(e){}
          }
        });
      }
    }catch(e){}
  }

  // Also patch renderDeductionsTable so that a manual refresh there also formats
  function patchRenderDeductions(){
    try{
      var orig = window.renderDeductionsTable;
      if (typeof orig === 'function'){
        window.renderDeductionsTable = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      }
    }catch(e){}
  }

  // Initial hooks
  patchCalculateAll();
  patchRenderDeductions();
  document.addEventListener('DOMContentLoaded', function(){
    try { formatAllNumbers(); } catch(e){}
  });
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function formatAllNumbers(){
    var sels = '#payrollTable td.num,#payrollTable tfoot td.num,#deductionsTable td.num,#reportTable td.num,#reportTable tfoot td.num';
    document.querySelectorAll(sels).forEach(td=>{
      var raw=(td.textContent||'').replace(/,/g,'').trim();
      var num=parseFloat(raw);
      if(isFinite(num)) td.textContent=fmt(num);
    });
  }
  function patch(fnName){
    var orig=window[fnName];
    if(typeof orig==='function'){
      window[fnName]=function(){
        var out=orig.apply(this,arguments);
        try{formatAllNumbers();}catch(e){}
        return out;
      }
    }
  }
  patch('calculateAll');
  patch('renderDeductionsTable');
  patch('renderReportTable');
  document.addEventListener('DOMContentLoaded',formatAllNumbers);
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function formatCells(cells){
    cells.forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (raw === '') return;
      var num = parseFloat(raw);
      if (isFinite(num)) td.textContent = fmt(num);
    });
  }
  function formatProjectTotals(){
    var tbl = document.getElementById('projectTotalsTable');
    if(!tbl) return;
    var tds = tbl.querySelectorAll('tbody td, tfoot td');
    formatCells(Array.from(tds));
  }
  function formatProjectModal(){
    var box = document.getElementById('projectReportContent');
    if (!box) return;
    var tds = box.querySelectorAll('td');
    formatCells(Array.from(tds));
  }
  // Patch showProjectReport to format modal numbers
  (function(){
    var orig = window.showProjectReport;
    if (typeof orig === 'function'){
      window.showProjectReport = function(){
        var out = orig.apply(this, arguments);
        try { formatProjectModal(); } catch(e){}
        return out;
      };
    }
  })();
  // Observe changes on the project totals table and auto-format
  document.addEventListener('DOMContentLoaded', function(){
    formatProjectTotals();
    var tbl = document.getElementById('projectTotalsTable');
    if (tbl && window.MutationObserver){
      var timer = null;
      var mo = new MutationObserver(function(){
        clearTimeout(timer);
        timer = setTimeout(formatProjectTotals, 50);
      });
      mo.observe(tbl.tBodies[0] || tbl, { childList: true, subtree: true });
    }
  });
})();
</script>


<script>
(function(){
  const ACTIVE_KEY = 'payroll_active';            // object map: key=start_end, value={startDate,endDate,rows,totals}
  const CURRENT_KEY = 'current_active_week';      // string: "YYYY-MM-DD__YYYY-MM-DD"
  const HIST_KEY = 'payroll_hist';                // existing history (may contain locked snapshots)

  function loadJSON(k, d){ try{ return JSON.parse(localStorage.getItem(k)||''); }catch(_){ return d; } }
  function saveJSON(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){} }

  function toKey(s,e){ return (s||'') + '__' + (e||''); }
  function fromKey(k){ const [s,e] = String(k||'').split('__'); return {start:s,end:e}; }

  // Build active store from locked history (one-time, if active is empty)
  function maybeSeedActiveFromHistory(){
    let active = loadJSON(ACTIVE_KEY, null);
    if (active && typeof active === 'object' && Object.keys(active).length) return;
    const hist = loadJSON(HIST_KEY, []);
    active = {};
    (hist||[]).forEach(s=>{
      if (s && s.startDate && s.endDate /* && s.locked */){
        const key = toKey(s.startDate, s.endDate);
        active[key] = { startDate:s.startDate, endDate:s.endDate, rows:s.rows||[], totals:s.totals||{} };
      }
    });
    saveJSON(ACTIVE_KEY, active);
  }

  function upsertActiveWeek(snap){
    if(!snap || !snap.startDate || !snap.endDate) return;
    const key = toKey(snap.startDate, snap.endDate);
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    active[key] = { startDate:snap.startDate, endDate:snap.endDate, rows:snap.rows||[], totals:snap.totals||{} };
    saveJSON(ACTIVE_KEY, active);
    localStorage.setItem(CURRENT_KEY, key);
  }

  function listActiveWeeks(){
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    return Object.keys(active).sort().map(k=>({ key:k, ...fromKey(k) }));
  }

  function fillActiveWeekSelects(){
    const weeks = listActiveWeeks();
    const current = localStorage.getItem(CURRENT_KEY) || (weeks[weeks.length-1]?.key || '');
    if (current) localStorage.setItem(CURRENT_KEY, current);
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      const prev = sel.value;
      sel.innerHTML='';
      weeks.forEach(w=>{
        const opt = document.createElement('option');
        opt.value = w.key;
        opt.textContent = `${w.start} → ${w.end}`;
        sel.appendChild(opt);
      });
      if (weeks.length){
        sel.value = current && weeks.some(w=>w.key===current) ? current : weeks[weeks.length-1].key;
      }
    });
  }

  function applyActiveWeekToGlobals(){
    const key = localStorage.getItem(CURRENT_KEY) || '';
    const {start,end} = fromKey(key);
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    if (ws) ws.value = start || ws.value;
    if (we) we.value = end || we.value;
  }

  function reRenderAll(){
    try{ applyActiveWeekToGlobals(); }catch(_){}
    try{ window.renderResults && renderResults(); }catch(_){}
    try{ window.calculateAll && calculateAll(); }catch(_){}
    try{ window.renderReportTable && renderReportTable(); }catch(_){}
    // If you have totals/project tables:
    try{ window.formatAllNumbers && formatAllNumbers(); }catch(_){}
  }

  // Wire the dropdown "Apply" buttons
  function hookActiveWeekUI(){
    document.querySelectorAll('.refreshActiveWeek').forEach(btn=>{
      if (btn._wired) return;
      btn._wired = true;
      btn.addEventListener('click', ()=>{
        const sel = btn.parentElement && btn.parentElement.querySelector('.activeWeekSelect');
        if (!sel) return;
        localStorage.setItem(CURRENT_KEY, sel.value || '');
        applyActiveWeekToGlobals();
        reRenderAll();
      });
    });
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      if (sel._wired) return;
      sel._wired = true;
      sel.addEventListener('change', ()=>{
        localStorage.setItem(CURRENT_KEY, sel.value || '');
      });
    });
  }

  // Patch Generate to upsert into ACTIVE store (while keeping existing behavior)
  function patchGenerateToActive(){
    const btn = document.getElementById('dashGenerate');
    if (!btn || btn._activeWired) return;
    btn._activeWired = true;
    btn.addEventListener('click', async ()=>{
      // Wait a moment for existing listeners to compute tables, then capture
      setTimeout(()=>{
        try{
          const ws = document.getElementById('weekStart')?.value;
          const we = document.getElementById('weekEnd')?.value;
          if (!ws || !we) return;
          // Try to collect current payroll rows/totals from existing functions
          if (typeof window.buildSnapshot === 'function'){
            (async ()=>{
              const snap = await window.buildSnapshot(ws, we);
              if (snap) upsertActiveWeek(snap);
              fillActiveWeekSelects();
            })();
          } else {
            // Fallback: minimal capture from payroll table if present
            const rows = [];
            document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
              rows.push(Array.from(tr.cells).map(td=>td.textContent.trim()));
            });
            upsertActiveWeek({ startDate: ws, endDate: we, rows, totals:{} });
            fillActiveWeekSelects();
          }
        }catch(_){}
      }, 300);
    }, { capture: true });
  }

  // On load
  document.addEventListener('DOMContentLoaded', ()=>{
    maybeSeedActiveFromHistory();
    fillActiveWeekSelects();
    hookActiveWeekUI();
    patchGenerateToActive();

    // Optional: visually disable weekStart/weekEnd outside dashboard
    try {
      const onHashChange = () => {
        const ws = document.getElementById('weekStart');
        const we = document.getElementById('weekEnd');
        // Simple heuristic: if dashboard panel isn't visible, keep inputs disabled
        const dash = document.getElementById('panelDashboard');
        const dashActive = dash && (dash.classList.contains('active') || dash.style.display !== 'none');
        const disabled = !dashActive;
        if (ws) ws.disabled = disabled;
        if (we) we.disabled = disabled;
      };
      onHashChange();
      window.addEventListener('hashchange', onHashChange);
    } catch(_){}
  });
})();
</script>

<!-- Script to manage global Active Payroll dropdown and New Period functionality -->
<script>
(function(){
  const PAYROLL_HIST_KEY = 'payroll_hist';
  const LS_ACTIVE_INDEX = 'payroll_active_index';

  function loadHistory() {
    try {
      const hist = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
      return Array.isArray(hist) ? hist : [];
    } catch (e) {
      return [];
    }
  }

  function saveActiveIndex(idx) {
    localStorage.setItem(LS_ACTIVE_INDEX, String(idx));
  }

  function getActiveIndex() {
    const v = localStorage.getItem(LS_ACTIVE_INDEX);
    const n = v == null ? -1 : parseInt(v, 10);
    return Number.isFinite(n) ? n : -1;
  }

  function updateWeekInputs(snap) {
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    if (ws) ws.value = (snap && snap.startDate) || '';
    if (we) we.value = (snap && snap.endDate) || '';
    try {
      if (typeof calculatePayrollFromRecords === 'function') {
        calculatePayrollFromRecords();
      }
    } catch (err) {}
  }

  function populateDropdowns() {
    // Prefer the global payrollHistory array if available, else fall back to localStorage
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const history = Array.isArray(hist) ? hist : [];
    // Build list of items with their original indices; sort newest first by start date
    const items = history.map((s, i) => Object.assign({ i: i }, s)).sort((a, b) => {
      return (b.startDate || '').localeCompare(a.startDate || '');
    });
    const globalSelect = document.getElementById('activePayrollSelect');
    const panelSelects = Array.from(document.querySelectorAll('.activeWeekSelect'));
    function fill(selectEl) {
      if (!selectEl) return;
      // Rebuild the dropdown options
      selectEl.innerHTML = '';
      items.forEach(item => {
        const opt = document.createElement('option');
        opt.value = String(item.i);
        opt.textContent = `${item.startDate || ''} — ${item.endDate || ''}${item.locked ? ' (locked)' : ''}`;
        selectEl.appendChild(opt);
      });
      // Always set the selected value to the saved active index so all selectors stay in sync
      const saved = String(getActiveIndex());
      if ([...selectEl.options].some(o => o.value === saved)) {
        selectEl.value = saved;
      } else if (selectEl.options.length) {
        selectEl.selectedIndex = 0;
      }
    }
    fill(globalSelect);
    panelSelects.forEach(sel => {
      if (sel !== globalSelect) fill(sel);
    });
    // after filling, apply active
    const idxVal = parseInt((globalSelect && globalSelect.value) || getActiveIndex(), 10);
    const snap = Number.isFinite(idxVal) ? history[idxVal] : null;
    if (snap) {
      saveActiveIndex(idxVal);
      updateWeekInputs(snap);
    }
  }

  function onSelectChange(e) {
    const idx = parseInt(e.target.value, 10);
    if (!Number.isFinite(idx)) return;
    const history = loadHistory();
    if (!history[idx]) return;
    saveActiveIndex(idx);
    updateWeekInputs(history[idx]);
    // Keep all selects in sync
    populateDropdowns();
  }

  function onNewPeriod() {
    const start = prompt('Enter start date (YYYY-MM-DD):');
    const end = start ? prompt('Enter end date (YYYY-MM-DD):') : null;
    if (!start || !end) return;
    // Use global payrollHistory if available to check for existing ranges
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const exists = hist.some(s => s && s.startDate === start && s.endDate === end);
    if (exists) {
      alert('A payroll snapshot for this date range already exists.');
      return;
    }
    if (typeof buildSnapshot === 'function') {
      (async () => {
        const snap = await buildSnapshot(start, end);
        if (!snap) {
          alert('Payroll table is missing or empty.');
          return;
        }
        const json = JSON.stringify(snap);
        const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        const now = new Date().toISOString();
        const newSnap = { startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false };
        // Push into global payrollHistory if it exists; else push into local history
        if (Array.isArray(window.payrollHistory)) {
          window.payrollHistory.push(newSnap);
          // Persist via existing saveHistory function if available
          if (typeof saveHistory === 'function') saveHistory();
        } else {
          // Fallback: update localStorage directly
          const localHist = loadHistory();
          localHist.push(newSnap);
          localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(localHist));
        }
        // Refresh tables
        if (typeof renderHistory === 'function') {
          try { renderHistory(); } catch (err) {}
        }
        if (typeof renderActivePayrolls === 'function') {
          try { renderActivePayrolls(); } catch (err) {}
        }
        // Compute index for active snapshot using global array or fallback local array
        let idx;
        if (Array.isArray(window.payrollHistory)) {
          idx = window.payrollHistory.length - 1;
        } else {
          const localHist2 = loadHistory();
          idx = localHist2.length - 1;
        }
        saveActiveIndex(idx);
        populateDropdowns();
      })();
    } else {
      alert('buildSnapshot function not available.');
    }
  }

  function onPanelApply(e) {
    const wrap = e.target.closest('.active-week-bar');
    if (!wrap) return;
    const sel = wrap.querySelector('.activeWeekSelect');
    if (!sel) return;
    onSelectChange({ target: sel });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const globalSelect = document.getElementById('activePayrollSelect');
    if (globalSelect) {
      globalSelect.addEventListener('change', onSelectChange);
    }
    const newBtn = document.getElementById('newPayrollPeriod');
    if (newBtn) {
      newBtn.addEventListener('click', onNewPeriod);
    }
    document.addEventListener('click', (e) => {
      if (e.target && e.target.classList && e.target.classList.contains('refreshActiveWeek')) {
        onPanelApply(e);
      }
    });
    populateDropdowns();
  });

  (function() {
    const tbody = document.querySelector('#historyTable tbody');
    if (!tbody) return;
    const observer = new MutationObserver(() => {
      try {
        populateDropdowns();
      } catch (err) {}
    });
    observer.observe(tbody, { childList: true, subtree: false });
  })();
})();
</script>

</body>
</html>
