<!DOCTYPE html>
<html>
 

<!-- === Supabase KV Sync Adapter (no-login, auto-sync) === -->
<script type="module">
// Minimal, no-login cloud persistence by mirroring localStorage to Supabase.
// 1) Create a table in Supabase named: kv_store
//    Columns:
//      key text PRIMARY KEY
//      value jsonb
//      updated_at timestamptz DEFAULT now()
// 2) Turn RLS ON and add permissive policies if you truly want no-login use:
//    - SELECT: USING (true)
//    - INSERT: WITH CHECK (true)
//    - UPDATE: USING (true)  WITH CHECK (true)   // optional; you can omit to prevent edits
//    - DELETE: USING (false)                      // optional; disallow deletes
// 3) Paste your Supabase project URL and anon key below.

import { createClient } from "https://esm.sh/@supabase/supabase-js"

const SUPABASE_URL = window.SUPABASE_URL || "https://qzkzugzfpegozpiqutdv.supabase.co"
const SUPABASE_KEY = window.SUPABASE_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6a3p1Z3pmcGVnb3pwaXF1dGR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4MTc5MDMsImV4cCI6MjA3MTM5MzkwM30.mdFYuFjbRfsILWPkQQmVUCDR7dGqEo-mdPZ6iwolvGk"
const TABLE = "kv_store"
// List of localStorage keys that should be mirrored to Supabase.  If you add
// new keys anywhere in the application that you want to persist across
// devices, add them here as well.  Without inclusion in this list the
// `Storage.prototype.setItem` hook will ignore them and they will remain
// strictly device‚Äëlocal.
const KNOWN_KEYS = [
  "att_employees_v2",
  "att_schedules_v2",
  "att_schedules_default",
  "att_projects_v1",
  "att_filter_project_v1",
  "att_overrides_schedules",
  "att_overrides_projects",
  "att_splits_v1",
  // payroll configuration keys
  "payroll_rates",
  "payroll_reg_hours",
  "payroll_ot_hours",
  "payroll_ot_multiplier",
  "payroll_week_start",
  "payroll_week_end",
  "payroll_deduction_divisor",
  "payroll_sss_table",
  "payroll_loan_sss",
  "payroll_loan_pagibig",
  "payroll_vale",
  "payroll_vale_wed",
  "payroll_hist",
  // additional filter & state keys not previously persisted
  "dtr_filter_from",
  "dtr_filter_to",
  "payroll_active_index"
  ,"payroll_adjustments"
  ,"payroll_pagibig_rate"
  ,"payroll_philhealth_rate"
  ,"payroll_pagibig_table"
  ,"payroll_philhealth_table"
  ,"payroll_adjustment_hours"
]

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

// Expose the Supabase client on the global window so that other
// non‚Äëmodule scripts (e.g. the boot guard) can access it without
// re‚Äëimporting the library.  Also expose the table name used for
// key/value storage.  Without this, any attempt to read from
// Supabase outside of this module would require a duplicate client
// instantiation, and due to the asynchronous execution order of
// module scripts it is not guaranteed that the client would be
// available when the boot guard runs.  Assigning to `window`
// provides a simple, predictable global reference.
window.supabase = supabase;
window.SUPABASE_TABLE = TABLE;

const __origSetItem = Storage.prototype.setItem
const __origRemoveItem = Storage.prototype.removeItem

async function cloudUpsert(key, value) {
  try {
    // Try upsert
    const { error } = await supabase
      .from(TABLE)
      .upsert({ key, value: tryParse(value) }, { onConflict: "key" })
    if (error) console.warn("Supabase upsert error:", error.message)
  } catch (e) { console.warn("Supabase upsert failed", e) }
}
async function cloudDelete(key) {
  try {
    const { error } = await supabase.from(TABLE).delete().eq("key", key)
    if (error) console.warn("Supabase delete error:", error.message)
  } catch (e) { console.warn("Supabase delete failed", e) }
}
function tryParse(v) {
  try { return JSON.parse(v) } catch { return v }
}

// Write-through on any localStorage change
Storage.prototype.setItem = function(k, v) {
  try { __origSetItem.call(this, k, v) } catch {}
  // Only mirror known keys to reduce noise
  if (KNOWN_KEYS.includes(k)) cloudUpsert(k, v)
}
Storage.prototype.removeItem = function(k) {
  try { __origRemoveItem.call(this, k) } catch {}
  if (KNOWN_KEYS.includes(k)) cloudDelete(k)
}

// On first load, pull from cloud and hydrate localStorage automatically.
// If we detect changes vs. current localStorage, we populate and reload once
// so the rest of the app sees the new data without manual "sync".
;(async function initialHydrate(){
  try {
    const { data, error } = await supabase
      .from(TABLE)
      .select("key, value")
      .in("key", KNOWN_KEYS)
    if (error) { console.warn("Supabase fetch error:", error.message); return }
    let changed = false
    ;(data || []).forEach(row => {
      const k = row.key
      const cloudStr = safeStringify(row.value)
      const cur = localStorage.getItem(k)
      if (cloudStr != null && cloudStr !== cur) {
        try { __origSetItem.call(localStorage, k, cloudStr) } catch {}
        changed = true
      }
    })
    if (changed) {
      // One-time reload to let downstream scripts render with hydrated data
      if (!sessionStorage.getItem("__kv_reloaded")) {
        sessionStorage.setItem("__kv_reloaded","1")
        location.reload()
      }
    }
  } catch (e) { console.warn("Initial hydrate failed", e) }
})()

function safeStringify(v){
  try { return typeof v === "string" ? v : JSON.stringify(v) } catch { return null }
}
</script>

<!-- Style to visually and functionally lock panels when payroll data is locked.
     When #panelMain has the 'locked' class, pointer events are disabled on
     all of its children and the panel appears dimmed. This prevents any
     interaction with DTR fields while still allowing navigation to other tabs. -->
<style>
  #panelMain.locked {
    pointer-events: none;
    opacity: 0.6;
  }
</style>
<!-- === / Supabase KV Sync Adapter === -->

<!-- Multi payslip printing functionality -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  var multiBtn = document.getElementById('printAllPayslipsBtn');
  if (multiBtn) {
    multiBtn.addEventListener('click', function() {
      var rows = document.querySelectorAll('#payrollTable tbody tr');
      if (!rows || rows.length === 0) return;
      // Grab period values
      var wsEl = document.getElementById('weekStart');
      var weEl = document.getElementById('weekEnd');
      var ws = wsEl ? (wsEl.value || '') : '';
      var we = weEl ? (weEl.value || '') : '';
      // Start building HTML document
      var html = '<!DOCTYPE html><html><head><meta charset="utf-8"><title>All Payslips</title>' +
        '<style>body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:10px;} .payslip-grid{display:flex;flex-wrap:wrap;} .payslip{width:50%;box-sizing:border-box;padding:10px;border:1px solid #e2e8f0;} table{border-collapse:collapse;width:100%;font-size:12px;} th,td{border:1px solid #e2e8f0;padding:4px;text-align:left;} th{background:#f1f5f9;} .page-break{page-break-after:always;}</style></head><body>';
      html += '<div class="payslip-grid">';
      rows.forEach(function(row, idx) {
        var id = (row.cells[0]?.textContent || '').trim();
        var name = (row.cells[1]?.textContent || '').trim();
        function gv(sel, prop) {
          var el = row.querySelector(sel);
          if (!el) return '';
          return prop === 'value' ? (el.value || '') : (el.textContent || '');
        }
        var reg = gv('.regHrs','value');
        var ot = gv('.otHrs','value');
        var rate = gv('.rate','value');
        var regPay = gv('.regPay','textContent');
        var otPay = gv('.otPay','textContent');
        var gross = gv('.grossPay','textContent');
        var pagibig = gv('.pagibig','textContent');
        var philhealth = gv('.philhealth','textContent');
        var sss = gv('.sss','textContent');
        var sssLoan = gv('.loanSSS','value');
        var piLoan = gv('.loanPI','value');
        var v = gv('.vale','value');
        var vW = gv('.valeWed','value');
        var adj = gv('.adjAmt','textContent');
        var total = gv('.totalDed','textContent');
        var net = gv('.netPay','textContent');
        html += '<div class="payslip">' +
          '<h3>Payslip</h3>' +
          '<p><strong>Employee ID:</strong> ' + id + '</p>' +
          '<p><strong>Name:</strong> ' + name + '</p>' +
          '<p><strong>Period:</strong> ' + ws + (we ? (' to ' + we) : '') + '</p>' +
          '<table>' +
          '<tr><th>Description</th><th>Value</th></tr>' +
          '<tr><td>Regular Hours</td><td>' + reg + '</td></tr>' +
          '<tr><td>OT Hours</td><td>' + ot + '</td></tr>' +
          '<tr><td>Hourly Rate</td><td>' + rate + '</td></tr>' +
          '<tr><td>Regular Pay</td><td>' + regPay + '</td></tr>' +
          '<tr><td>OT Pay</td><td>' + otPay + '</td></tr>' +
          '<tr><td>Gross Pay</td><td>' + gross + '</td></tr>' +
          '<tr><td>Pag-IBIG</td><td>' + pagibig + '</td></tr>' +
          '<tr><td>PhilHealth</td><td>' + philhealth + '</td></tr>' +
          '<tr><td>SSS</td><td>' + sss + '</td></tr>' +
          '<tr><td>SSS Loan</td><td>' + sssLoan + '</td></tr>' +
          '<tr><td>Pag-IBIG Loan</td><td>' + piLoan + '</td></tr>' +
          '<tr><td>Vale</td><td>' + v + '</td></tr>' +
          '<tr><td>Wed Vale</td><td>' + vW + '</td></tr>' +
          '<tr><td>Adjustments</td><td>' + adj + '</td></tr>' +
          '<tr><td>Total Deductions</td><td>' + total + '</td></tr>' +
          '<tr><th>Net Pay</th><th>' + net + '</th></tr>' +
          '</table></div>';
        if ((idx + 1) % 4 === 0 && idx !== rows.length - 1) {
          html += '</div><div class="page-break"></div><div class="payslip-grid">';
        }
      });
      html += '</div></body></html>';
      var w = window.open('', '', 'width=800,height=900');
      if (!w) return;
      w.document.open();
      w.document.write(html);
      w.document.close();
      w.focus();
      // Automatically trigger print dialog after load
      setTimeout(function() { try { w.print(); } catch(e){} }, 0);
    });
  }
});
</script>
  <meta charset="utf-8"/>
  <title>
   Attendance &mdash; Schedules + Ranges (Merged) + Projects
  </title>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <style>
  /*
   * Allow the application to consume the full viewport width so wide tables (like
   * the DTR grid) are not artificially constrained. The original max-width of
   * 1200px caused wide tables to be clipped on larger screens and hid
   * additional columns. Removing the fixed max-width lets the container grow
   * with the window size, and combined with overflow handling on the panel
   * ensures that all columns remain accessible via horizontal scrolling when
   * necessary.
   */
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;max-width:100%;color:#0b1220}
  header{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab-btn{padding:8px 12px;cursor:pointer;border:1px solid #cbd5e1;background:#f8fafc;border-radius:6px}
  .tab-btn.active{background:#0ea5a4;color:#fff}
  section.panel{display:none}
  section.panel.active{display:block;padding-top:8px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  input[type=file],input[type=date],input[type=time],input[type=number],button,select{padding:6px 8px}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border:1px solid #e2e8f0;padding:8px;text-align:center;font-size:13px}
  th{background:#f1f5f9;position:sticky;top:0;z-index:1}
  .missing{background:#ffdede;color:#7a0000;font-weight:700}
  .note{color:#64748b;font-size:13px;margin-top:6px}
  input.cell{width:100%;box-sizing:border-box}
  .small{font-size:12px;color:#64748b}
  .muted{color:#64748b;font-size:12px}
  @media (max-width:800px){th,td{font-size:12px}}
  .section-title{margin-top:12px;margin-bottom:4px;font-weight:700}
  /* Ensure DTR table columns stay visible and don't collapse in Chrome. Allow
     horizontal scrolling if needed by preventing cells from shrinking and
     wrapping. */
  #panelMain {
    overflow-x: auto;
  }
  #panelMain #resultsTable {
    /*
     * Use max-content so the table grows to accommodate all of its columns.
     * This prevents Chrome from collapsing column widths to fit a parent with
     * limited width and ensures that long headers (e.g. "Clock Out 4",
     * "Night Differential") do not disappear. When combined with the
     * overflow-x:auto on #panelMain, a horizontal scrollbar will appear
     * whenever the total table width exceeds the viewport, allowing users to
     * scroll horizontally to view hidden columns.
     */
    table-layout: auto;
    width: max-content;
  }
  #panelMain #resultsTable th,
  #panelMain #resultsTable td {
    white-space: nowrap;
  }

  /* Make the wrapper around the DTR results scrollable on the x-axis. Without
     this wrapper, wide tables can be clipped by parent containers with
     overflow hidden. */
  .results-wrapper {
    overflow-x: auto;
  }
  </style>
  <style>

  /* Hide individual deduction columns in Payroll table (show only Total Deductions).
     After adding the Adjustment Hrs column, the indices shift by one.
     Hide Pag‚ÄëIBIG to Wed Vale columns (cols 10‚Äì16). */
  #payrollTab #payrollTable th:nth-child(10),
  #payrollTab #payrollTable td:nth-child(10),
  #payrollTab #payrollTable th:nth-child(11),
  #payrollTab #payrollTable td:nth-child(11),
  #payrollTab #payrollTable th:nth-child(12),
  #payrollTab #payrollTable td:nth-child(12),
  #payrollTab #payrollTable th:nth-child(13),
  #payrollTab #payrollTable td:nth-child(13),
  #payrollTab #payrollTable th:nth-child(14),
  #payrollTab #payrollTable td:nth-child(14),
  #payrollTab #payrollTable th:nth-child(15),
  #payrollTab #payrollTable td:nth-child(15),
  #payrollTab #payrollTable th:nth-child(16),
  #payrollTab #payrollTable td:nth-child(16) { display: none; }

  
/* ===== Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  #panelProjectTotals, #panelProjectTotals * { visibility: visible !important; }
  #panelProjectTotals { position: absolute; left: 0; top: 0; width: 100%; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}
</style>

  <style id="payrollScopedStyles">
  #panelPayroll {
    --border:#e2e8f0; --bg:#f8fafc; --bg2:#f1f5f9; --text:#0b1220;
    /* Updated accent color to gold */
    --accent:#FFD700; --muted:#64748b;
  }
  #panelPayroll *, #panelPayroll *::before, #panelPayroll *::after { box-sizing:border-box }
  #panelPayroll { color:var(--text) }
  #panelPayroll header { display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;flex-wrap:wrap }
  #panelPayroll h2 { margin:0 }
  #panelPayroll .tabs { display:flex;gap:6px;flex-wrap:wrap }
  #panelPayroll .tab-btn { padding:8px 12px;border:1px solid var(--border);background:white;border-radius:8px;cursor:pointer }
  #panelPayroll .tab-btn.active { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll .tab { display:none }
  #panelPayroll .tab.active { display:block }
  #panelPayroll .controls { display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:10px 0 }
  #panelPayroll label { font-size:12px;color:var(--muted) }
  #panelPayroll input[type=date], 
  #panelPayroll input[type=number], 
  #panelPayroll input[type=text], 
  #panelPayroll select, 
  #panelPayroll button { padding:6px 8px;border:1px solid var(--border);border-radius:6px }
  #panelPayroll button.primary { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll table { border-collapse:collapse;width:100%;margin-top:12px }
  #panelPayroll th, #panelPayroll td { border:1px solid var(--border);padding:8px;text-align:center;font-size:13px }
  #panelPayroll th { background:var(--bg2);position:sticky;top:0;z-index:1 }
  #panelPayroll td.num { text-align:right }
  #panelPayroll input.cell { width:100%;padding:4px;border:1px solid var(--border);border-radius:4px;text-align:right }
  #panelPayroll .note { font-size:12px;color:var(--muted) }
  #panelPayroll .section { background:var(--bg);padding:10px;border:1px solid var(--border);border-radius:10px;margin-top:8px }
  #panelPayroll .danger { color:#b91c1c }
  #panelPayroll .wrap { white-space:normal }

  </style>
  <style id="payroll-tabs-fix">
   #panelPayroll .tab{display:none} #panelPayroll .tab.active{display:block}
  </style>
 
<style>
/* --- Employees: Clean Add Employee UI --- */
#panelEmployees .form-card{
  background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,0.04);margin-bottom:12px;
}
#panelEmployees form{
  display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;align-items:start;
}
#panelEmployees label{display:block;font-size:12px;color:#334155;margin-bottom:6px;font-weight:600;}
#panelEmployees input, #panelEmployees select, #panelEmployees textarea{
  width:100%;padding:10px 12px;border:1px solid #cbd5e1;border-radius:10px;outline:none;
}
#panelEmployees input:focus, #panelEmployees select:focus, #panelEmployees textarea:focus{
  border-color:#64748b;box-shadow:0 0 0 3px rgba(100,116,139,0.15);
}
#panelEmployees input:invalid, #panelEmployees select:invalid, #panelEmployees textarea:invalid{
  border-color:#ef4444;
}
#panelEmployees .form-actions{grid-column:1 / -1;display:flex;gap:10px;justify-content:flex-end;margin-top:2px;}
#panelEmployees button, #panelEmployees input[type="submit"], #panelEmployees input[type="button"]{
  border:1px solid #cbd5e1;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer;background:#f8fafc;
}
#panelEmployees button:hover, #panelEmployees input[type="submit"]:hover, #panelEmployees input[type="button"]:hover{
  filter:brightness(0.98);
}
#panelEmployees .btn-primary{background:#0ea5e9;border-color:#0284c7;color:#fff;}
#panelEmployees .btn-danger{background:#fee2e2;border-color:#fecaca;color:#b91c1c;}
#panelEmployees small.hint{display:block;color:#64748b;margin-top:4px;font-size:11px;}
@media (max-width:1100px){
  #panelEmployees form{grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
}
</style>

<style>

/* ===== Strong Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  section.panel { display: none !important; }
  #panelProjectTotals { 
    position: absolute; left: 0; top: 0; width: 100%;
    display: block !important; 
    visibility: visible !important;
  }
  #panelProjectTotals * { visibility: visible !important; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}

</style>

<style>

/* --- Per-project per page when printing --- */
@media print {
  /* If a project has a breakdown row, break after that row; otherwise break after the project header row */
  #panelProjectTotals tr.proj-emp-breakdown { page-break-after: always; }
  #panelProjectTotals tr.proj-row.no-breakdown { page-break-after: always; }
}

</style>

<style>
#payrollTab #payrollTable tfoot td,
#deductionsTab #deductionsTable tfoot td{ font-weight:700; background:#fff7ed; border-top:2px solid #e2e8f0; }
#payrollTab #payrollTable tfoot td.label-cell,
#deductionsTab #deductionsTable tfoot td.label-cell{ text-align:left; }
#payrollTab #payrollTable tfoot td.num,
#deductionsTab #deductionsTable tfoot td.num{ text-align:right; }
</style>
    <!-- Added payroll dashboard theme -->
    <style>
        /* Override default margins and background */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .app-container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            padding: 30px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }
        .sidebar-header {
            padding: 0 30px 30px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        .logo {
            font-size: 24px;
            font-weight: 800;
            /* Updated logo color to yellow */
            color: #FFD700;
            background: none;
            -webkit-background-clip: border-box;
            -webkit-text-fill-color: #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .nav-menu {
            list-style: none;
            padding: 0 15px;
        }
        .nav-item {
            margin-bottom: 8px;
        }
        .nav-link {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            text-decoration: none;
            color: #6b7280;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        .nav-link:hover {
            background: #f3f4f6;
            color: #374151;
            transform: translateX(5px);
        }
        .nav-link.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 30px;
            /*
             * Permit horizontal scrolling within the main content area. The
             * original style hid any overflow on the x-axis, which meant
             * wide tables (such as the DTR results grid) could not be
             * scrolled into view and appeared to be missing columns. By
             * changing overflow-x to auto, the browser will show a
             * horizontal scrollbar when necessary, ensuring all columns
             * remain accessible.
             */
            overflow-x: auto;
        }
        .content-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .page-title {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .page-subtitle {
            color: #6b7280;
            font-size: 14px;
        }
        .date-range {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .date-input {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
        .date-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .warning-note {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #92400e;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 13px;
            margin-top: 15px;
            border-left: 4px solid #f59e0b;
        }
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block;
            }
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 999;
            }
            .sidebar.active {
                transform: translateX(0);
            }
            .main-content {
                margin-left: 0;
                padding: 80px 20px 20px;
            }
            .date-range {
                justify-content: center;
            }
        }
        /* Hide original top-level navigation tabs but keep payroll sub-tabs visible */
        .tabs { display: none !important; }
        /* Explicitly show the sub-tabs inside the Payroll panel. */
    #panelPayroll .tabs {
            display: flex !important;
        }
    </style>
    <!-- Additional styles for new header UI -->
    <style>
      body {
        background: #f8f8f8;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: linear-gradient(135deg, #000 0%, #333 100%);
        color: white;
        padding: 10px 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
      }
      .header .logo {
        font-size: 24px;
        font-weight: 800;
        color: #FFD700;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .header .nav-menu {
        list-style: none;
        display: flex;
        gap: 20px;
        margin: 0;
        padding: 0;
        align-items: center;
      }
      .header .nav-menu .nav-item .nav-link {
        border: none;
        background: none;
        color: white;
        font-weight: 600;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .header .nav-menu .nav-item .nav-link:hover {
        background-color: #FFD700;
        color: #000;
      }
      .header .nav-menu .nav-item .nav-link.active {
        background-color: #FFD700;
        color: #000;
      }
      .sidebar {
        display: none !important;
      }
      .mobile-menu-btn {
        display: none !important;
      }
      .main-content {
        margin-left: 0 !important;
        padding-top: 90px;
      }
    </style>
</head>

<!-- Boot guard to ensure global stored data is available early -->
<script>
/*
  Immediately initialize global data stores used throughout the app.
  In addition to reading from localStorage, this version attempts to
  fetch persisted values from Supabase.  Because the Supabase
  client is exposed on `window.supabase` by the kv sync adapter,
  we can asynchronously query the kv_store table for each known
  key.  If a value exists in Supabase, it takes precedence over
  localStorage; otherwise, the localStorage fallback is used.  This
  ensures that data entered on one device is available on other
  devices without relying on cached local storage.
*/
(function(){
  // Helper to fetch a single key from Supabase.  Returns a Promise
  // that resolves to the parsed JSON value or undefined on error.
  function fetchFromSupabase(key){
    return new Promise((resolve) => {
      try {
        const client = window.supabase;
        const table = window.SUPABASE_TABLE;
        if (!client || !table) return resolve(undefined);
        client
          .from(table)
          .select('value')
          .eq('key', key)
          .single()
          .then(({ data, error }) => {
            if (error || !data) return resolve(undefined);
            const v = data.value;
            if (v == null) return resolve(undefined);
            // If the stored value is a string, assume it is JSON and parse
            if (typeof v === 'string') {
              try { return resolve(JSON.parse(v)); } catch { return resolve(undefined); }
            }
            // Otherwise return the JSON value directly
            return resolve(v);
          })
          .catch(() => resolve(undefined));
      } catch (ex) {
        resolve(undefined);
      }
    });
  }
  (async function(){
    try {
      // Employees store (att_employees_v2)
      if (typeof window.storedEmployees === 'undefined') {
        const supaVal = await fetchFromSupabase('att_employees_v2');
        if (supaVal !== undefined) {
          window.storedEmployees = supaVal;
        } else {
          // fallback to localStorage
          window.storedEmployees = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
        }
      }
      // Attendance records store (att_records_v2)
      if (typeof window.storedRecords === 'undefined') {
        // Attendance records are no longer synced via kv_store; instead they
        // are loaded from localStorage here and later hydrated from the
        // dedicated dtr_records table in Supabase.  We skip
        // fetchFromSupabase('att_records_v2') to avoid loading large
        // datasets into localStorage.
        window.storedRecords = JSON.parse(localStorage.getItem('att_records_v2') || '[]');
      }
      // Projects store (att_projects_v1)
      if (typeof window.storedProjects === 'undefined') {
        const supaVal = await fetchFromSupabase('att_projects_v1');
        if (supaVal !== undefined) {
          window.storedProjects = supaVal;
        } else {
          window.storedProjects = JSON.parse(localStorage.getItem('att_projects_v1') || '{}');
        }
      }
      // Schedules store (att_schedules_v2) ‚Äì ensures schedules are available early
      if (typeof window.storedSchedules === 'undefined') {
        const supaVal = await fetchFromSupabase('att_schedules_v2');
        if (supaVal !== undefined) {
          window.storedSchedules = supaVal;
        } else {
          window.storedSchedules = JSON.parse(localStorage.getItem('att_schedules_v2') || '{}');
        }
      }
    } catch (e) {
      console.warn('Boot guard init failed', e);
    }
  })();
})();
</script>

  <!-- Mobile menu button for smaller screens -->
  <button class="mobile-menu-btn" onclick="toggleSidebar()">
    <span style="font-size: 20px;">‚ò∞</span>
  </button>
  <!-- Begin App Container with Sidebar and Main Content -->
  <div class="app-container">
      <!-- Added top navigation header to adapt payroll UI -->
      <header class="header">
        <div class="header-content">
          <div class="logo">PayrollPro</div>
          <nav>
            <ul class="nav-menu">
              <li class="nav-item"><button class="nav-link tab-btn active" id="tabDashboard" data-page="dashboard"><span class="nav-icon">üìä</span> Dashboard</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabMain" data-page="dtr"><span class="nav-icon">üïê</span> DTR</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabSchedule" data-page="schedules"><span class="nav-icon">üìÖ</span> Schedules</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabEmployees" data-page="employees"><span class="nav-icon">üë•</span> Employees</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabProjects" data-page="projects"><span class="nav-icon">üöÄ</span> Projects</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabPayroll" data-page="payroll"><span class="nav-icon">üí∞</span> Payroll</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabProjectTotals" data-page="totals"><span class="nav-icon">üìà</span> Reports</button></li>
            </ul>
          </nav>
        </div>
      </header>
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">
          üíº PayrollHub
        </div>
      </div>
      <nav>
        <ul class="nav-menu">
          <li class="nav-item">
            <button class="nav-link tab-btn active" id="old-tabDashboard" data-page="dashboard">
              <span class="nav-icon">üìä</span>
              Dashboard
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabMain" data-page="dtr">
              <span class="nav-icon">üïê</span>
              DTR
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabSchedule" data-page="schedules">
              <span class="nav-icon">üìÖ</span>
              Schedules
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabEmployees" data-page="employees">
              <span class="nav-icon">üë•</span>
              Employees
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabProjects" data-page="projects">
              <span class="nav-icon">üöÄ</span>
              Projects
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabPayroll" data-page="payroll">
              <span class="nav-icon">üí∞</span>
              Payroll
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabProjectTotals" data-page="totals">
              <span class="nav-icon">üìà</span>
              Reports
            </button>
          </li>
        </ul>
      </nav>
    </aside>
    <main class="main-content">
      <div class="content-header">
        <h1 class="page-title">
          <span style="font-size: 32px;">üìä</span>
          Dashboard
        </h1>
        <p class="page-subtitle">Manage your payroll system efficiently</p>
        <!-- Hide the legacy date range controls but keep them in the DOM for backwards compatibility -->
        <div class="date-range" id="dateRangeLegacy" style="display:none">
          <span style="font-weight: 600; color: #374151;">Start:</span>
          <input id="weekStart" type="date" class="date-input">
          <span style="font-weight: 600; color: #374151;">End:</span>
          <input id="weekEnd" type="date" class="date-input">
          <button id="dashGenerate" style="margin-left: 8px;">Generate</button>
        </div>
        <!-- New Active Payroll picker -->
        <div class="date-range" id="activePayrollPicker" style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
          <span style="font-weight:600;color:#374151;">Payroll period:</span>
          <select id="activePayrollSelect" class="date-input activeWeekSelect" style="min-width:260px;"></select>
          <button id="newPayrollPeriod" type="button" class="date-input">New period</button>
        </div>
        <div class="warning-note">
          üíæ Data persisted in browser (localStorage). Use Clear to remove.
        </div>
      </div>

      <!-- Begin original content -->

<!-- Original tab buttons and header removed in favour of sidebar navigation -->
  <!-- Dashboard panel to host high-level metrics and payroll history -->
  <section class="panel active" id="panelDashboard">
   <h3>Dashboard</h3>
   <!-- Date range picker and action buttons -->
   <!-- The Generate button has been moved into the date-range picker; retain the controls container for future actions if needed. -->
   <div class="controls"></div>
   <!-- Container for viewing a snapshot or diff results -->
   <div id="snapshotView" style="margin-top:12px;"></div>

   <!-- Active Payrolls table showing all un-locked snapshots -->
   <h4>Active Payrolls</h4>
   <table id="activePayrollTable">
     <thead>
       <tr>
         <th>Start</th>
         <th>End</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <!-- Payroll History table showing all generated/locked snapshots -->
   <h4>Payroll History</h4>
   <table id="historyTable">
     <thead>
       <tr>
         <th>Select</th>
         <th>Start</th>
         <th>End</th>
         <th>Locked At</th>
         <th>Hash</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
     <button id="diffBtn">Diff Selected</button>
   </div>
   <!-- Detail view for locked payroll snapshots. Hidden by default and shown when a user clicks Open/View on a history row. -->
   <div id="snapshotDetailsScreen" style="display:none; margin-top:12px;">
     <h4 id="snapshotDetailTitle"></h4>
     <div id="snapshotPayrollContainer" style="margin-bottom:16px;"></div>
     <div id="snapshotDTRContainer"></div>
     <button id="snapshotBackButton" type="button" style="margin-top:12px;">Back</button>
   </div>
  </section>

  <!-- Original Main panel (DTR) no longer active by default -->
  <section class="panel" id="panelMain">
<!-- Removed DTR-specific Active Payroll selector -->

   <div class="controls">
    <label>
     Upload .DAT/.TXT (multiple)
     <input accept=".dat,.txt" id="fileInput" multiple="" type="file"/>
    </label>
    <button id="manualDtrBtn">Enter Manual DTR</button>
    <button id="printDtrBtn">Print DTR</button>
    <button id="clearData">
     Clear All Data
    </button>
    <label>
     Project:
     <select id="filterProject" title="Filter by project">
     </select>
    </label>
<button id="downloadCSV" style="display:none">
     Download CSV
    </button>
    <label> Search Name: <input id="dtrSearchName" type="text" placeholder="Type a name" style="width:220px" /></label>
   </div>
   <div class="note">
    Regular hours computed per schedule segments. Grace applies to AM/PM in. OT detected after PM out reference.
   </div>
   <!-- Wrap the results table in a scrollable container so horizontal overflow
        is always visible. Without this wrapper some layouts (especially when
        embedding this page in an iframe or within a limited-width container)
        can hide the horizontal scroll bar and make it appear as if columns
        are missing. -->
   <div class="results-wrapper">
   <!-- DTR Date Finder Controls -->
<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;">
  <label style="display:flex;align-items:center;gap:.35rem;">
    <span>Date:</span>
    <input id="dtrDateFrom" type="date" />
  </label>
  <span>‚Äî</span>
  <label>
    <input id="dtrDateTo" type="date" />
  </label>
  <button id="dtrDateClear" type="button">Clear</button>
</div>
<table aria-live="polite" id="resultsTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Project
      </th>
      <th>
       Schedule
      </th>
      <th>
       Date
      </th>
      <th>
       Clock In 1
      </th>
      <th>
       Clock Out 1
      </th>
      <th>
       Clock In 2
      </th>
      <th>
       Clock Out 2
      </th>
      <th>
       OT In
      </th>
      <th>
       OT Out
      </th>
      <th>
       Total Regular Hrs
      </th>
      <th>
       OT Hrs
      </th>
      <th>
       Split
      </th>
      <!-- Added explicit Actions column to ensure consistent header structure -->
      <th class="actions-header">
       Actions
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
   <!-- Summary of DTR totals and employee count -->
   <div id="dtrSummary" style="margin-top:4px;font-weight:bold;"></div>
   </div>
  </section>
  
  <section class="panel" id="panelSchedule">
   <h3>
    Schedules
   </h3>
   <div class="controls">
    <label>
     Choose schedule:
     <select id="scheduleSelect">
     </select>
    </label>
    <button id="addScheduleBtn">
     Add
    </button>
    <button id="deleteScheduleBtn">
     Delete
    </button>
    <button id="setDefaultScheduleBtn">
     Set Default
    </button>
   </div>
   <div class="section-title">
    Schedule segments
   </div>
   <table id="scheduleTable">
    <thead>
     <tr>
      <th>
       Segment
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       AM
      </td>
      <td>
       <input class="cell" data-key="sch_am_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_am_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       PM
      </td>
      <td>
       <input class="cell" data-key="sch_pm_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_pm_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday</td>
      <td><input class="cell" data-key="sch_sat_start" type="time"/></td>
      <td><input class="cell" data-key="sch_sat_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <label>
     Grace Minutes:
     <input class="cell" data-key="sch_grace" min="0" style="width:90px" type="number"/>
    </label>
    <label style="margin-left:8px">
     Schedule name:
     <input class="cell" id="scheduleName" style="width:200px"/>
    </label>
    <button id="saveScheduleBtn">
     Save
    </button>
   </div>
   <div class="section-title">
    Ranges (detection per schedule)
   </div>
   <table id="rangesTable">
    <thead>
     <tr>
      <th>
       Slot
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       Clock In 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock In 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT In
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT Out
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday OT In</td>
      <td><input class="cell" data-key="rng_sat_ot_start" type="time"/></td>
      <td><input class="cell" data-key="rng_sat_ot_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <button id="saveRangesBtn">
     Save Ranges
    </button>
    <button id="resetRangesBtn">
     Reset Ranges
    </button>
   </div>
  </section>
  
  <section class="panel" id="panelEmployees">
   <h3>
    Employees
   </h3>
   <div class="controls">
    <input class="cell" id="empIdInput" placeholder="ID" style="width:120px"/>
    <input class="cell" id="empNameInput" placeholder="Name" style="width:220px"/>
    <input class="cell" id="empRateInput" min="0" placeholder="Hourly Rate" step="0.01" style="width:140px" type="number"/>
    <input class="cell" id="empBankInput" placeholder="Bank Account" style="width:220px"/>
    <label>
     Schedule:
     <select id="empScheduleSelect">
     </select>
    </label>
    <label>
     Project:
     <select id="empProjectSelect">
     </select>
    </label>
    <button id="addEmployeeBtn">
     Add
    </button>
    <button id="clearEmployeesBtn">
     Clear All Employees
    </button>
   </div>
   <div class="controls" style="margin-top:6px;align-items:center;">
    <label style="font-weight:600">
     Upload employee list (no header):
    </label>
    <input accept=".xlsx,.xls,.csv" id="empFileInput" type="file"/>
    <button id="downloadEmployeesCSV">
     Download Employees CSV
    </button>
    <div class="muted">
     Cols: A = ID, B = Name, C = Hourly Rate (optional), D = Schedule Name (optional), E = Project Name (optional), F = Bank Account (optional). Imported employees get default schedule and no project unless set.
    </div>
   </div>


   <table id="employeesTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Hourly Rate
      </th>
      <th>
       Schedule
      </th>
      <th>
       Project
      </th>
      <th>Bank Account</th><th>Action</th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  
  <section class="panel" id="panelProjects">
   <h3>
    Projects
   </h3>
   <div class="controls">
    <input class="cell" id="projectNameInput" placeholder="Project Name" style="width:220px"/>
    <button id="addProjectBtn">
     Add
    </button>
    <button id="clearProjectsBtn">
     Clear All Projects
    </button>
   </div>
   <table id="projectsTable">
    <thead>
     <tr>
      <th>
       Project Name
      </th>
      <th>
       Action
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  <section class="panel" id="panelPayroll">
<!-- Active Payroll selector (non-dashboard) -->
<div class="active-week-bar" style="display:flex;gap:8px;align-items:center;margin:10px 0;">
  <label><strong>Payroll:</strong>
    <select class="activeWeekSelect"></select>
  </label>
  <button type="button" class="refreshActiveWeek">Apply</button>
</div>

   <div id="payrollWrapper">
    <header>
     <h2>
      Payroll
     </h2>
     <div class="tabs">
      <button class="tab-btn active" data-tab="payrollTab">
       Payroll
      </button>
      <!-- Renamed SSS sub-tab to Contributions to include additional government contributions -->
      <button class="tab-btn" data-tab="contributionsTab">
       Contributions
      </button>
      <button class="tab-btn" data-tab="deductionsTab">
       Deductions
      </button>
      <!-- New sub-tab for manual adjustments -->
      <button class="tab-btn" data-tab="adjustmentsTab">Adjustments</button>
     </div>
    </header>
    <div class="tab active" id="payrollTab">
     <div class="controls">
      <label>
       OT Multiplier
       <br/>
       <input id="otMultiplier" step="0.01" style="width:100px" type="number" value="1.50"/>
      </label>
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisor">
        <option value="1">
         1
        </option>
        <option value="2">
         2
        </option>
        <option value="3">
         3
        </option>
        <option value="4">
         4
        </option>
        <option value="5">
         5
        </option>
       </select>
      </label>
      <div style="flex:1 1 auto">
      </div>
      <button class="primary" id="downloadPayrollCSV">
       Download Payroll CSV
      </button>
      <button id="printPayrollBtn" type="button">
       Print Report
      </button>
      <button id="printAllPayslipsBtn" type="button">
       Print Payslips
      </button>
     </div>
     <!-- Contribution formula note with dynamic rates updated via script -->
     <div id="contribNote" class="section note">
      Pag-IBIG = Regular Pay &times; 2% &divide; Divisor, PhilHealth = Regular Pay &times; 2.5% &divide; Divisor,
    SSS = (Employee Share by Monthly Income) &divide; Divisor. Loans &amp; Vales are manual (not divided).
     </div>
     <table id="payrollTable">
      <thead>
       <tr>
        <th>
         ID
        </th>
        <th>
         Name
        </th>
        <th>
         Regular Hours
        </th>
        <th>
         OT Hours
        </th>
        <th>
         Adjustment Hrs
        </th>
        <th>
         Hourly Rate
        </th>
        <th>
         Regular Pay
        </th>
        <th>
         OT Pay
        </th>
        <th>
         Gross Pay
        </th>
        <th>
         Pag-IBIG
        </th>
        <th>
         PhilHealth
        </th>
        <th>
         SSS
        </th>
        <th>
         SSS Loan
        </th>
        <th>
         Pag-IBIG Loan
        </th>
        <th>
         Vale
        </th>
        <th>
         Wed Vale
        </th>
        <th>
         Total Deductions
        </th>
        <th>
         Adjustments
        </th>
        <th>
         Net Pay
        </th>
        <th>
         Payslip
        </th>
       </tr>
      </thead>
      <tbody>
      </tbody>
      <tfoot id="payrollTotalsFoot">
        <tr>
          <td colspan="2" class="label-cell">Grand Total</td>
          <td class="num" data-col="regHrs">0.00</td>
          <td class="num" data-col="otHrs">0.00</td>
          <td class="num" data-col="adjHrs">0.00</td>
          <td class="num" data-col="rate">0.00</td>
          <td class="num" data-col="regPay">0.00</td>
          <td class="num" data-col="otPay">0.00</td>
          <td class="num" data-col="grossPay">0.00</td>
          <td class="num" data-col="pagibig">0.00</td>
          <td class="num" data-col="philhealth">0.00</td>
          <td class="num" data-col="sss">0.00</td>
          <td class="num" data-col="loanSSS">0.00</td>
          <td class="num" data-col="loanPI">0.00</td>
          <td class="num" data-col="vale">0.00</td>
          <td class="num" data-col="valeWed">0.00</td>
          <td class="num" data-col="totalDed">0.00</td>
          <td class="num" data-col="adjAmt">0.00</td>
          <td class="num" data-col="netPay">0.00</td>
          <td></td>
        </tr>
      </tfoot>

     </table>
     <div class="section note">
      Reads employees from localStorage key
      <code>
       att_employees_v2
      </code>
      (id&rarr;{name}). If none found, shows a sample row.
     </div>
    </div>
    <!-- Renamed SSS tab to Contributions for clarity -->
    <div class="tab" id="contributionsTab">
     <div class="controls">
      <button id="addSssRow">
       Add Row
      </button>
      <button class="primary" id="resetSss">
       Reset to Defaults (Custom)
      </button>
      <button class="danger" id="clearSss">
       Clear SSS Table
      </button>
      <button id="exportSss">
       Export CSV
      </button>
      <label>
       Import CSV (min,max,employeeShare)
       <br/>
       <input accept=".csv,text/csv" id="importSss" type="file"/>
      </label>
     </div>
     <table id="sssTable">
      <thead>
       <tr>
        <th>
         Range From (‚Ç±)
        </th>
        <th>
         Range To (‚Ç±)
        </th>
        <th>
         Employee Share (‚Ç±)
        </th>
        <th>
         Actions
        </th>
       </tr>
      </thead>
      <tbody>
      </tbody>
     </table>
     <div class="section note">
      Monthly Income = Hourly Rate &times; 8 &times; 24. We pick the row where
      <i>
       min &le; income &le; max
      </i>
      and use the Employee Share.
     </div>
    <!-- Editable Pag‚ÄëIBIG and PhilHealth tables (employee rates).  Each table allows
         defining income ranges and the corresponding employee rate (as a decimal).
         The rate is applied to regular pay to compute the contribution. -->
    <h4>Pag‚ÄëIBIG Table (Employee Rate)</h4>
    <div class="controls">
      <button id="addPagibigRow">
       Add Row
      </button>
      <button class="primary" id="resetPagibig">
       Reset to Defaults
      </button>
      <button class="danger" id="clearPagibig">
       Clear Pag-IBIG Table
      </button>
    </div>
    <table id="pagibigTable">
      <thead>
        <tr>
          <th>Range From (‚Ç±)</th>
          <th>Range To (‚Ç±)</th>
          <th>Rate (decimal)</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
    <div class="section note">
      Rate is decimal (e.g. 0.02 = 2% employee share). Employer share is assumed to match the employee share but is not used in calculations.
    </div>
    <h4>PhilHealth Table (Employee Rate)</h4>
    <div class="controls">
      <button id="addPhilRow">
       Add Row
      </button>
      <button class="primary" id="resetPhil">
       Reset to Defaults
      </button>
      <button class="danger" id="clearPhil">
       Clear PhilHealth Table
      </button>
    </div>
    <table id="philhealthTable">
      <thead>
        <tr>
          <th>Range From (‚Ç±)</th>
          <th>Range To (‚Ç±)</th>
          <th>Rate (decimal)</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
    <div class="section note">
      Rate is decimal (e.g. 0.025 = 2.5% employee share). Employer share is assumed to match the employee share but is not used in calculations.
    </div>
    </div>
    <div class="tab" id="deductionsTab">
     <!-- Sub-tab navigation for Deductions.  Users can switch between the main
          deductions table and the cash advance tracker.  We reuse the
          existing tab button styles by including the `tab-btn` class. -->
     <div class="subtab-nav">
      <button class="tab-btn subtab-btn active" data-subtab="dedMainSection">Deductions Table</button>
      <button class="tab-btn subtab-btn" data-subtab="cashAdvanceSection">Cash Advance Tracker</button>
     </div>
     <!-- Main deductions content wrapper.  All of the existing controls,
          informational notes and the deductions table reside inside this
          wrapper so that it can be toggled independently from the cash
          advance tracker. -->
     <div id="dedMainSection" class="subtab-panel active">
     <div class="controls">
      <label>
       Upload Excel/CSV (ID, Pag-IBIG Loan, SSS Loan, Vale, Wed Vale):
       <br/>
       <input accept=".xlsx,.xls,.csv" id="deductionsFileInput" type="file"/>
      </label>
      <button id="exportDeductionsCSV">Export CSV</button>

      <!-- Divisor selector for splitting deductions across pay periods (Deductions tab) -->
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisorDeds">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
       </select>
      </label>
     </div>
     <div class="section note">
      <strong>File Format:</strong> Use the exported CSV from this table, then edit only these columns:
      <br/>‚Ä¢ <strong>Column 6:</strong> SSS Loan (edit this value)
      <br/>‚Ä¢ <strong>Column 7:</strong> Pag-IBIG Loan (edit this value)  
      <br/>‚Ä¢ <strong>Column 8:</strong> Vale (edit this value)
      <br/>‚Ä¢ <strong>Column 9:</strong> Wed Vale (edit this value)
      <br/><strong>Important:</strong> Don't change columns 1-5 or 10 (they're calculated automatically)
      <br/><strong>Note:</strong> If employee names are split into 2 columns, the system automatically adjusts
     </div>
     <table id="deductionsTable">
      <thead>
       <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Pag-IBIG</th>
        <th>PhilHealth</th>
        <th>SSS</th>
        <th>SSS Loan</th>
        <th>Pag-IBIG Loan</th>
        <th>Vale</th>
        <th>Wed Vale</th>
        <th>Total Deductions</th>
       </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="deductionsTable_foot">
        <tr>
          <td class="label-cell" colspan="2">Grand Total</td>
          <td class="num" data-col="pagibig">0.00</td>
          <td class="num" data-col="philhealth">0.00</td>
          <td class="num" data-col="sss">0.00</td>
          <td class="num" data-col="loanSSS">0.00</td>
          <td class="num" data-col="loanPI">0.00</td>
          <td class="num" data-col="vale">0.00</td>
          <td class="num" data-col="valeWed">0.00</td>
          <td class="num" data-col="total">0.00</td>
        </tr>
      </tfoot>

     </table>
     </div><!-- close dedMainSection -->
     <!-- Cash Advance Tracker section.  Initially hidden; toggled via the subtab buttons. -->
     <div id="cashAdvanceSection" class="subtab-panel" style="display:none;">
      <table id="cashAdvanceTable">
        <thead>
         <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Original Amount</th>
          <th>Deduction</th>
          <th>Balance</th>
          <th>Action</th>
         </tr>
        </thead>
        <tbody></tbody>
      </table>
     </div>
    </div>

    <!-- Manual Adjustments Tab -->
    <div class="tab" id="adjustmentsTab">
     <div class="section note">
      Enter positive or negative adjustments for each employee. These values will be added (or subtracted if negative) to the net pay. Adjustments are saved automatically.
     </div>
     <table id="adjustmentsTable">
      <thead>
       <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Adjustment Amount</th>
        <th>Adjustment Hrs</th>
       </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="adjustmentsTableFoot">
       <tr>
        <td colspan="2" class="label-cell">Total Adjustments</td>
        <td class="num" data-col="adjAmt">0.00</td>
        <td class="num" data-col="adjHrs">0.00</td>
       </tr>
      </tfoot>
     </table>
    </div>

    <script>
const LS_RATES='payroll_rates', LS_REG_HRS='payroll_reg_hours', LS_OT_HRS='payroll_ot_hours';
const LS_OTMULT='payroll_ot_multiplier', LS_WEEKSTART='payroll_week_start', LS_WEEKEND='payroll_week_end';
const LS_DIVISOR='payroll_deduction_divisor', LS_SSS_TABLE='payroll_sss_table';
const LS_LOAN_SSS='payroll_loan_sss', LS_LOAN_PI='payroll_loan_pagibig';
const LS_VALE='payroll_vale', LS_VALE_WED='payroll_vale_wed';
// LocalStorage key for per-employee payroll adjustments
const LS_ADJ='payroll_adjustments';
// LocalStorage key for per-employee adjustment hours (OT adjustments)
const LS_ADJ_HRS='payroll_adjustment_hours';
// LocalStorage keys for dynamic Pag‚ÄëIBIG and PhilHealth contribution rates (employee share)
const LS_PAGIBIG_RATE='payroll_pagibig_rate';
const LS_PHILHEALTH_RATE='payroll_philhealth_rate';
// LocalStorage keys for dynamic Pag‚ÄëIBIG and PhilHealth contribution tables
const LS_PAGIBIG_TABLE='payroll_pagibig_table';
const LS_PHILHEALTH_TABLE='payroll_philhealth_table';

// Current employee contribution rates (decimal form).  Defaults: 0.02 (2%) for Pag‚ÄëIBIG and 0.025 (2.5%) for PhilHealth.
let pagibigRate = parseFloat(localStorage.getItem(LS_PAGIBIG_RATE) ?? '0.02');
if (isNaN(pagibigRate)) pagibigRate = 0.02;
let philhealthRate = parseFloat(localStorage.getItem(LS_PHILHEALTH_RATE) ?? '0.025');
if (isNaN(philhealthRate)) philhealthRate = 0.025;
const SSS_SEED_2025 = [
  [1, 5249.99, 250],
  [5250, 5749.99, 275],
  [5750, 6249.99, 300],
  [6250, 6749.99, 325],
  [6750, 7249.99, 350],
  [7250, 7749.99, 375],
  [7750, 8249.99, 400],
  [8250, 8749.99, 425],
  [8750, 9249.99, 450],
  [9250, 9749.99, 475],
  [9750, 10249.99, 500],
  [10250, 10749.99, 525],
  [10750, 11249.99, 550],
  [11250, 11749.99, 575],
  [11750, 12249.99, 600],
  [12250, 12749.99, 625],
  [12750, 13249.99, 650],
  [13250, 13749.99, 675],
  [13750, 14249.99, 700],
  [14250, 14749.99, 725],
  [14750, 15249.99, 750],
  [15250, 15749.99, 775],
  [15750, 16249.99, 800],
  [16250, 16749.99, 825],
  [16750, 17249.99, 850],
  [17250, 17749.99, 875],
  [17750, 18249.99, 900],
  [18250, 18749.99, 925],
  [18750, 19249.99, 950],
  [19250, 19749.99, 975],
  [19750, 20249.99, 1000],
  [20250, 20749.99, 1025],
  [20750, 21249.99, 1050],
  [21250, 21749.99, 1075],
  [21750, 22249.99, 1100],
  [22250, 22749.99, 1125],
  [22750, 23249.99, 1150],
  [23250, 23749.99, 1175],
  [23750, 24249.99, 1200],
  [24250, 24749.99, 1225],
  [24750, 25249.99, 1250],
  [25250, 25749.99, 1275],
  [25750, 26249.99, 1300],
  [26250, 26749.99, 1325],
  [26750, 27249.99, 1350],
  [27250, 27749.99, 1375],
  [27750, 28249.99, 1400],
  [28250, 28749.99, 1425],
  [28750, 29249.99, 1450],
  [29250, 29749.99, 1475],
  [29750, 30249.99, 1500],
  [30250, 30749.99, 1525],
  [30750, 31249.99, 1550],
  [31250, 31749.99, 1575],
  [31750, 32249.99, 1600],
  [32250, 32749.99, 1625],
  [32750, 33249.99, 1650],
  [33250, 33749.99, 1675],
  [33750, 34249.99, 1700],
  [34250, 34749.99, 1725],
  [34750, 100000000, 1750]
];

function ensureSeededSSS() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
      localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
    localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededSSS();
// Seed the Pag‚ÄëIBIG and PhilHealth tables with default rates if empty.  These tables
// define income ranges and the corresponding employee contribution rate (decimal).
const PAGIBIG_SEED = [
  [0, 100000000, 0.02]
];
const PHILHEALTH_SEED = [
  [0, 100000000, 0.025]
];

function ensureSeededPagibig() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_PAGIBIG_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
    localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(mapped));
  }
}

function ensureSeededPhilhealth() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_PHILHEALTH_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
    localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededPagibig();
ensureSeededPhilhealth();
let payrollRates = JSON.parse(localStorage.getItem(LS_RATES) || '{}');
let regHours = JSON.parse(localStorage.getItem(LS_REG_HRS) || '{}');
let otHours = JSON.parse(localStorage.getItem(LS_OT_HRS) || '{}');
let loanSSS = JSON.parse(localStorage.getItem(LS_LOAN_SSS) || '{}');
let loanPI = JSON.parse(localStorage.getItem(LS_LOAN_PI) || '{}');
let vale = JSON.parse(localStorage.getItem(LS_VALE) || '{}');
let valeWed = JSON.parse(localStorage.getItem(LS_VALE_WED) || '{}');

// Cash advance localStorage keys and in-memory objects.  These store per-employee
// original cash advance amounts, per-payroll deductions and the current
// outstanding balance.  Each key is persisted to localStorage (and
// mirrored to Supabase via the auto-sync adapter) under its own
// namespace.  The objects are keyed by employee ID.  See the cash
// advance tracker script at the bottom of the document for usage.
const LS_CASH_ORIG = 'payroll_cashAdvanceOrig',
      LS_CASH_DED  = 'payroll_cashAdvanceDed',
      LS_CASH_BAL  = 'payroll_cashAdvanceBal';
let cashOrig = JSON.parse(localStorage.getItem(LS_CASH_ORIG) || '{}');
let cashDed  = JSON.parse(localStorage.getItem(LS_CASH_DED)  || '{}');
let cashBal  = JSON.parse(localStorage.getItem(LS_CASH_BAL)  || '{}');
// Per-employee payroll adjustments (positive or negative amounts)
let adjustments = JSON.parse(localStorage.getItem(LS_ADJ) || '{}');
// Per‚Äëemployee adjustment hours (OT adjustments).  These values represent additional
// overtime hours that should be added to the regular OT hours when computing OT pay.
let adjHrs = JSON.parse(localStorage.getItem(LS_ADJ_HRS) || '{}');

let otMultiplier = parseFloat(localStorage.getItem(LS_OTMULT)) || 1.50;
let weekStartSaved = localStorage.getItem(LS_WEEKSTART) || '';
let weekEndSaved = localStorage.getItem(LS_WEEKEND) || '';
let divisor = parseInt(localStorage.getItem(LS_DIVISOR) || '1', 10);
const weekStartEl = document.getElementById('weekStart');
const weekEndEl = document.getElementById('weekEnd');
const otMultiplierEl = document.getElementById('otMultiplier');
const divisorEl = document.getElementById('deductionDivisor');
const divisorDedsEl = document.getElementById('deductionDivisorDeds');
const tbody = document.querySelector('#payrollTable tbody');
document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('#panelPayroll .tab').forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    const panel = document.querySelector('#panelPayroll #' + btn.dataset.tab);
    if (panel) panel.classList.add('active');
  });
});
otMultiplierEl.value = otMultiplier;
weekStartEl.value = weekStartSaved;
weekEndEl.value = weekEndSaved;
divisorEl.value = divisor;
// Sync the Deductions tab divisor select with the stored divisor value and attach event listener
if (divisorDedsEl) {
  divisorDedsEl.value = String(divisor);
  divisorDedsEl.addEventListener('change', () => {
    divisor = parseInt(divisorDedsEl.value, 10) || 1;
    divisorEl.value = String(divisor);
    localStorage.setItem(LS_DIVISOR, String(divisor));
    calculateAll();
  });
}

otMultiplierEl.addEventListener('input', ()=>{ otMultiplier = parseFloat(otMultiplierEl.value)||0; localStorage.setItem(LS_OTMULT, otMultiplier); calculateAll(); });
weekStartEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKSTART, weekStartEl.value));
weekEndEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKEND, weekEndEl.value));
divisorEl.addEventListener('change', () => {
  divisor = parseInt(divisorEl.value, 10) || 1;
  localStorage.setItem(LS_DIVISOR, String(divisor));
  // Sync the Deductions tab divisor select if it exists
  if (typeof divisorDedsEl !== 'undefined' && divisorDedsEl) {
    divisorDedsEl.value = String(divisor);
  }
  calculateAll();
});
function loadEmployees() {
  const stored = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
  let list = Object.keys(stored).map(id=>({id, name: stored[id]?.name || ''}));
  if (list.length === 0) list = [{id:'001', name:'Sample Employee'}];
  list.sort((a,b)=> (a.name||'').localeCompare(b.name||''));
  return list;
}
const employeeList = loadEmployees();
function getSssTable(){
  let arr = [];
  try { arr = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]'); }
  catch(e){ arr = []; }
  if (!Array.isArray(arr)) arr = [];
  arr = arr.map(r=>({min:Number(r.min)||0, max:Number(r.max)||0, employee:Number(r.employee)||0}))
           .sort((a,b)=> a.min - b.min);
  return arr;
}
function setSssTable(rows){
  localStorage.setItem(LS_SSS_TABLE, JSON.stringify(rows));
}

function renderDeductionsTable(){
  const dtbody = document.querySelector('#deductionsTable tbody');
  if (!dtbody) return;
  dtbody.innerHTML = '';
  employeeList.forEach(emp => {
    const rH = Number(regHours[emp.id] ?? 0);
    const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
    payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
const lSSS = Number(loanSSS[emp.id] ?? 0);
    const lPI = Number(loanPI[emp.id] ?? 0);
    const v = Number(vale[emp.id] ?? 0);
    const vW = Number(valeWed[emp.id] ?? 0);
    const regPay = +(rH * rate).toFixed(2);
    // Use dynamic contribution tables for Pag‚ÄëIBIG and PhilHealth.  Determine the
    // applicable rate based on monthly income and multiply by regular pay.
    const monthly = rate * 8 * 24;
    const piRate = pagibigRateByMonthly(monthly);
    const phRate = philhealthRateByMonthly(monthly);
    const pagibig = +(regPay * piRate).toFixed(2);
    const philhealth = +(regPay * phRate).toFixed(2);
    const sssFull = sssShareByMonthly(monthly);
    const sss = +(sssFull / (Number(divisor)||1)).toFixed(2);
    const sssLoan = +(lSSS / (Number(divisor)||1)).toFixed(2);
    const piLoan = +(lPI / (Number(divisor)||1)).toFixed(2);
    const total = +(pagibig + philhealth + sss + sssLoan + piLoan + v + vW).toFixed(2);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${emp.id}</td><td class="wrap">${emp.name}</td>
      <td class="num">${pagibig.toFixed(2)}</td>
      <td class="num">${philhealth.toFixed(2)}</td>
      <td class="num">${sss.toFixed(2)}</td>
      <td class="num">${sssLoan.toFixed(2)}</td>
      <td class="num">${piLoan.toFixed(2)}</td>
      <td class="num">${v.toFixed(2)}</td>
      <td class="num">${vW.toFixed(2)}</td>
      <td class="num">${total.toFixed(2)}</td>`;
    dtbody.appendChild(tr);
  });
}
document.addEventListener('click', (e)=>{
  if(e.target && e.target.id === 'exportDeductionsCSV'){
    const header = ['ID','Name','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Deductions'];
    const rows=[header];
    document.querySelectorAll('#deductionsTable tbody tr').forEach(tr=>{
      const cells = Array.from(tr.children).map(td=>td.textContent.trim());
      rows.push(cells);
    });
    const csv = rows.map(r=>r.map(s=>{
      s = String(s ?? '');
      return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    }).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='deductions.csv'; document.body.appendChild(a); a.click(); a.remove();
  }
});

// Handle deductions file upload
document.addEventListener('change', (e)=>{
  if(e.target && e.target.id === 'deductionsFileInput'){
    const file = e.target.files && e.target.files[0]; 
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        let rows = [];
        
        // Check if employeeList is available
        if (!employeeList || employeeList.length === 0) {
          alert('No employees found. Please add employees first in the Employees tab.');
          return;
        }
        
        console.log('Available employees:', employeeList.map(e => e.id));
        
        if (file.name.toLowerCase().endsWith('.csv')) {
          // Handle CSV files
          
          const text = String(e.target.result || '');
          // Robust CSV parsing with quoted field support
          rows = text.split(/\r?\n/).filter(line => line.trim().length>0).map(line => {
            const out = []; let cur = ''; let inQ = false;
            for (let i=0;i<line.length;i++){
              const ch = line[i]; const nx = line[i+1];
              if (ch === '"'){
                if (inQ && nx === '"'){ cur += '"'; i++; } 
                else { inQ = !inQ; }
              } else if (ch === ',' && !inQ){
                out.push(cur); cur = '';
              } else {
                cur += ch;
              }
            }
            out.push(cur);
            return out.map(cell => cell.trim());
          });
    } else {
          // Handle Excel files
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        }
        
        if (rows.length < 2) {
          alert('File must have at least a header row and one data row.');
          return;
        }
        
        // Process the data
        let updated = 0;
        let errors = [];
        
        console.log('Processing file with rows:', rows.length);
        console.log('First row (headers):', rows[0]);
        console.log('Second row (sample data):', rows[1]);
        
        
        // Map column indexes by header names to tolerate column reordering
        const header = rows[0].map(h => String(h).trim().toLowerCase());
        const IDX = {
          id: header.indexOf('id'),
          name: header.indexOf('name'),
          sssloan: header.indexOf('sss loan'),
          pagibigloan: header.indexOf('pag-ibig loan'),
          vale: header.indexOf('vale'),
          wedvale: header.indexOf('wed vale')
        };
        const req = ['id','sssloan','pagibigloan','vale','wedvale'];
        for (const k of req){ if (IDX[k] < 0){ alert('Upload missing column: ' + k); return; } }
for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (row.length < 10) {
            console.log(`Row ${i} too short (${row.length} columns):`, row);
            continue;
          }
          
          const empId = String(row[0] || '').trim();
          
          // Only read the specific columns we need for loans and vales
          // Skip the calculated fields (Pag-IBIG, PhilHealth, SSS, Total Deductions)
          // Note: If name is split into 2 columns, adjust accordingly
          const sssLoan = parseFloat(row[IDX.sssloan]) || 0; const pagibigLoan = parseFloat(row[IDX.pagibigloan]) || 0; const valeVal = parseFloat(row[IDX.vale]) || 0; const wedValeVal = parseFloat(row[IDX.wedvale]) || 0;       // Column 9: Wed Vale (was 8)
          
          console.log(`Row ${i}: ID=${empId}, SSS Loan=${sssLoan}, Pag-IBIG Loan=${pagibigLoan}, Vale=${valeVal}, Wed Vale=${wedValeVal}`);
          
          if (!empId) continue;
          
          // Check if employee exists in employeeList
          const employeeExists = employeeList.some(emp => emp.id === empId);
          if (employeeExists) {
            // Update the loan and vale amounts
            loanPI[empId] = pagibigLoan;
            loanSSS[empId] = sssLoan;
            vale[empId] = valeVal;
            valeWed[empId] = wedValeVal;
            updated++;
            console.log(`Updated employee ${empId}:`, { pagibigLoan, sssLoan, vale: valeVal, wedVale: wedValeVal });
          } else {
            errors.push(`Employee ID ${empId} not found`);
            console.log(`Employee ${empId} not found in:`, employeeList.map(e => e.id));
          }
        }
        
        // Save to localStorage
        localStorage.setItem(LS_LOAN_PI, JSON.stringify(loanPI));
        localStorage.setItem(LS_LOAN_SSS, JSON.stringify(loanSSS));
        localStorage.setItem(LS_VALE, JSON.stringify(vale));
        localStorage.setItem(LS_VALE_WED, JSON.stringify(valeWed));
        
        // Refresh displays
        if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
        if (typeof renderTable === 'function') renderTable();
        
        // Show results
        let message = `Updated ${updated} employees.`;
        if (errors.length > 0) {
          message += `\n\nErrors:\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) message += `\n...and ${errors.length - 5} more.`;
        }
        alert(message);
        
      } catch (err) { 
        console.error(err); 
        alert('Error reading file. Please check the file format.'); 
      } finally { 
        e.target.value = ''; 
      }
    };
    
    if (file.name.toLowerCase().endsWith('.csv')) {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  }
});
function renderTable(){
  tbody.innerHTML = '';
  employeeList.forEach(emp=>{
    const tr = document.createElement('tr');
    const rH = Number(regHours[emp.id] ?? 0);
    const oH = Number(otHours[emp.id] ?? 0);
    // Adjustment hours for this employee (default to 0 if undefined)
    const aH = Number(adjHrs[emp.id] ?? 0);
    const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
    payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
const lSSS = Number(loanSSS[emp.id] ?? 0);
    const lPI = Number(loanPI[emp.id] ?? 0);
    const v = Number(vale[emp.id] ?? 0);
    const vW = Number(valeWed[emp.id] ?? 0);
    tr.innerHTML = `
      <td>${emp.id}</td>
      <td class="wrap">${emp.name}</td>
      <td><input class="cell regHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${rH}" readonly></td>
      <td><input class="cell otHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${oH}" readonly></td>
      <td class="adjHrs num">${aH ? aH.toFixed(2) : '0.00'}</td>
      <td><input class="cell rate" title="Non-editable in Payroll" type="number" step="0.01" value="${rate}" readonly></td>
      <td class="regPay num">0.00</td>
      <td class="otPay num">0.00</td>
      <td class="grossPay num">0.00</td>
      <td class="pagibig num">0.00</td>
      <td class="philhealth num">0.00</td>
      <td class="sss num">0.00</td>
      <td><input class="cell loanSSS" type="number" step="0.01" value="${lSSS}"></td>
      <td><input class="cell loanPI" type="number" step="0.01" value="${lPI}"></td>
      <td><input class="cell vale" type="number" step="0.01" value="${v}"></td>
      <td><input class="cell valeWed" type="number" step="0.01" value="${vW}"></td>
      <td class="totalDed num">0.00</td>
      <td class="adjAmt num">0.00</td>
      <td class="netPay num">0.00</td>
      <td><button type="button" class="payslipBtn">Payslip</button></td>`;
    tbody.appendChild(tr);
  });
  attachRowEvents();
  calculateAll();
}

function attachRowEvents(){
  tbody.querySelectorAll('tr').forEach(row=>{
    const id = row.cells[0].textContent.trim();
    const regI = row.querySelector('.regHrs');
    const otI = row.querySelector('.otHrs');
    const rateI = row.querySelector('.rate');
    const lSSSI = row.querySelector('.loanSSS');
    const lPII = row.querySelector('.loanPI');
    const vI = row.querySelector('.vale');
    const vWI = row.querySelector('.valeWed');
    [regI, otI, rateI, lSSSI, lPII, vI, vWI].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        regHours[id] = +(Number(regI.value)||0).toFixed(2);
        otHours[id] = +(Number(otI.value)||0).toFixed(2);
        payrollRates[id] = +(Number(rateI.value)||0).toFixed(2);
        loanSSS[id] = +(Number(lSSSI.value)||0).toFixed(2);
        loanPI[id] = +(Number(lPII.value)||0).toFixed(2);
        vale[id] = +(Number(vI.value)||0).toFixed(2);
        valeWed[id] = +(Number(vWI.value)||0).toFixed(2);
        localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
        localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
        localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
        localStorage.setItem(LS_LOAN_SSS, JSON.stringify(loanSSS));
        localStorage.setItem(LS_LOAN_PI, JSON.stringify(loanPI));
        localStorage.setItem(LS_VALE, JSON.stringify(vale));
        localStorage.setItem(LS_VALE_WED, JSON.stringify(valeWed));
        calculateRow(row);
      });
    });
  });
}
function renderSssTable(){
  const tbodyS = document.querySelector('#sssTable tbody');
  tbodyS.innerHTML='';
  const rows = getSssTable();
  rows.forEach((r, i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell sssMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell sssMax" value="${r.max}"></td>
      <td><input type="number" step="0.01" class="cell sssEmp" value="${r.employee}"></td>
      <td><button class="delRow">Delete</button></td>`;
    tbodyS.appendChild(tr);
    const minI = tr.querySelector('.sssMin');
    const maxI = tr.querySelector('.sssMax');
    const empI = tr.querySelector('.sssEmp');
    minI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    maxI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    empI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    tr.querySelector('.delRow').addEventListener('click', ()=>{
      const cur = getSssTable();
      cur.splice(i,1);
      setSssTable(cur);
      renderSssTable();
      calculateAll();
    });
  });
}
function updateRow(i, minI, maxI, empI){
  const cur = getSssTable();
  cur[i] = {min:Number(minI.value)||0, max:Number(maxI.value)||0, employee:Number(empI.value)||0};
  setSssTable(cur);
  calculateAll();
}

document.getElementById('addSssRow').addEventListener('click', ()=>{
  const cur = getSssTable(); cur.push({min:0,max:0,employee:0}); setSssTable(cur); renderSssTable();
});
document.getElementById('resetSss').addEventListener('click', ()=>{
  if(confirm('Reset SSS table to 2025 defaults?')){
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
    setSssTable(mapped);
    renderSssTable();
    calculateAll();
  }
});
document.getElementById('clearSss').addEventListener('click', ()=>{
  if(confirm('Clear all SSS ranges?')){ setSssTable([]); renderSssTable(); calculateAll(); }
});
document.getElementById('exportSss').addEventListener('click', ()=>{
  const rows = getSssTable();
  const csv = ['min,max,employeeShare'].concat(rows.map(r=>[r.min,r.max,r.employee].join(','))).join('\n');
  const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='sss_table.csv'; document.body.appendChild(a); a.click(); a.remove();
});
document.getElementById('importSss').addEventListener('change', ev=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = e=>{
    const text = e.target.result;
    const lines = text.split(/\r?\n/).filter(Boolean);
    const out=[];
    for(let i=0;i<lines.length;i++){ const line = lines[i].trim();
      if(i===0 && /min/i.test(line) && /max/i.test(line)) continue;
      const p = line.split(',');
      if(p.length>=3) out.push({min:Number(p[0])||0,max:Number(p[1])||0,employee:Number(p[2])||0});
    }
    setSssTable(out); renderSssTable(); calculateAll();
  };
  reader.readAsText(f);
});

// === Begin Pag‚ÄëIBIG and PhilHealth Table Management ===
// Pag‚ÄëIBIG dynamic table helpers.  Defines helper functions for retrieving and
// setting the table in localStorage, rendering the table in the UI, and applying
// the employee share rate based on income ranges.
function getPagibigTable(){
  let arr = [];
  try {
    arr = JSON.parse(localStorage.getItem(LS_PAGIBIG_TABLE) || '[]');
  } catch(e) { arr = []; }
  if (!Array.isArray(arr)) arr = [];
  return arr.map(r => ({
    min: Number(r.min) || 0,
    max: Number(r.max) || 0,
    rate: Number(r.rate) || 0
  })).sort((a,b) => a.min - b.min);
}
function setPagibigTable(rows){
  localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(rows));
}
function renderPagibigTable(){
  const tbodyP = document.querySelector('#pagibigTable tbody');
  if(!tbodyP) return;
  tbodyP.innerHTML = '';
  const rows = getPagibigTable();
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell pagibigMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell pagibigMax" value="${r.max}"></td>
      <td><input type="number" step="0.0001" class="cell pagibigRate" value="${r.rate}"></td>
      <td><button class="delPagibigRow">Delete</button></td>`;
    tbodyP.appendChild(tr);
    const minI = tr.querySelector('.pagibigMin');
    const maxI = tr.querySelector('.pagibigMax');
    const rateI = tr.querySelector('.pagibigRate');
    function update(i){
      const cur = getPagibigTable();
      cur[i] = {min: Number(minI.value) || 0, max: Number(maxI.value) || 0, rate: Number(rateI.value) || 0};
      setPagibigTable(cur);
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
    minI.addEventListener('input', () => update(idx));
    maxI.addEventListener('input', () => update(idx));
    rateI.addEventListener('input', () => update(idx));
    tr.querySelector('.delPagibigRow').addEventListener('click', () => {
      const cur = getPagibigTable();
      cur.splice(idx, 1);
      setPagibigTable(cur);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    });
  });
}
function getPhilhealthTable(){
  let arr = [];
  try {
    arr = JSON.parse(localStorage.getItem(LS_PHILHEALTH_TABLE) || '[]');
  } catch(e) { arr = []; }
  if (!Array.isArray(arr)) arr = [];
  return arr.map(r => ({
    min: Number(r.min) || 0,
    max: Number(r.max) || 0,
    rate: Number(r.rate) || 0
  })).sort((a,b) => a.min - b.min);
}
function setPhilhealthTable(rows){
  localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(rows));
}
function renderPhilhealthTable(){
  const tbodyPh = document.querySelector('#philhealthTable tbody');
  if(!tbodyPh) return;
  tbodyPh.innerHTML = '';
  const rows = getPhilhealthTable();
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell philMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell philMax" value="${r.max}"></td>
      <td><input type="number" step="0.0001" class="cell philRate" value="${r.rate}"></td>
      <td><button class="delPhilRow">Delete</button></td>`;
    tbodyPh.appendChild(tr);
    const minI = tr.querySelector('.philMin');
    const maxI = tr.querySelector('.philMax');
    const rateI = tr.querySelector('.philRate');
    function update(i){
      const cur = getPhilhealthTable();
      cur[i] = {min: Number(minI.value) || 0, max: Number(maxI.value) || 0, rate: Number(rateI.value) || 0};
      setPhilhealthTable(cur);
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
    minI.addEventListener('input', () => update(idx));
    maxI.addEventListener('input', () => update(idx));
    rateI.addEventListener('input', () => update(idx));
    tr.querySelector('.delPhilRow').addEventListener('click', () => {
      const cur = getPhilhealthTable();
      cur.splice(idx, 1);
      setPhilhealthTable(cur);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    });
  });
}
// Click handler for adding, resetting and clearing rows in Pag‚ÄëIBIG and PhilHealth tables.
document.addEventListener('click', (e) => {
  if (e.target && e.target.id === 'addPagibigRow') {
    const cur = getPagibigTable();
    cur.push({min: 0, max: 0, rate: 0});
    setPagibigTable(cur);
    renderPagibigTable();
    calculateAll();
    if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
  } else if (e.target && e.target.id === 'resetPagibig') {
    if (confirm('Reset Pag-IBIG table to defaults?')) {
      const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      setPagibigTable(mapped);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'clearPagibig') {
    if (confirm('Clear all Pag-IBIG ranges?')) {
      setPagibigTable([]);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'addPhilRow') {
    const cur = getPhilhealthTable();
    cur.push({min: 0, max: 0, rate: 0});
    setPhilhealthTable(cur);
    renderPhilhealthTable();
    calculateAll();
    if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
  } else if (e.target && e.target.id === 'resetPhil') {
    if (confirm('Reset PhilHealth table to defaults?')) {
      const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      setPhilhealthTable(mapped);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'clearPhil') {
    if (confirm('Clear all PhilHealth ranges?')) {
      setPhilhealthTable([]);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  }
});
// === End Pag‚ÄëIBIG and PhilHealth Table Management ===
function sssShareByMonthly(monthly){
  const rows = getSssTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].employee)||0;
  for(const r of rows){ if(monthly >= r.min && monthly <= r.max) return Number(r.employee)||0; }
  return Number(rows[rows.length-1].employee)||0;
}

// Determine Pag‚ÄëIBIG contribution rate based on the monthly income.  Uses the
// editable Pag‚ÄëIBIG table; returns a decimal rate (e.g. 0.02).  If no matching
// range is found, returns the last row's rate.
function pagibigRateByMonthly(monthly){
  const rows = getPagibigTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].rate)||0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.rate)||0;
    }
  }
  return Number(rows[rows.length-1].rate)||0;
}

// Determine PhilHealth contribution rate based on the monthly income.  Uses the
// editable PhilHealth table; returns a decimal rate.  If no matching range is found,
// returns the last row's rate.
function philhealthRateByMonthly(monthly){
  const rows = getPhilhealthTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].rate)||0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.rate)||0;
    }
  }
  return Number(rows[rows.length-1].rate)||0;
}

function calculateRow(tr){
  const id = tr.cells[0].textContent.trim();
  const reg = Number(tr.querySelector('.regHrs').value)||0;
  const ot = Number(tr.querySelector('.otHrs').value)||0;
  // Adjustment hours from the adjHrs object (if any)
  const adjHours = Number(adjHrs[id] || 0);
  // Combined OT hours including adjustments
  const otTotal = ot + adjHours;
  const rate = Number(tr.querySelector('.rate').value)||0;
  const lSSS = Number(tr.querySelector('.loanSSS').value)||0;
  const lPI = Number(tr.querySelector('.loanPI').value)||0;
  const v = Number(tr.querySelector('.vale').value)||0;
  const vW = Number(tr.querySelector('.valeWed').value)||0;

  const regPay = +(reg * rate).toFixed(2);
  const otPay = +(otTotal * rate * (Number(otMultiplier)||0)).toFixed(2);
  const gross = +(regPay + otPay).toFixed(2);
  // Compute contributions using dynamic tables (employee share).  Determine the
  // appropriate rate based on the monthly income and multiply by regular pay.
  const monthly = rate * 8 * 24;
  const piRate = pagibigRateByMonthly(monthly);
  const phRate = philhealthRateByMonthly(monthly);
  const pagibig = +(regPay * piRate).toFixed(2);
  const philhealth = +(regPay * phRate).toFixed(2);
  const sssFull = sssShareByMonthly(monthly);
  const sss = sssFull / (Number(divisor)||1);
  const sssLoan = lSSS / (Number(divisor)||1);
  const piLoan = lPI / (Number(divisor)||1);
  const valeAmt = v;
  const wedValeAmt = vW;

  const total = pagibig + philhealth + sss + sssLoan + piLoan + valeAmt + wedValeAmt;
  // Adjustment amount for this employee (may be positive or negative)
  const adj = Number(adjustments[id] || 0);
  const net = gross - total + adj;

  tr.querySelector('.regPay').textContent = regPay.toFixed(2);
  tr.querySelector('.otPay').textContent = otPay.toFixed(2);
  tr.querySelector('.grossPay').textContent = gross.toFixed(2);
  tr.querySelector('.pagibig').textContent = pagibig.toFixed(2);
  tr.querySelector('.philhealth').textContent = philhealth.toFixed(2);
  tr.querySelector('.sss').textContent = sss.toFixed(2);
  tr.querySelector('.totalDed').textContent = total.toFixed(2);
  // Populate adjustment cell (if exists) and net pay
  if (tr.querySelector('.adjAmt')) {
    tr.querySelector('.adjAmt').textContent = adj.toFixed(2);
  }
  // Update the displayed adjustment hours cell if present
  const adjHrsCell = tr.querySelector('.adjHrs');
  if (adjHrsCell) adjHrsCell.textContent = adjHours ? adjHours.toFixed(2) : '0.00';
  tr.querySelector('.netPay').textContent = net.toFixed(2);
}

function calculateAll(){
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=> calculateRow(tr));
  renderDeductionsTable();
}

// === Adjustments Tab ===
// Render the adjustments table listing all employees with an input field for manual adjustment amounts.
function renderAdjustmentsTable() {
  const atbody = document.querySelector('#adjustmentsTable tbody');
  if (!atbody) return;
  atbody.innerHTML = '';
  employeeList.forEach(emp => {
    const id = emp.id;
    const name = emp.name;
    // Use existing adjustment amount (monetary) or empty string for display
    const val = adjustments[id] !== undefined ? adjustments[id] : '';
    // Use existing adjustment hours or empty string for display
    const hrs = adjHrs[id] !== undefined ? adjHrs[id] : '';
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${id}</td>
      <td class="wrap">${name}</td>
      <td><input type="number" step="0.01" class="adjInput" data-id="${id}" value="${val}" /></td>
      <td><input type="number" step="0.01" class="adjHrsInput" data-id="${id}" value="${hrs}" /></td>
    `;
    atbody.appendChild(tr);
  });
  // Attach input event listeners to persist changes and recalculate payroll
  // Monetary adjustments
  atbody.querySelectorAll('.adjInput').forEach(inp => {
    inp.addEventListener('input', () => {
      const empId = inp.getAttribute('data-id');
      const n = parseFloat(inp.value);
      if (!isNaN(n) && n !== 0) {
        // Round to 2 decimal places and store
        adjustments[empId] = +(n.toFixed(2));
      } else {
        // Remove the entry when zero or invalid
        delete adjustments[empId];
      }
      localStorage.setItem(LS_ADJ, JSON.stringify(adjustments));
      calculateAll();
      renderAdjustmentsFoot();
    });
  });
  // Adjustment hours
  atbody.querySelectorAll('.adjHrsInput').forEach(inp => {
    inp.addEventListener('input', () => {
      const empId = inp.getAttribute('data-id');
      const n = parseFloat(inp.value);
      if (!isNaN(n) && n !== 0) {
        // Round to 2 decimal places and store
        adjHrs[empId] = +(n.toFixed(2));
      } else {
        // Remove the entry when zero or invalid
        delete adjHrs[empId];
      }
      localStorage.setItem(LS_ADJ_HRS, JSON.stringify(adjHrs));
      calculateAll();
      renderAdjustmentsFoot();
    });
  });
  // Initialize totals for adjustments (amount and hours)
  renderAdjustmentsFoot();
}

// Compute and display the total of all adjustment amounts in the adjustments table footer.
function renderAdjustmentsFoot() {
  const amtCell = document.querySelector('#adjustmentsTableFoot [data-col="adjAmt"]');
  const hrsCell = document.querySelector('#adjustmentsTableFoot [data-col="adjHrs"]');
  if (!amtCell) return;
  // Sum monetary adjustments
  let totAmt = 0;
  Object.keys(adjustments || {}).forEach(k => {
    const v = Number(adjustments[k]) || 0;
    totAmt += v;
  });
  amtCell.textContent = totAmt.toFixed(2);
  // Sum adjustment hours
  if (hrsCell) {
    let totHrs = 0;
    Object.keys(adjHrs || {}).forEach(k => {
      const v = Number(adjHrs[k]) || 0;
      totHrs += v;
    });
    hrsCell.textContent = totHrs.toFixed(2);
  }
}

// Initialize the dynamic Pag‚ÄëIBIG and PhilHealth rate input fields.  This function
// sets their values from the current global variables and attaches input
// listeners to persist changes to localStorage and recalculate payroll.
function initializeContributionRates() {
  const pagibigInput = document.getElementById('pagibigRateInput');
  if (pagibigInput) {
    // Set current value; show as decimal with 3 decimals
    pagibigInput.value = typeof pagibigRate === 'number' ? pagibigRate.toFixed(3) : '';
    pagibigInput.addEventListener('change', function() {
      let val = parseFloat(pagibigInput.value);
      if (!isNaN(val)) {
        // If user enters percent (e.g. 2), convert to decimal
        if (val > 1) val = val / 100;
        // Bound to 0‚Äì1
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        pagibigRate = val;
        localStorage.setItem(LS_PAGIBIG_RATE, String(val));
        calculateAll();
        updateContributionNote();
      }
    });
  }
  const philInput = document.getElementById('philhealthRateInput');
  if (philInput) {
    philInput.value = typeof philhealthRate === 'number' ? philhealthRate.toFixed(3) : '';
    philInput.addEventListener('change', function() {
      let val = parseFloat(philInput.value);
      if (!isNaN(val)) {
        if (val > 1) val = val / 100;
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        philhealthRate = val;
        localStorage.setItem(LS_PHILHEALTH_RATE, String(val));
        calculateAll();
        updateContributionNote();
      }
    });
  }
}

// Update the contribution note in the payroll tab to reflect current rates.  It
// calculates percentages and updates the HTML of the element with id
// 'contribNote'.  Called after rate changes and on initial load.
function updateContributionNote() {
  const noteEl = document.getElementById('contribNote');
  if (!noteEl) return;
  const piPct = (pagibigRate * 100).toFixed(2);
  const phPct = (philhealthRate * 100).toFixed(2);
  noteEl.innerHTML = 'Pag-IBIG = Regular Pay &times; ' + piPct + '% &divide; Divisor, ' +
    'PhilHealth = Regular Pay &times; ' + phPct + '% &divide; Divisor, ' +
    'SSS = (Employee Share by Monthly Income) &divide; Divisor. Loans &amp; Vales are manual (not divided).';
}
document.getElementById('downloadPayrollCSV').addEventListener('click', ()=>{
  // Include Adjustments column in payroll CSV export
  const header = ['Week Start','Week End','OT Multiplier','Divisor','ID','Name','Regular Hours','OT Hours','Hourly Rate','Regular Pay','OT Pay','Gross Pay','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Deductions','Adjustments','Net Pay'];
  const rows=[header];
  const ws = weekStartEl.value||''; const we = weekEndEl.value||''; const otm = String(otMultiplierEl.value||''); const div = String(divisorEl.value||'1');
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
    const tds = tr.querySelectorAll('td');
    const id = tds[0].textContent.trim(); const name = tds[1].textContent.trim();
    const regI = tr.querySelector('.regHrs'); const otI = tr.querySelector('.otHrs'); const rateI = tr.querySelector('.rate');
    const regPay = tr.querySelector('.regPay').textContent.trim();
    const otPay = tr.querySelector('.otPay').textContent.trim();
    const grossPay = tr.querySelector('.grossPay').textContent.trim();
    const pagibig = tr.querySelector('.pagibig').textContent.trim();
    const philhealth = tr.querySelector('.philhealth').textContent.trim();
    const sss = tr.querySelector('.sss').textContent.trim();
    const lSSS = tr.querySelector('.loanSSS').value; const lPI = tr.querySelector('.loanPI').value;
    const v = tr.querySelector('.vale').value; const vW = tr.querySelector('.valeWed').value;
    const total = tr.querySelector('.totalDed').textContent.trim();
    const adj   = tr.querySelector('.adjAmt') ? tr.querySelector('.adjAmt').textContent.trim() : '';
    const net   = tr.querySelector('.netPay').textContent.trim();
    rows.push([ws,we,otm,div,id,name,regI.value,otI.value,rateI.value,regPay,otPay,grossPay,pagibig,philhealth,sss,lSSS,lPI,v,vW,total,adj,net]);
  });
  const csv = rows.map(r=>r.map(s=>{
    s = String(s ?? '');
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='payroll.csv'; document.body.appendChild(a); a.click(); a.remove();
});
renderTable();
renderSssTable();
renderAdjustmentsTable();
// Render new contribution tables and update the note
renderPagibigTable();
renderPhilhealthTable();
updateContributionNote();
    
  // Wire Project Totals CSV download button (global)
  if (document.getElementById('downloadProjectTotalsCSV')) {
    document.getElementById('downloadProjectTotalsCSV').addEventListener('click', exportProjectTotalsCSV);
  }
</script>

<!-- Modal report functionality for project totals -->
<script>
// Display a modal dialog with a detailed breakdown of a single project's totals.
// Takes a row object (result of computeProjectTotals) and builds a table of
// per-day hours per employee along with grand totals for regular hours, OT,
// total hours and gross pay. Uses the global weekStart/weekEnd inputs to
// construct the day labels. The modal is hidden by default and can be
// dismissed by clicking on the close button or outside the modal.
function showProjectReport(row) {
  if (!row || !row.breakdown || !row.breakdown.length) return;
  const modal = document.getElementById('projectReportModal');
  const content = document.getElementById('projectReportContent');
  if (!modal || !content) return;
  const wsEl = document.getElementById('weekStart');
  const weEl = document.getElementById('weekEnd');
  const startDate = wsEl && wsEl.value ? wsEl.value : '';
  const endDate = weEl && weEl.value ? weEl.value : '';
  // Helper to build a list of dates between start and end inclusive
  function dateRangeList(s, e) {
    const out = [];
    if (!s || !e) return out;
    const sd = new Date(s);
    const ed = new Date(e);
    for (let d = new Date(sd); d <= ed; d.setDate(d.getDate() + 1)) {
      out.push(new Date(d));
    }
    return out;
  }
  const days = dateRangeList(startDate, endDate);
  let html = '';
  html += '<h3 style="margin-top:0;">' + (row.project || 'Project') + ' (' + (startDate || '') + ' to ' + (endDate || '') + ')</h3>';
  html += '<div style="overflow-x:auto;">';
  html += '<table style="width:100%;border-collapse:collapse;margin-bottom:12px;">';
  html += '<thead><tr>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">ID</th>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">Name</th>';
  days.forEach(function(dt) {
    const label = (dt.getMonth() + 1) + '/' + dt.getDate();
    html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + label + '</th>';
  });
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Hrs</th>';
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Amount</th>';
  html += '</tr></thead><tbody>';
  row.breakdown.forEach(function(emp) {
    html += '<tr>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.id || '') + '</td>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.name || '') + '</td>';
    days.forEach(function(dt) {
      const key = dt.toISOString().slice(0, 10);
      const val = parseFloat((emp.perDay && emp.perDay[key]) || 0).toFixed(2);
      html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + val + '</td>';
    });
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.total || 0).toFixed(2)) + '</td>';
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.gross || 0).toFixed(2)) + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  html += '</div>';
  // Grand totals section
  html += '<div style="font-weight:600;">Grand Totals:</div>';
  html += '<table style="border-collapse:collapse;margin-top:4px;">';
  html += '<tr><td style="padding:4px;">Regular Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.reg || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">OT Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.ot || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Total Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.total || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Gross Amount:</td><td style="padding:4px;text-align:right;">' + ((row.gross != null) ? Number(row.gross).toFixed(2) : '0.00') + '</td></tr>';
  html += '</table>';
  content.innerHTML = html;
  modal.style.display = 'flex';
}
// Attach close handlers once DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('projectReportModal');
  const closeBtn = document.getElementById('closeProjectReport');
  if (closeBtn) closeBtn.addEventListener('click', function() { if (modal) modal.style.display = 'none'; });
  if (modal) modal.addEventListener('click', function(e) { if (e.target === modal) modal.style.display = 'none'; });
});
</script>

<!--
  Dashboard functionality
  This script defines utilities for managing payroll history snapshots. It is intentionally
  separated from the existing payroll logic to avoid altering core calculations.
  The dashboard allows users to select a date range, generate a snapshot of the current payroll table,
  lock it to prevent further edits, view past snapshots, download CSV versions, and compare (diff) two snapshots.
-->
<script>
// Print Payroll Report: generate a print-friendly view of the payroll table and open
// a new window for printing. Inputs are converted to plain text and the final
// payslip column is removed to preserve confidentiality.
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('printPayrollBtn');
  if (btn) btn.addEventListener('click', function(){
    const srcTable = document.getElementById('payrollTable');
    if (!srcTable) {
      alert('Payroll table is missing or empty.');
      return;
    }
    // Clone table so we can modify it without affecting the live DOM
    const clone = srcTable.cloneNode(true);
    // Remove the last column (Payslip) from thead, tbody and tfoot
    const removeLastCell = row => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
    clone.querySelectorAll('thead tr').forEach(removeLastCell);
    clone.querySelectorAll('tbody tr').forEach(removeLastCell);
    clone.querySelectorAll('tfoot tr').forEach(removeLastCell);
    // Convert input fields to plain text within the cloned table
    clone.querySelectorAll('input').forEach(inp => {
      const td = inp.parentElement;
      const val = (inp.value || inp.textContent || '').toString();
      td.textContent = val;
    });
    // Build a new window for printing
    const w = window.open('', '', 'width=900,height=700');
    if (!w) return;
    w.document.write('<html><head><meta charset="utf-8"><title>Payroll Report</title>');
    // Basic styles: borders and alignment
    w.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;margin:20px;} table{border-collapse:collapse;width:100%;} th,td{border:1px solid #ddd;padding:6px;} th{background:#f1f5f9;} td.num{text-align:right;} th:nth-child(1),td:nth-child(1),th:nth-child(2),td:nth-child(2){text-align:left;} tfoot td{font-weight:700;background:#fff7ed;border-top:2px solid #e2e8f0;} </style>');
    w.document.write('</head><body>');
    // Header with date range if available
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const startDate = ws && ws.value ? ws.value : '';
    const endDate = we && we.value ? we.value : '';
    if (startDate && endDate) {
      w.document.write('<h2>Payroll Report (' + startDate + ' to ' + endDate + ')</h2>');
    } else {
      w.document.write('<h2>Payroll Report</h2>');
    }
    w.document.write(clone.outerHTML);
    w.document.write('</body></html>');
    w.document.close();
    w.focus();
    w.print();
    // Optionally close after printing (comment out if you don't want auto-close)
    // w.close();
  });
});
document.addEventListener('DOMContentLoaded', () => {
  // Key used to persist payroll history snapshots in localStorage
  const PAYROLL_HIST_KEY = 'payroll_hist';
  // Load existing history from localStorage or default to an empty array
  let payrollHistory;
  try {
    payrollHistory = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
    if (!Array.isArray(payrollHistory)) payrollHistory = [];
  } catch (err) {
    payrollHistory = [];
  }
  // Expose payrollHistory on the window so other scripts (like the Active Payroll dropdown) can
  // append to it directly. Without this, new snapshots added via custom UI would only update
  // localStorage and would not appear in the current session until a full page reload.
  window.payrollHistory = payrollHistory;
  // Grab references to dashboard elements
  // Use the global weekStart/weekEnd inputs instead of the removed dashStartDate/dashEndDate fields.
  const dashStart = document.getElementById('weekStart');
  const dashEnd = document.getElementById('weekEnd');
  const dashGenerateBtn = document.getElementById('dashGenerate');
  // The global lock button has been removed; per-row lock buttons are provided in the Active Payrolls table.
  const dashLockBtn = document.getElementById('dashLock');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const snapshotView = document.getElementById('snapshotView');
  const diffBtn = document.getElementById('diffBtn');

  // Reference to the Active Payrolls table body
  const activeTableBody = document.querySelector('#activePayrollTable tbody');

  /**
   * Render the active payrolls table.
   * Lists snapshots that are not yet locked with Edit and Lock actions.
   */
  window.renderActivePayrolls = function renderActivePayrolls() {
    if (!activeTableBody) return;
    activeTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      if (snap.locked) return;
      const tr = document.createElement('tr');
      // Build the Active Payroll row. Include Edit, Lock and Delete actions. Deleting
      // prompts confirmation and removes the snapshot from payrollHistory.
      tr.innerHTML = `
        <td>${snap.startDate || ''}</td>
        <td>${snap.endDate || ''}</td>
        <td>
          <button type="button" class="editActive" data-index="${index}">Edit</button>
          <button type="button" class="lockActive" data-index="${index}">Lock</button>
          <button type="button" class="deleteActive" data-index="${index}">Delete</button>
        </td>
      `;
      activeTableBody.appendChild(tr);
    });
  };

  // Delegate edit/lock actions on the Active Payrolls table
  activeTableBody && activeTableBody.addEventListener('click', async (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('editActive')) {
      // Set the global date range to the snapshot dates and switch to Payroll tab
      const wsEl = document.getElementById('weekStart');
      const weEl = document.getElementById('weekEnd');
      if (wsEl) wsEl.value = snap.startDate || '';
      if (weEl) weEl.value = snap.endDate || '';
      try { if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords(); } catch (err) {}
      // Show the payroll panel
      try { showTab('payroll'); } catch (err) {}
    } else if (target.classList.contains('lockActive')) {
      // Lock this active payroll: update its snapshot and mark locked
      const startDate = snap.startDate;
      const endDate = snap.endDate;
      if (!startDate || !endDate) {
        alert('Invalid snapshot dates.');
        return;
      }
      const newSnap = await buildSnapshot(startDate, endDate);
      if (!newSnap) {
        alert('Payroll table is missing or empty.');
        return;
      }
      const json = JSON.stringify(newSnap);
      const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      const now = new Date().toISOString();
      snap.rows = newSnap.rows;
      snap.totals = newSnap.totals;
      snap.hash = hashHex;
      snap.lockedAt = now;
      snap.locked = true;
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      // Disable payroll and DTR editing via helper until date range changes
      disablePayrollInputs();
      const wsEl2 = document.getElementById('weekStart');
      const weEl2 = document.getElementById('weekEnd');
      // Mark date inputs as forced to prevent showTab from re-enabling prematurely
      if (wsEl2) wsEl2.dataset.forced = 'true';
      if (weEl2) weEl2.dataset.forced = 'true';
      function enableOnChange() {
        if (wsEl2) wsEl2.removeEventListener('change', enableOnChange);
        if (weEl2) weEl2.removeEventListener('change', enableOnChange);
        // Determine if the newly selected period is locked. If locked, keep
        // editing disabled; otherwise enable editing and clear forced flags.
        if (typeof checkAndToggleEditState === 'function') {
          checkAndToggleEditState();
        } else {
          enablePayrollInputs();
        }
      }
      if (wsEl2) wsEl2.addEventListener('change', enableOnChange);
      if (weEl2) weEl2.addEventListener('change', enableOnChange);
    } else if (target.classList.contains('deleteActive')) {
      // Delete active (unlocked) snapshot after confirmation
      if (!snap) return;
      const ok = confirm('Are you sure you want to delete this payroll snapshot? This action cannot be undone.');
      if (!ok) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
  });

  /**
   * Render the payroll history table.
   * Each snapshot row contains a checkbox for diffing, start/end dates, lock timestamp,
   * truncated hash, and action buttons for opening and downloading the snapshot.
   */
  window.renderHistory = function renderHistory() {
    if (!historyTableBody) return;
    historyTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      const tr = document.createElement('tr');
      // Build row HTML; note small hash display for brevity
      // Build the actions column depending on lock status. Only locked snapshots show Open/Unlock buttons.
      const actions = [];
      if (snap.locked) {
        actions.push(`<button type="button" class="openSnapshot" data-index="${index}">Open</button>`);
        actions.push(`<button type="button" class="unlockSnapshot" data-index="${index}">Unlock</button>`);
        // For locked snapshots, show a disabled delete button to indicate it cannot be removed
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}" disabled>Delete</button>`);
      } else {
        // For unlocked snapshots, allow deletion
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}">Delete</button>`);
      }
      // Always provide a download button
      actions.push(`<button type="button" class="downloadSnapshot" data-index="${index}">Download CSV</button>`);
      tr.innerHTML = `
        <td><input type="checkbox" class="diff-select" data-index="${index}"></td>
        <td>${snap.startDate || ''}</td>
        <td>${snap.endDate || ''}</td>
        <td>${snap.lockedAt ? new Date(snap.lockedAt).toLocaleString() : ''}</td>
        <td><span style="font-size:10px;">${snap.hash ? snap.hash.slice(0, 12) + '...' : ''}</span></td>
        <td>${actions.join(' ')}</td>
      `;
      historyTableBody.appendChild(tr);
    });
  };

  /**
   * Build a snapshot from the current payroll table. This captures all row values
   * and totals in a structured JSON object for persistence.
   */
  async function buildSnapshot(startDate, endDate) {
    const table = document.getElementById('payrollTable');
    if (!table) return null;
    const rows = [];
    table.querySelectorAll('tbody tr').forEach(row => {
      const data = {};
      data.id = (row.cells[0]?.textContent || '').trim();
      data.name = (row.cells[1]?.textContent || '').trim();
      // Helper to read numeric input or fallback text
      function readNum(sel, cellIndex) {
        const input = row.querySelector(sel);
        if (input) return parseFloat(input.value) || 0;
        const cellVal = row.cells[cellIndex] && row.cells[cellIndex].textContent;
        return parseFloat(cellVal) || 0;
      }
      data.regHrs = readNum('.regHrs', 2);
      data.otHrs = readNum('.otHrs', 3);
      data.rate = readNum('.rate', 4);
      data.regPay = readNum('.regPay', 5);
      data.otPay = readNum('.otPay', 6);
      data.grossPay = readNum('.grossPay', 7);
      data.pagibig = readNum('.pagibig', 8);
      data.philhealth = readNum('.philhealth', 9);
      data.sss = readNum('.sss', 10);
      data.loanSSS = readNum('.loanSSS', 11);
      data.loanPI = readNum('.loanPI', 12);
      data.vale = readNum('.vale', 13);
      data.valeWed = readNum('.valeWed', 14);
      data.totalDed = readNum('.totalDed', 15);
      // Capture adjustments and correct net pay cell index. The adjustment column is at index 16 and net pay at 17.
      data.adjAmt = readNum('.adjAmt', 16);
      data.netPay = readNum('.netPay', 17);
      // Capture DTR records for this employee within the selected date range. Stores an array of {date, times}
      try {
        const recStr = localStorage.getItem('att_records_v2');
        const recs = recStr ? JSON.parse(recStr) : [];
        if (Array.isArray(recs)) {
          const start = startDate || '';
          const end = endDate || '';
          const empRecs = recs.filter(r => r && String(r.empId) === String(data.id) && (!start || r.date >= start) && (!end || r.date <= end));
          const grouped = {};
          empRecs.forEach(r => {
            if (!r || !r.date) return;
            const d = r.date;
            if (!grouped[d]) grouped[d] = [];
            if (r.time && !grouped[d].includes(r.time)) grouped[d].push(r.time);
          });
          const arr = [];
          Object.keys(grouped).sort().forEach(dateKey => {
            const times = grouped[dateKey].sort();
            arr.push({ date: dateKey, times });
          });
          data.dtrs = arr;
        }
      } catch (e) {
        // ignore parse errors
      }
      rows.push(data);
    });
    // Read totals from footer
    const totals = {};
    const footRow = document.querySelector('#payrollTable tfoot tr');
    if (footRow) {
      footRow.querySelectorAll('[data-col]').forEach(td => {
        const key = td.dataset.col;
        totals[key] = parseFloat(td.textContent.trim()) || 0;
      });
    }
    return { startDate, endDate, rows, totals };
  }
  // Expose buildSnapshot globally so it can be called from other scripts
  window.buildSnapshot = buildSnapshot;

  /**
   * Disable payroll and DTR editing across the application. Once a payroll
   * period is locked, users should not be able to adjust hours, rates, or
   * manually enter or delete DTR entries for that period. This helper
   * centralizes the logic so both global and per-row lock actions can reuse
   * it. Date range controls and Generate/Lock buttons are also disabled.
   */
  function disablePayrollInputs() {
    // Disable all editable fields in the payroll table
    document.querySelectorAll('#payrollTable input').forEach(inp => {
      inp.disabled = true;
    });
    // Disable DTR inputs, buttons and selects (manual DTR, delete buttons, filters, etc.)
    document.querySelectorAll('#panelMain input, #panelMain button, #panelMain select').forEach(el => {
      el.disabled = true;
    });
    // Additionally disable key DTR controls explicitly by ID. While the generic selector above
    // should catch most elements, some dynamically inserted controls (or those outside
    // #panelMain) may escape. Explicitly disabling them ensures search fields, date filters,
    // project dropdowns and import/export buttons cannot be used once locked. These IDs
    // correspond to the manual DTR workflow and DTR filtering controls.
    ['dtrSearchName','dtrDateFrom','dtrDateTo','dtrDateClear','filterProject','downloadCSV','fileInput','manualDtrBtn','printDtrBtn','clearData','dtrDateRangeFrom','dtrDateRangeTo'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = true;
    });
    // Disable all select elements within the results table (project and schedule selectors)
    document.querySelectorAll('#resultsTable select').forEach(sel => {
      sel.disabled = true;
    });
    // Disable any DTR delete buttons that may have been added
    document.querySelectorAll('.dtr-del-btn').forEach(btn => {
      btn.disabled = true;
    });

    // Add a locked class to the DTR panel to disable pointer events. This is a
    // visual and functional safeguard for cases where individual inputs might
    // get re-enabled by other scripts. The CSS defined above ensures
    // #panelMain.locked blocks all interaction with its contents.
    const pm = document.getElementById('panelMain');
    if (pm) pm.classList.add('locked');
    // Also disable inputs and buttons within the manual DTR modal if it exists. The modal is not
    // nested under #panelMain, so we need to explicitly target it. Without this, users could
    // potentially enter a manual record even after locking by using the modal fields directly.
    document.querySelectorAll('#manualDtrModal input, #manualDtrModal button, #manualDtrModal select').forEach(el => {
      el.disabled = true;
    });
    // Disable dashboard date range inputs and action buttons
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const genBtn = document.getElementById('dashGenerate');
    const lockBtn = document.getElementById('dashLock');
    if (ws) ws.disabled = true;
    if (we) we.disabled = true;
    if (genBtn) genBtn.disabled = true;
    if (lockBtn) lockBtn.disabled = true;
  }
  // Expose helper globally so other scripts can disable editing
  window.disablePayrollInputs = disablePayrollInputs;

  /**
   * Re-enable payroll and DTR editing across the application. This should be
   * called when the user changes the date range after locking, or when a
   * snapshot is unlocked. It resets disabled fields and action buttons.
   */
  function enablePayrollInputs() {
    // Re-enable payroll table inputs
    document.querySelectorAll('#payrollTable input').forEach(inp => {
      inp.disabled = false;
    });
    // Re-enable DTR inputs, buttons and selects
    document.querySelectorAll('#panelMain input, #panelMain button, #panelMain select').forEach(el => {
      el.disabled = false;
    });
    // Re-enable specific DTR controls by ID that were explicitly disabled in
    // disablePayrollInputs(). This ensures search, date filters, project filter,
    // and import/export controls become usable again when the payroll is unlocked
    // or the date range is changed.
    ['dtrSearchName','dtrDateFrom','dtrDateTo','dtrDateClear','filterProject','downloadCSV','fileInput','manualDtrBtn','printDtrBtn','clearData','dtrDateRangeFrom','dtrDateRangeTo'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = false;
    });
    // Re-enable selects in the results table (project and schedule selectors)
    document.querySelectorAll('#resultsTable select').forEach(sel => {
      sel.disabled = false;
    });
    // Re-enable any DTR delete buttons
    document.querySelectorAll('.dtr-del-btn').forEach(btn => {
      btn.disabled = false;
    });

    // Remove the locked class from the DTR panel so pointer events and
    // interaction are restored. When the user switches to an unlocked period or
    // explicitly unlocks a snapshot, this class must be removed.
    const pm = document.getElementById('panelMain');
    if (pm) pm.classList.remove('locked');
    // Re-enable manual DTR modal fields and buttons. When a payroll is unlocked or the date
    // range changes, users should be able to enter manual DTR entries again. This undoes the
    // disablement applied in disablePayrollInputs().
    document.querySelectorAll('#manualDtrModal input, #manualDtrModal button, #manualDtrModal select').forEach(el => {
      el.disabled = false;
    });
    // Re-enable dashboard date range and action buttons
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const genBtn = document.getElementById('dashGenerate');
    const lockBtn = document.getElementById('dashLock');
    if (ws) ws.disabled = false;
    if (we) we.disabled = false;
    if (genBtn) genBtn.disabled = false;
    if (lockBtn) lockBtn.disabled = false;
  }
  // Expose helper globally so other scripts can enable editing
  window.enablePayrollInputs = enablePayrollInputs;

  /**
   * Determine whether the currently selected payroll period (weekStart/weekEnd values)
   * corresponds to a locked snapshot. This reads from the global payrollHistory
   * array if available, otherwise loads history from localStorage. It returns
   * true if a matching snapshot exists and its `locked` property is truthy.
   */
  function isSelectedPeriodLocked() {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (!wsEl || !weEl) return false;
    const start = wsEl.value;
    const end = weEl.value;
    // Helper to parse either ISO (yyyy-mm-dd) or US (m/d/yyyy) date strings
    function parseDateStr(str) {
      if (!str) return null;
      // If contains dash, assume ISO format yyyy-mm-dd or yyyy-m-d
      if (str.includes('-')) {
        const isoParts = str.split('-');
        if (isoParts.length === 3) {
          const y = parseInt(isoParts[0], 10);
          const m = parseInt(isoParts[1], 10);
          const d = parseInt(isoParts[2], 10);
          if (!isNaN(y) && !isNaN(m) && !isNaN(d)) {
            return new Date(y, m - 1, d);
          }
        }
        // Fallback: let Date constructor try parsing
        const dt = new Date(str);
        return isNaN(dt.getTime()) ? null : dt;
      }
      // If contains slash, assume m/d/yyyy or mm/dd/yyyy
      if (str.includes('/')) {
        const parts = str.split('/');
        if (parts.length === 3) {
          const m = parseInt(parts[0], 10);
          const d = parseInt(parts[1], 10);
          const y = parseInt(parts[2], 10);
          if (!isNaN(m) && !isNaN(d) && !isNaN(y)) {
            return new Date(y, m - 1, d);
          }
        }
      }
      // Final attempt: parse using Date constructor
      const dt2 = new Date(str);
      return isNaN(dt2.getTime()) ? null : dt2;
    }
    const startDateObj = parseDateStr(start);
    const endDateObj = parseDateStr(end);
    if (!startDateObj || !endDateObj) return false;
    // Use the in-memory payrollHistory if available; else load from storage
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : (typeof loadHistory === 'function' ? loadHistory() : []);
    if (!Array.isArray(hist)) return false;
    return hist.some(s => {
      if (!s || !s.startDate || !s.endDate) return false;
      // Parse snapshot dates similarly; handle leading zero differences
      const sStart = parseDateStr(s.startDate);
      const sEnd = parseDateStr(s.endDate);
      if (!sStart || !sEnd) return false;
      return s.locked && sStart.getTime() === startDateObj.getTime() && sEnd.getTime() === endDateObj.getTime();
    });
  }
  window.isSelectedPeriodLocked = isSelectedPeriodLocked;

  /**
   * Check the current payroll period and toggle editing state accordingly. If the
   * selected period is locked, all payroll/DTR inputs are disabled and the
   * date inputs are marked as forced. If the period is not locked, editing is
   * enabled and the forced flags are removed. This helper centralizes the
   * logic of determining lock status and applying the appropriate UI state.
   */
  function checkAndToggleEditState() {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (!wsEl || !weEl) return;
    const locked = isSelectedPeriodLocked();
    if (locked) {
      disablePayrollInputs();
      // Mark inputs as forced so other logic (showTab) doesn't re-enable them
      wsEl.dataset.forced = 'true';
      weEl.dataset.forced = 'true';
    } else {
      enablePayrollInputs();
      if (wsEl.dataset) delete wsEl.dataset.forced;
      if (weEl.dataset) delete weEl.dataset.forced;
    }
  }
  window.checkAndToggleEditState = checkAndToggleEditState;

  /**
   * Convert a snapshot into a CSV string. Header names correspond to payroll columns.
   */
  function snapshotToCSV(snap) {
    const header = [
      'ID','Name','Regular Hours','OT Hours','Rate','Regular Pay','OT Pay','Gross Pay',
      'Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale','Total Deductions','Adjustments','Net Pay'
    ];
    const lines = [header.join(',')];
    snap.rows.forEach(row => {
      const values = [
        row.id, row.name,
        row.regHrs, row.otHrs, row.rate,
        row.regPay, row.otPay, row.grossPay,
        row.pagibig, row.philhealth, row.sss,
        row.loanSSS, row.loanPI, row.vale, row.valeWed,
        row.totalDed, row.adjAmt, row.netPay
      ];
      lines.push(values.map(v => {
        const s = String(v ?? '');
        return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
      }).join(','));
    });
    return lines.join('\n');
  }

  // Persist payrollHistory to localStorage
  function saveHistory() {
    localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(payrollHistory));
  }
  // Expose saveHistory globally so it can be called from other scripts
  window.saveHistory = saveHistory;

  // Handler for Generate button: build and save a snapshot without locking
  dashGenerateBtn && dashGenerateBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    // Prevent duplicate snapshots for the same date range. If any snapshot (locked or active)
    // already exists with this start/end, alert the user and skip creation. This avoids
    // double‚Äëentry payroll for the same period.
    const exists = Array.isArray(payrollHistory) && payrollHistory.some(snap =>
      snap && snap.startDate === start && snap.endDate === end);
    if (exists) {
      alert('A payroll snapshot for this date range already exists. Please choose a different range or delete the existing entry.');
      return;
    }
    // Ensure all payroll values are recalculated before taking a snapshot for generation
    try {
      if (typeof calculateAll === 'function') {
        calculateAll();
      }
    } catch (e) {
      // Suppress errors from calculateAll; snapshot will reflect current cell values
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false });
    saveHistory();
    // Update both history and active payroll tables after creating a new snapshot
    renderHistory();
    if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
  });

  // Handler for Lock button: build snapshot, mark locked and disable payroll editing
  dashLockBtn && dashLockBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    // Recompute all payroll row values prior to building the snapshot. Without this
    // call, some columns (e.g. contributions, total deductions, adjustments and
    // net pay) may not be up to date if the user has edited values but not
    // triggered a recalculation. Ensuring calculateAll() runs here fills all
    // numeric columns before locking.
    try {
      if (typeof calculateAll === 'function') {
        calculateAll();
      }
    } catch (e) {
      // Ignore errors in calculation; snapshot will still be built from current cells
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: true });
    saveHistory();
    renderHistory();
    // Disable payroll and DTR editing via helper until date range changes
    disablePayrollInputs();
    // Mark date inputs as forced so showTab logic doesn't re-enable them prematurely
    if (dashStart) dashStart.dataset.forced = 'true';
    if (dashEnd) dashEnd.dataset.forced = 'true';
    // Listener to re-enable controls on date change
    function enableOnChange() {
      if (dashStart) dashStart.removeEventListener('change', enableOnChange);
      if (dashEnd) dashEnd.removeEventListener('change', enableOnChange);
      // Check the new period and toggle edit state accordingly. If the new
      // selection is locked, keep editing disabled; otherwise enable it.
      if (typeof checkAndToggleEditState === 'function') {
        checkAndToggleEditState();
      } else {
        enablePayrollInputs();
        if (dashStart && dashStart.dataset) delete dashStart.dataset.forced;
        if (dashEnd && dashEnd.dataset) delete dashEnd.dataset.forced;
      }
    }
    if (dashStart) dashStart.addEventListener('change', enableOnChange);
    if (dashEnd) dashEnd.addEventListener('change', enableOnChange);
  });

  // Delegate open/download actions on history table
  historyTableBody && historyTableBody.addEventListener('click', (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('openSnapshot')) {
      // Only allow opening locked snapshots
      if (!snap.locked) return;
      // Render the snapshot in a dedicated detail view with DTR breakdown
      if (typeof showSnapshotDetails === 'function') {
        showSnapshotDetails(idx);
      }
    }
    if (target.classList.contains('deleteSnapshot')) {
      // Delete a snapshot from history if it is not locked
      if (snap.locked) return; // Skip deletion for locked snapshots
      const confirmDel = confirm('Are you sure you want to delete this payroll record? This cannot be undone.');
      if (!confirmDel) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      return;
    }
    if (target.classList.contains('unlockSnapshot')) {
      // Unlock this locked snapshot: mark as unlocked and remove timestamp
      if (!snap.locked) return;
      snap.locked = false;
      snap.lockedAt = '';
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
    if (target.classList.contains('downloadSnapshot')) {
      const csv = snapshotToCSV(snap);
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `payroll_${snap.startDate}_${snap.endDate}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  });

  // Compare two snapshots and display net pay differences
  diffBtn && diffBtn.addEventListener('click', () => {
    const selected = Array.from(document.querySelectorAll('.diff-select')).filter(cb => cb.checked);
    if (selected.length !== 2) {
      alert('Please select exactly two snapshots to compare.');
      return;
    }
    const idx1 = parseInt(selected[0].dataset.index, 10);
    const idx2 = parseInt(selected[1].dataset.index, 10);
    const s1 = payrollHistory[idx1];
    const s2 = payrollHistory[idx2];
    if (!s1 || !s2) return;
    const map1 = {};
    s1.rows.forEach(r => { map1[r.id] = r; });
    const map2 = {};
    s2.rows.forEach(r => { map2[r.id] = r; });
    const allIds = new Set([...Object.keys(map1), ...Object.keys(map2)]);
    if (snapshotView) snapshotView.innerHTML = '';
    const table = document.createElement('table');
    table.style.borderCollapse = 'collapse';
    table.style.width = '100%';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['ID','Name',`Net (${s1.startDate} - ${s1.endDate})`,`Net (${s2.startDate} - ${s2.endDate})`,'Difference'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    allIds.forEach(id => {
      const r1 = map1[id] || {};
      const r2 = map2[id] || {};
      const name = r2.name || r1.name || '';
      const net1 = parseFloat(r1.netPay) || 0;
      const net2 = parseFloat(r2.netPay) || 0;
      const diff = (net2 - net1).toFixed(2);
      const tr = document.createElement('tr');
      [id, name, net1.toFixed(2), net2.toFixed(2), diff].forEach((val, i) => {
        const td = document.createElement('td');
        td.textContent = val;
        td.style.border = '1px solid #e2e8f0';
        td.style.padding = '4px';
        if (i >= 2) td.style.textAlign = 'right';
        tr.appendChild(td);
      });
      // Highlight difference cell
      const diffVal = parseFloat(diff);
      const diffCell = tr.children[4];
      if (diffVal > 0) diffCell.style.background = '#dcfce7';
      else if (diffVal < 0) diffCell.style.background = '#fee2e2';
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    if (snapshotView) snapshotView.appendChild(table);
  });

  // Initial render on page load
  renderHistory();
  if (typeof renderActivePayrolls === 'function') renderActivePayrolls();

  /**
   * Display a locked payroll snapshot in a dedicated detail view. This hides the dashboard
   * tables and shows a new section with a summary of the payroll and a breakdown of the
   * DTR (time entries) per employee for the period. A Back button restores the dashboard.
   * @param {number} index Index of the snapshot in payrollHistory
   */
  window.showSnapshotDetails = function showSnapshotDetails(index) {
    const snap = Array.isArray(payrollHistory) ? payrollHistory[index] : null;
    if (!snap) return;
    // Grab key dashboard elements
    const activeTable = document.getElementById('activePayrollTable');
    const historyTable = document.getElementById('historyTable');
    const diffButton = document.getElementById('diffBtn');
    const snapshotViewEl = document.getElementById('snapshotView');
    const detailScreen = document.getElementById('snapshotDetailsScreen');
    const backBtn = document.getElementById('snapshotBackButton');
    const titleEl = document.getElementById('snapshotDetailTitle');
    const payrollContainer = document.getElementById('snapshotPayrollContainer');
    const dtrContainer = document.getElementById('snapshotDTRContainer');
    if (!detailScreen || !payrollContainer || !dtrContainer) return;
    // Determine headers for hiding/showing (h4 elements preceding tables)
    const activeHeader = activeTable && activeTable.previousElementSibling;
    const histHeader = historyTable && historyTable.previousElementSibling;
    // Set title with lock info
    if (titleEl) {
      const lockedInfo = snap.lockedAt ? ` (Locked ${new Date(snap.lockedAt).toLocaleString()})` : '';
      titleEl.textContent = `Payroll Details: ${snap.startDate || ''} ‚Äî ${snap.endDate || ''}${lockedInfo}`;
    }
    // Hide dashboard tables and controls
    if (activeTable) activeTable.style.display = 'none';
    if (activeHeader && activeHeader.tagName === 'H4') activeHeader.style.display = 'none';
    if (historyTable) historyTable.style.display = 'none';
    if (histHeader && histHeader.tagName === 'H4') histHeader.style.display = 'none';
    if (diffButton) diffButton.style.display = 'none';
    if (snapshotViewEl) snapshotViewEl.style.display = 'none';
    // Build payroll summary table
    payrollContainer.innerHTML = '';
    const payTable = document.createElement('table');
    payTable.style.borderCollapse = 'collapse';
    payTable.style.width = '100%';
    const pHead = document.createElement('thead');
    const pRow = document.createElement('tr');
    // Define the headers for the payroll summary table. Include an Adjustments
    // column so that any manual adjustments saved in the snapshot are visible
    // when viewing a locked payroll. This keeps the summary in sync with the
    // CSV export and ensures the net pay is clearly explained.
    const headers = [
      'ID','Name','Regular Hrs','OT Hrs','Rate','Reg Pay','OT Pay','Gross',
      'Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale',
      'Total Ded','Adjustments','Net Pay'
    ];
    headers.forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      pRow.appendChild(th);
    });
    pHead.appendChild(pRow);
    payTable.appendChild(pHead);
    const pBody = document.createElement('tbody');
    // Each employee row in the snapshot may include an adjAmt property
    // representing manual adjustments. Build the table row accordingly.
    (snap.rows || []).forEach(r => {
      const tr = document.createElement('tr');
      const vals = [
        r.id, r.name, r.regHrs, r.otHrs, r.rate,
        r.regPay, r.otPay, r.grossPay,
        r.pagibig, r.philhealth, r.sss,
        r.loanSSS, r.loanPI, r.vale, r.valeWed,
        r.totalDed, r.adjAmt, r.netPay
      ];
      vals.forEach(v => {
        const td = document.createElement('td');
        let text = '';
        if (v != null && v !== '') {
          // Format numeric values to two decimal places; leave strings (e.g. ID, name)
          const num = parseFloat(v);
          if (!isNaN(num) && isFinite(num)) {
            text = num.toFixed(2);
          } else {
            text = v;
          }
        }
        td.textContent = text;
        td.style.border = '1px solid #e2e8f0';
        td.style.padding = '4px';
        // Align numbers to the right and text to the left for better readability
        if (!isNaN(parseFloat(text)) && isFinite(parseFloat(text))) {
          td.style.textAlign = 'right';
        } else {
          td.style.textAlign = 'left';
        }
        tr.appendChild(td);
      });
      pBody.appendChild(tr);
    });
    payTable.appendChild(pBody);
    payrollContainer.appendChild(payTable);
    // Build DTR breakdown
    dtrContainer.innerHTML = '';
    // Build DTR data for display. If the snapshot rows include a dtrs array
    // (captured when the payroll was locked), use it directly so that the
    // attendance shown reflects the state at locking time. Otherwise, fall
    // back to reading the current att_records_v2 from localStorage for
    // backward compatibility with snapshots created before this feature was
    // implemented.
    let dtrRows = [];
    let useSnapDtrs = false;
    (snap.rows || []).forEach(empRow => {
      if (Array.isArray(empRow.dtrs) && empRow.dtrs.length) {
        useSnapDtrs = true;
      }
    });
    if (useSnapDtrs) {
      // Use the stored dtrs directly from each employee row
      (snap.rows || []).forEach(empRow => {
        const id = empRow.id;
        const name = empRow.name || '';
        (empRow.dtrs || []).forEach(d => {
          dtrRows.push({ id, name, date: d.date, times: d.times || [] });
        });
      });
    } else {
      // Fallback: derive from live attendance records within the snapshot date range
      let records = [];
      try {
        const recStr = localStorage.getItem('att_records_v2');
        records = recStr ? JSON.parse(recStr) : [];
        if (!Array.isArray(records)) records = [];
      } catch (e) {
        records = [];
      }
      const start = snap.startDate || '';
      const end = snap.endDate || '';
      function inRange(dateStr) {
        if (!dateStr) return false;
        return (!start || dateStr >= start) && (!end || dateStr <= end);
      }
      (snap.rows || []).forEach(empRow => {
        const id = empRow.id;
        const name = empRow.name || '';
        const recs = records.filter(r => r && String(r.empId) === String(id) && inRange(r.date));
        const dateGroups = {};
        recs.forEach(r => {
          const d = r.date;
          if (!dateGroups[d]) dateGroups[d] = [];
          if (r.time && !dateGroups[d].includes(r.time)) dateGroups[d].push(r.time);
        });
        Object.keys(dateGroups).sort().forEach(dateKey => {
          const times = dateGroups[dateKey].sort();
          dtrRows.push({ id, name, date: dateKey, times });
        });
      });
    }
    const dtrTable = document.createElement('table');
    dtrTable.style.borderCollapse = 'collapse';
    dtrTable.style.width = '100%';
    const dtrHead = document.createElement('thead');
    const dr = document.createElement('tr');
    ['ID','Name','Date','Times'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      dr.appendChild(th);
    });
    dtrHead.appendChild(dr);
    dtrTable.appendChild(dtrHead);
    const dtrBody = document.createElement('tbody');
    dtrRows.forEach(row => {
      const tr = document.createElement('tr');
      const idCell = document.createElement('td');
      idCell.textContent = row.id;
      idCell.style.border = '1px solid #e2e8f0';
      idCell.style.padding = '4px';
      tr.appendChild(idCell);
      const nameCell = document.createElement('td');
      nameCell.textContent = row.name;
      nameCell.style.border = '1px solid #e2e8f0';
      nameCell.style.padding = '4px';
      tr.appendChild(nameCell);
      const dateCell = document.createElement('td');
      dateCell.textContent = row.date;
      dateCell.style.border = '1px solid #e2e8f0';
      dateCell.style.padding = '4px';
      tr.appendChild(dateCell);
      const timesCell = document.createElement('td');
      timesCell.textContent = (row.times || []).join(', ');
      timesCell.style.border = '1px solid #e2e8f0';
      timesCell.style.padding = '4px';
      tr.appendChild(timesCell);
      dtrBody.appendChild(tr);
    });
    dtrTable.appendChild(dtrBody);
    if (dtrRows.length) {
      dtrContainer.appendChild(dtrTable);
    } else {
      const p = document.createElement('p');
      p.textContent = 'No DTR records found for this period.';
      dtrContainer.appendChild(p);
    }
    // Show the detail screen
    detailScreen.style.display = 'block';
    // Disable editing across the app
    if (typeof disablePayrollInputs === 'function') {
      disablePayrollInputs();
    }
    // Mark date range inputs as forced and disabled
    const wsInput = document.getElementById('weekStart');
    const weInput = document.getElementById('weekEnd');
    if (wsInput) {
      wsInput.disabled = true;
      wsInput.dataset.forced = 'true';
    }
    if (weInput) {
      weInput.disabled = true;
      weInput.dataset.forced = 'true';
    }
    // Back button: restore previous view
    if (backBtn) {
      backBtn.onclick = () => {
        detailScreen.style.display = 'none';
        if (activeTable) activeTable.style.display = '';
        if (activeHeader && activeHeader.tagName === 'H4') activeHeader.style.display = '';
        if (historyTable) historyTable.style.display = '';
        if (histHeader && histHeader.tagName === 'H4') histHeader.style.display = '';
        if (diffButton) diffButton.style.display = '';
        if (snapshotViewEl) snapshotViewEl.style.display = '';
        payrollContainer.innerHTML = '';
        dtrContainer.innerHTML = '';
        // Remove forced flags and re-enable date inputs
        if (wsInput) {
          delete wsInput.dataset.forced;
          wsInput.disabled = false;
        }
        if (weInput) {
          delete weInput.dataset.forced;
          weInput.disabled = false;
        }
        // Re-enable editing
        if (typeof enablePayrollInputs === 'function') {
          enablePayrollInputs();
        }
        // Re-check lock status for selected period
        try {
          if (typeof checkAndToggleEditState === 'function') {
            checkAndToggleEditState();
          }
        } catch (_) {}
      };
    }
  };
});
</script>
   </div>
  </section>
  <section class="panel" id="panelProjectTotals">
    <h3>Reports</h3>
    <div class="controls" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <div class="muted">Uses the global Start/End dates in the header and includes per-day project/schedule overrides.</div>
      <div style="flex:1 1 auto"></div>
      <button id="downloadProjectTotalsCSV">Download CSV</button>
      <button id="printProjectTotalsBtn">Print Reports</button>
    </div>
    <table id="projectTotalsTable">
      <thead>
        <tr>
          <th>Project</th>
          <th>Regular Hours</th>
          <th>OT Hours</th>
          <th>Total Hours</th>
          <th>Gross Amount</th>
          <th>Employees (count)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <!-- Modal for detailed project report -->
    <div id="projectReportModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;z-index:10000;">
      <div style="background:white;padding:20px;border-radius:10px;max-height:80vh;overflow:auto;width:90%;max-width:800px;position:relative;">
        <button type="button" id="closeProjectReport" style="position:absolute;top:10px;right:10px;font-size:20px;border:none;background:transparent;cursor:pointer;">&times;</button>
        <div id="projectReportContent"></div>
      </div>
    </div>
  </section>
      </main>
    </div>
    <!-- Sidebar navigation behaviour -->
    <script>
    document.querySelectorAll('.nav-link').forEach(function(link){
        link.addEventListener('click', function(e){
            e.preventDefault();
            document.querySelectorAll('.nav-link').forEach(function(l){ l.classList.remove('active'); });
            this.classList.add('active');
            var icon = this.querySelector('.nav-icon').textContent;
            var text = this.textContent.trim();
            var pageTitle = document.querySelector('.page-title');
            if(pageTitle){
                pageTitle.innerHTML = '<span style="font-size: 32px;">' + icon + '</span> ' + text;
            }
        });
    });
    function toggleSidebar(){
        var sidebar = document.getElementById('sidebar');
        if(sidebar) sidebar.classList.toggle('active');
    }
    document.addEventListener('click', function(e){
        var sidebar = document.getElementById('sidebar');
        var mobileBtn = document.querySelector('.mobile-menu-btn');
        if(window.innerWidth <= 768 && sidebar && sidebar.classList.contains('active') && !sidebar.contains(e.target) && mobileBtn && !mobileBtn.contains(e.target)){
            sidebar.classList.remove('active');
        }
    });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
   
const LS_RECORDS = 'att_records_v2';

const LS_SCHEDULES = 'att_schedules_v2';
const LS_SCHEDULES_DEFAULT = 'att_schedules_default';
const LS_EMPLOYEES = 'att_employees_v2';
const LS_PROJECTS = 'att_projects_v1';
const LS_FILTER_PROJECT = 'att_filter_project_v1';
const LS_OVERRIDES_SCHEDULES = 'att_overrides_schedules';
const LS_OVERRIDES_PROJECTS = 'att_overrides_projects';

let overridesSchedules = JSON.parse(localStorage.getItem(LS_OVERRIDES_SCHEDULES) || '{}');
let overridesProjects = JSON.parse(localStorage.getItem(LS_OVERRIDES_PROJECTS) || '{}');
// Store per-date split flags for half-day display. When true for an empId+date,
// the DTR entry is rendered as two separate rows (AM and PM) rather than a
// single combined row. The split state is persisted in localStorage under
// LS_SPLITS. Keys are formatted as empId + '___' + date.
const LS_SPLITS = 'att_splits_v1';
let splits = {};
try {
  splits = JSON.parse(localStorage.getItem(LS_SPLITS) || '{}');
} catch (e) {
  splits = {};
}
function saveSplits() {
  try {
    localStorage.setItem(LS_SPLITS, JSON.stringify(splits));
  } catch (e) {
    console.warn('Saving splits failed', e);
  }
}
function saveOverrides(){
  localStorage.setItem(LS_OVERRIDES_SCHEDULES, JSON.stringify(overridesSchedules));
  localStorage.setItem(LS_OVERRIDES_PROJECTS, JSON.stringify(overridesProjects));
}


const DEFAULT_RANGES = {
  rng_am_in_start:"05:00", rng_am_in_end:"09:00",
  rng_am_out_start:"11:30", rng_am_out_end:"12:30",
  rng_pm_in_start:"12:30", rng_pm_in_end:"14:30",
  rng_pm_out_start:"15:00", rng_pm_out_end:"20:00",
  rng_ot_in_start:"19:00", rng_ot_in_end:"22:00",
  rng_ot_out_start:"19:00", rng_ot_out_end:"23:59",
  rng_sat_ot_start:"11:00", rng_sat_ot_end:"23:59"
};
const DEFAULT_SCHEDULE = {
  name: "Default",
  sch_am_start:"08:00", sch_am_end:"12:00",
  sch_pm_start:"13:00", sch_pm_end:"17:00",
  
  sch_sat_start:"", sch_sat_end:"",
  sch_grace:15,
  ...DEFAULT_RANGES

};

// Do not seed storedRecords from localStorage by default.  The DTR data
// is persisted in Supabase and is loaded on page initialization via
// loadAttendanceByDateRange() or loadDtrFromCloud().  Initializing with
// an empty array prevents exceeding local storage quotas and avoids
// stale or partial data.
let storedRecords = [];
let storedEmployees = JSON.parse(localStorage.getItem(LS_EMPLOYEES) || '{}');
let storedSchedules = JSON.parse(localStorage.getItem(LS_SCHEDULES) || 'null');
let defaultScheduleId = localStorage.getItem(LS_SCHEDULES_DEFAULT) || null;
let storedProjects = JSON.parse(localStorage.getItem(LS_PROJECTS) || '{}');
document.getElementById('downloadEmployeesCSV').addEventListener('click', () => {
  const rows = [['ID','Name','Hourly Rate','Schedule','Project','Bank Account']];
  Object.keys(storedEmployees).forEach(id => {
    const emp = storedEmployees[id] || {};
    const schedName = storedSchedules[emp.scheduleId]?.name || '';
    const projName = storedProjects[emp.projectId]?.name || '';
    const bank = emp.bankAccount || ''; rows.push([id, emp.name || '', emp.hourlyRate || '', schedName, projName, bank]);
  });

  const csv = rows.map(r => r.map(v => {
    const s = String(v ?? '');
    return (s.includes(',') || s.includes('"') || s.includes('\n')) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'employees_backup.csv';
  a.click();
});

let currentProjectFilter = localStorage.getItem(LS_FILTER_PROJECT) || 'all';

function ensureSchedules(){
  if(!storedSchedules || typeof storedSchedules !== 'object'){
    const id = 'sched_' + Date.now();
    storedSchedules = {};
    storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE);
    storedSchedules[id].name = DEFAULT_SCHEDULE.name;
    defaultScheduleId = id;
    saveSchedulesToLS();
  } else {
    Object.keys(storedSchedules).forEach(id=>{
      storedSchedules[id] = { ...DEFAULT_RANGES, ...storedSchedules[id] };
      storedSchedules[id].sch_am_start = storedSchedules[id].sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
      storedSchedules[id].sch_am_end   = storedSchedules[id].sch_am_end   || DEFAULT_SCHEDULE.sch_am_end;
      storedSchedules[id].sch_pm_start = storedSchedules[id].sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
      storedSchedules[id].sch_pm_end   = storedSchedules[id].sch_pm_end   || DEFAULT_SCHEDULE.sch_pm_end;
      if(typeof storedSchedules[id].sch_grace !== 'number') storedSchedules[id].sch_grace = DEFAULT_SCHEDULE.sch_grace;
      storedSchedules[id].name = storedSchedules[id].name || 'Schedule';
    });
    if(!defaultScheduleId || !storedSchedules[defaultScheduleId]){
      const keys = Object.keys(storedSchedules);
      if(keys.length) defaultScheduleId = keys[0];
      saveSchedulesToLS();
    }
  }
}
function saveSchedulesToLS(){
  localStorage.setItem(LS_SCHEDULES, JSON.stringify(storedSchedules));
  localStorage.setItem(LS_SCHEDULES_DEFAULT, defaultScheduleId);
}

const tabs = {
  tabMain: document.getElementById('tabMain'),
  // Dashboard tab/button for high-level summary and payroll history
  tabDashboard: document.getElementById('tabDashboard'),
  tabSchedule: document.getElementById('tabSchedule'),
  tabEmployees: document.getElementById('tabEmployees'),
  tabProjects: document.getElementById('tabProjects'),
  panelMain: document.getElementById('panelMain'),
  // Corresponding Dashboard panel
  panelDashboard: document.getElementById('panelDashboard'),
  panelSchedule: document.getElementById('panelSchedule'),
  panelEmployees: document.getElementById('panelEmployees'),
  panelProjects: document.getElementById('panelProjects'),
  tabPayroll: document.getElementById('tabPayroll'),
  panelPayroll: document.getElementById('panelPayroll')
};
function showTab(name){
  Object.values(tabs).forEach(el => el && el.classList && el.classList.remove('active'));

  // Manage date range controls: disable on non-dashboard tabs, enable on dashboard unless forced
  (() => {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (wsEl && weEl) {
      const isDash = (name === 'dashboard');
      // Only toggle if the inputs are not forcibly disabled (e.g., due to lock/open)
      const forced = wsEl.dataset.forced === 'true' || weEl.dataset.forced === 'true';
      if (!forced) {
        wsEl.disabled = !isDash;
        weEl.disabled = !isDash;
      }
    }
  })();
  if(name==='main'){ tabs.tabMain.classList.add('active'); tabs.panelMain.classList.add('active'); }
  // When the dashboard is selected, activate its tab and panel
  if(name==='dashboard'){ tabs.tabDashboard && tabs.tabDashboard.classList.add('active'); tabs.panelDashboard && tabs.panelDashboard.classList.add('active'); }
  if(name==='schedule'){ tabs.tabSchedule.classList.add('active'); tabs.panelSchedule.classList.add('active'); renderScheduleEditor(); }
  if(name==='employees'){ tabs.tabEmployees.classList.add('active'); tabs.panelEmployees.classList.add('active'); renderEmployees(); }
  if(name==='projects'){ tabs.tabProjects.classList.add('active'); tabs.panelProjects.classList.add('active'); renderProjects(); }

  if(name==='payroll'){ tabs.tabPayroll && tabs.tabPayroll.classList.add('active'); tabs.panelPayroll && tabs.panelPayroll.classList.add('active'); }
}
// When switching to the main (DTR) tab, render results and then toggle the edit
// state based on whether the selected period is locked. Without this call,
// the DTR UI may remain interactive even when a locked payroll period is
// selected. Any errors are caught to avoid breaking tab switching.
tabs.tabMain.addEventListener('click', () => {
  showTab('main');
  try { renderResults(); } catch (e) {}
  try {
    if (typeof checkAndToggleEditState === 'function') {
      checkAndToggleEditState();
    }
  } catch (e) {}
});
tabs.tabSchedule.addEventListener('click', ()=>showTab('schedule'));
tabs.tabEmployees.addEventListener('click', ()=>showTab('employees'));
tabs.tabProjects.addEventListener('click', ()=>showTab('projects'));

tabs.tabPayroll.addEventListener('click', ()=>{
  try {
    const defaultBtn = document.querySelector('#panelPayroll .tabs .tab-btn[data-tab="payrollTab"]');
    if (defaultBtn) defaultBtn.click();
  } catch (e) {}

  showTab('payroll');
  try { if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); } catch(e){}
  try { if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); } catch(e){}
});

// Switch to the dashboard tab when clicked. Render payroll history if available.
if (tabs.tabDashboard) {
  tabs.tabDashboard.addEventListener('click', () => {
    showTab('dashboard');
    try {
      if (typeof renderHistory === 'function') renderHistory();
    } catch (e) {}
  });
}

const scheduleSelect = document.getElementById('scheduleSelect');
const scheduleNameInput = document.getElementById('scheduleName');

function renderScheduleSelector(){
  scheduleSelect.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = (storedSchedules[id].name || id) + (id === defaultScheduleId ? " (Default)" : "");
    scheduleSelect.appendChild(opt);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) scheduleSelect.value = defaultScheduleId;
  else if(scheduleSelect.options.length) scheduleSelect.selectedIndex = 0;
  renderEmpScheduleDropdowns();
  renderEmpScheduleDropdownsInTable();
}

function renderScheduleEditor(){
  const sel = scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  const s = storedSchedules[sel];
  document.querySelector('[data-key="sch_am_start"]').value = s.sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
  document.querySelector('[data-key="sch_am_end"]').value = s.sch_am_end || DEFAULT_SCHEDULE.sch_am_end;
  document.querySelector('[data-key="sch_pm_start"]').value = s.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
  document.querySelector('[data-key="sch_pm_end"]').value = s.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end;
  
  const satStartInp = document.querySelector('[data-key="sch_sat_start"]');
  const satEndInp   = document.querySelector('[data-key="sch_sat_end"]');
  if (satStartInp) satStartInp.value = (s.sch_sat_start || "");
  if (satEndInp)   satEndInp.value   = (s.sch_sat_end   || "");
document.querySelector('[data-key="sch_grace"]').value = (s.sch_grace !== undefined ? s.sch_grace : DEFAULT_SCHEDULE.sch_grace);
  scheduleNameInput.value = s.name || ("Schedule " + sel);
  document.querySelectorAll('#rangesTable input[data-key]').forEach(inp=>{
    const key = inp.dataset.key;
    inp.value = s[key] || (DEFAULT_RANGES && DEFAULT_RANGES[key]) || "";
  });
}

function gatherScheduleFromEditor(){
  return {
    name: scheduleNameInput.value.trim() || ("Schedule " + Date.now()),
    sch_am_start: document.querySelector('[data-key="sch_am_start"]').value || DEFAULT_SCHEDULE.sch_am_start,
    sch_am_end: document.querySelector('[data-key="sch_am_end"]').value || DEFAULT_SCHEDULE.sch_am_end,
    sch_pm_start: document.querySelector('[data-key="sch_pm_start"]').value || DEFAULT_SCHEDULE.sch_pm_start,
    sch_pm_end: document.querySelector('[data-key="sch_pm_end"]').value || DEFAULT_SCHEDULE.sch_pm_end,
    
    sch_sat_start: (document.querySelector('[data-key="sch_sat_start"]')?.value || ""),
    sch_sat_end:   (document.querySelector('[data-key="sch_sat_end"]')?.value   || ""),
sch_grace: Number(document.querySelector('[data-key="sch_grace"]').value || DEFAULT_SCHEDULE.sch_grace),
    ...Object.fromEntries([...document.querySelectorAll('#rangesTable input[data-key]')].map(i=>[i.dataset.key, i.value || DEFAULT_RANGES[i.dataset.key] || ""]))
  };
}

document.getElementById('addScheduleBtn').addEventListener('click', ()=>{
  const id = 'sched_' + Date.now();
  storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE); storedSchedules[id].name = 'New schedule';
  saveSchedulesToLS(); renderScheduleSelector(); scheduleSelect.value = id; renderScheduleEditor();
});
document.getElementById('deleteScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  if(Object.keys(storedSchedules).length === 1){ alert('Cannot delete the only schedule.'); return; }
  if(!confirm('Delete schedule "' + storedSchedules[sel].name + '"?')) return;
  delete storedSchedules[sel];
  if(!storedSchedules[defaultScheduleId]) defaultScheduleId = Object.keys(storedSchedules)[0];
  Object.keys(storedEmployees).forEach(eid=>{
    if(storedEmployees[eid].scheduleId === sel) storedEmployees[eid].scheduleId = defaultScheduleId;
  });
  saveSchedulesToLS(); saveEmployeesToLS(); renderScheduleSelector(); renderEmployees(); renderResults();
});
document.getElementById('setDefaultScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return; defaultScheduleId = sel; saveSchedulesToLS(); renderScheduleSelector();
});
document.getElementById('saveScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  const oldRanges = {};
  Object.keys(DEFAULT_RANGES).forEach(k=> oldRanges[k] = (storedSchedules[sel] && storedSchedules[sel][k]) || DEFAULT_RANGES[k]);
  storedSchedules[sel] = { ...gatherScheduleFromEditor(), ...oldRanges, name: document.getElementById('scheduleName').value.trim() || storedSchedules[sel].name || 'Schedule' };
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || DEFAULT_RANGES[i.dataset.key] || "";
  });
  saveSchedulesToLS(); renderScheduleSelector(); renderEmpScheduleDropdowns(); renderResults();
});
scheduleSelect.addEventListener('change', ()=>{ renderScheduleEditor(); });

function saveRangesFromUI(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || "";
  });
  saveSchedulesToLS();
  renderResults();
}
function resetRanges(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  Object.keys(DEFAULT_RANGES).forEach(k=>{
    storedSchedules[sel][k] = DEFAULT_RANGES[k];
  });
  saveSchedulesToLS();
  renderScheduleEditor();
  renderResults();
}
document.getElementById('saveRangesBtn').addEventListener('click', saveRangesFromUI);
document.getElementById('resetRangesBtn').addEventListener('click', resetRanges);

function saveEmployeesToLS(){ localStorage.setItem(LS_EMPLOYEES, JSON.stringify(storedEmployees)); }
function renderEmpScheduleDropdowns(){
  const sel = document.getElementById('empScheduleSelect'); if(!sel) return;
  sel.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const o=document.createElement('option'); o.value=id;
    o.textContent=storedSchedules[id].name + (id===defaultScheduleId?' (Default)':'');
    sel.appendChild(o);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) sel.value = defaultScheduleId;
}
function renderEmpScheduleDropdownsInTable(){
  document.querySelectorAll('.emp-sel-schedule').forEach(sel=>{
    const id = sel.dataset.id;
    sel.innerHTML = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      const o = document.createElement('option'); o.value = sid; o.textContent = label;
      if(storedEmployees[id] && storedEmployees[id].scheduleId === sid) o.selected = true;
      sel.appendChild(o);
    });
  });
}

function saveProjectsToLS(){ localStorage.setItem(LS_PROJECTS, JSON.stringify(storedProjects)); renderProjects(); renderProjectDropdowns(); renderProjectFilterOptions(); renderResults(); }
function renderProjects(){
  const tbody = document.querySelector('#projectsTable tbody'); tbody.innerHTML = '';
  Object.keys(storedProjects).forEach(pid=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td><input class="cell proj-name-input" data-id="${pid}" value="${storedProjects[pid].name}"></td>
      <td><button class="del-proj" data-id="${pid}">Delete</button></td>`;
    tbody.appendChild(tr);
  });
  document.querySelectorAll('.del-proj').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const id = e.target.dataset.id;
      if(confirm('Delete project "' + storedProjects[id].name + '"?')){
        delete storedProjects[id];
        Object.keys(storedEmployees).forEach(eid=>{ if(storedEmployees[eid].projectId === id) storedEmployees[eid].projectId = null; });
        saveProjectsToLS(); saveEmployeesToLS(); renderEmployees(); renderResults();
      }
    });
  });
  document.querySelectorAll('.proj-name-input').forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.dataset.id;
      storedProjects[id].name = e.target.value;
      saveProjectsToLS();
    });
  });

}
function renderProjectDropdowns(){
  const sel = document.getElementById('empProjectSelect');
  if(!sel) return;
  sel.innerHTML = '';
  const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid=>{
    const o=document.createElement('option'); o.value=pid; o.textContent=storedProjects[pid].name; sel.appendChild(o);
  });
}
function renderEmpProjectDropdownsInTable(){
  document.querySelectorAll('.emp-sel-project').forEach(sel=>{
    const id = sel.dataset.id;
    const prev = sel.value;
    sel.innerHTML = '';
    const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
    Object.keys(storedProjects).forEach(pid=>{
      const o = document.createElement('option'); o.value = pid; o.textContent = storedProjects[pid].name;
      if(storedEmployees[id] && storedEmployees[id].projectId === pid) o.selected = true;
      sel.appendChild(o);
    });
    if(prev) sel.value = prev;
  });
}

const filterProjectSel = document.getElementById('filterProject');
function renderProjectFilterOptions(){
  if(!filterProjectSel) return;
  const prev = currentProjectFilter || 'all';
  filterProjectSel.innerHTML = '';
  const make = (value, label)=>{ const o=document.createElement('option'); o.value=value; o.textContent=label; return o; };
  filterProjectSel.appendChild(make('all','All Projects'));
  filterProjectSel.appendChild(make('none','(No project)'));
  Object.keys(storedProjects).forEach(pid=>{
    filterProjectSel.appendChild(make(pid, storedProjects[pid].name));
  });
  if([...filterProjectSel.options].some(o=>o.value===prev)) filterProjectSel.value = prev;
  else filterProjectSel.value = 'all';
  currentProjectFilter = filterProjectSel.value;
}
filterProjectSel && filterProjectSel.addEventListener('change', ()=>{
  currentProjectFilter = filterProjectSel.value || 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);
  renderResults();
});

function renderEmployees(){
  renderEmpScheduleDropdowns();
  renderProjectDropdowns();
  const tbody = document.querySelector('#employeesTable tbody'); tbody.innerHTML = '';
  const ids = Object.keys(storedEmployees).sort((a,b)=>{
    const na = /^\d+$/.test(a), nb = /^\d+$/.test(b);
    if (na && nb) return Number(a) - Number(b);
    return String(a).localeCompare(String(b));
  });
ids.forEach(id => {
    const emp = storedEmployees[id];
    let scheduleOptionsHtml = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      scheduleOptionsHtml += `<option value="${sid}" ${emp.scheduleId===sid ? 'selected' : ''}>${label}</option>`;
    });
    let projectOptionsHtml = `<option value="">(None)</option>`;
    Object.keys(storedProjects).forEach(pid=>{
      projectOptionsHtml += `<option value="${pid}" ${emp.projectId===pid ? 'selected' : ''}>${storedProjects[pid].name}</option>`;
    });
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${id}</td>
      <td><input class="cell emp-name-input" data-id="${id}" value="${emp.name}"></td>
      <td><input class="cell emp-rate-input" type="number" step="0.01" min="0" data-id="${id}" value="${emp.hourlyRate != null ? emp.hourlyRate : ''}"></td>
      <td><select class="emp-sel-schedule" data-id="${id}">${scheduleOptionsHtml}</select></td>
      <td><select class="emp-sel-project" data-id="${id}">${projectOptionsHtml}</select></td>
      <td><input class="cell emp-bank-input" data-id="${id}" value="${emp.bankAccount != null ? emp.bankAccount : ''}"></td>
      <td><button class="del-emp" data-id="${id}">Delete</button></td>`;
    tbody.appendChild(tr);
  });

  document.querySelectorAll('.emp-name-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].name = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-rate-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    const id = e.target.dataset.id;
    const val = parseFloat(e.target.value) || 0;
    storedEmployees[id].hourlyRate = val; saveEmployeesToLS();
    try { payrollRates[id] = val; localStorage.setItem(LS_RATES, JSON.stringify(payrollRates)); } catch(err) {}
    renderResults();
  }));
document.querySelectorAll('.emp-sel-schedule').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].scheduleId = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-sel-project').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].projectId = e.target.value || null; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.del-emp').forEach(btn=> btn.addEventListener('click', (e)=>{
    const id=e.target.dataset.id;
    if(confirm(`Delete employee ${id} ‚Äî ${storedEmployees[id].name}?`)){
      delete storedEmployees[id]; saveEmployeesToLS(); renderEmployees(); renderResults();
    }
  }));
}

document.getElementById('addEmployeeBtn').addEventListener('click', ()=>{
  const id = document.getElementById('empIdInput').value.trim();
  const name = document.getElementById('empNameInput').value.trim();
  const rate = parseFloat(document.getElementById('empRateInput').value) || 0;
  const scheduleId = document.getElementById('empScheduleSelect').value || defaultScheduleId;
  const projectId = document.getElementById('empProjectSelect').value || null;
  const bank = document.getElementById('empBankInput').value.trim();
  if(!id){ alert('Enter ID'); return; } if(!name){ alert('Enter Name'); return; }
  storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId };
  saveEmployeesToLS();
  document.getElementById('empIdInput').value=''; document.getElementById('empNameInput').value=''; document.getElementById('empRateInput').value=''; document.getElementById('empBankInput').value='';
  renderEmployees(); renderResults();
});
document.getElementById('clearEmployeesBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all employees?')) return;
  storedEmployees = {}; saveEmployeesToLS(); renderEmployees(); renderResults();
});

document.getElementById('empFileInput').addEventListener('change', (evt) => {
  const file = evt.target.files && evt.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      
const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
let added = 0, updated = 0;
rows.slice(1).forEach(row => {
  if (row && row.length >= 2) {
    const id = String(row[0] ?? '').trim();
    const name = String(row[1] ?? '').trim();
    const rate = row.length >= 3 ? parseFloat(row[2]) || 0 : 0;
    const schedName = row.length >= 4 ? String(row[3] ?? '').trim().toLowerCase() : '';
    const projName = row.length >= 5 ? String(row[4] ?? '').trim().toLowerCase() : '';

    const bank = row.length >= 6 ? String(row[5] ?? '').trim() : '';
    if (id && name) {
      if (!storedEmployees[id]) { added++; } else { updated++; }
      let scheduleId = Object.keys(storedSchedules).find(k => storedSchedules[k].name.toLowerCase() === schedName) || defaultScheduleId;
      let projectId = Object.keys(storedProjects).find(k => storedProjects[k].name.toLowerCase() === projName) || null;

      storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId };
    }
  }
});
saveEmployeesToLS();
renderEmployees();
renderResults();
if (added || updated) alert(`Imported: ${added}, Updated: ${updated}`);
 renderResults();
      if(added || updated) alert('Imported: ' + added + ' added, ' + updated + ' updated.');
    } catch (err) { console.error(err); alert('Error reading file.'); }
    finally { evt.target.value = ''; }
  };
  reader.readAsArrayBuffer(file);
});

function parseLine(line){
  if(!line || !line.trim()) return null;
  const parts = line.trim().split(/\t+/);
  if(parts.length >= 2){
    const id = parts[0].trim(); const dt = parts[1].trim();
    const m = dt.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})(:\d{2})?$/);
    if(m) return { empId: id, date: m[1], time: m[2] };
  }
  const m2 = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
  if(m2){
    const before = line.slice(0, m2.index); const idm = before.match(/(\d+)/);
    if(!idm) return null; return { empId: idm[1], date: m2[1], time: m2[2].slice(0,5) };
  }
  return null;
}



document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const inputEl = ev.target;
  const files = inputEl.files;
  if (!files || !files.length) return;

  let processed = 0, totalAdded = 0, errors = 0;
  const total = files.length;
  inputEl.disabled = true;

  Array.from(files).forEach(file=>{
    const r = new FileReader();
    r.onload = (e)=>{
      try {
        const content = String(e.target.result || '');
        const lines = content.split(/\r?\n/);
        let added = 0;
        for(const ln of lines){
          const p = (typeof parseLine === 'function') ? parseLine(ln) : null;
          if(p && p.empId && p.date && p.time){
            storedRecords.push({ empId: String(p.empId), date: p.date, time: padHM(p.time) });
            added++;
          }
        }
        // Refresh the DTR grid
        if (typeof renderResults === 'function') renderResults();
        // Persist the records to Supabase for cross‚Äëdevice sync.  We avoid
        // using localStorage here to prevent exceeding browser storage quotas.
        try {
          if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
        } catch (e) {
          console.warn('Failed to save DTR to Supabase', e);
        }
        totalAdded += added;
      } catch(err){
        console.error('Error reading', file.name, err);
        errors++;
      } finally {
        processed++;
        if (processed === total){
          inputEl.disabled = false; inputEl.value = '';
          if (errors > 0){
            alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
          } else {
            alert(`Upload successful: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}.`);
          }
        }
      }
    };
    r.onerror = ()=>{
      errors++; processed++;
      if (processed === total){
        inputEl.disabled = false; inputEl.value = '';
        alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
      }
    };
    r.readAsText(file);
  });
});


document.getElementById('clearData').addEventListener('click', ()=>{
  if(!confirm('Clear all saved attendance data?')) return;
  storedRecords = [];
  // Remove the locally cached attendance data
  localStorage.removeItem(LS_RECORDS);
  // Persist the cleared dataset to Supabase for cross‚Äëdevice sync
  try {
    if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
  } catch (e) {
    console.warn('Failed to clear DTR in Supabase', e);
  }
  renderResults();
});
document.getElementById('downloadCSV').addEventListener('click', ()=>{
  const rows = [['ID','Name','Project','Schedule','Date','AM In','AM Out','PM In','PM Out','OT In','OT Out','Total Regular Hrs','OT Hrs']];
  document.querySelectorAll('#resultsTable tbody tr').forEach(tr=>{
  const cells = Array.from(tr.querySelectorAll('td')).filter(td=>!td.classList.contains('actions-cell'));
  const rowVals = cells.map(td => {
    const sel = td.querySelector && td.querySelector('select');
    if (sel && sel.options && sel.selectedIndex >= 0) {
      const opt = sel.options[sel.selectedIndex];
      return (opt && opt.textContent) ? opt.textContent.trim() : '';
    }
    return td.textContent.trim();
  });
  rows.push(rowVals);
});
const csv = rows.map(r=>r.map(c=> (c.includes('"')||c.includes(',')||c.includes('\n')) ? '"' + c.replace(/"/g,'""') + '"' : c ).join(',')).join('\n');
  const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'attendance_with_ot.csv'; document.body.appendChild(a); a.click(); a.remove();
});
function padHM(hm){ if(!hm) return ''; const [h,m]=hm.split(':').map(x=>String(Number(x)).padStart(2,'0')); return h.padStart(2,'0')+':'+m.padStart(2,'0'); }
function toMins(hm){ if(!hm) return null; const [h,m]=hm.split(':').map(Number); return h*60+m; }
function minsToDecimal(mins){ return (mins/60).toFixed(2); }

function buildScheduleDropdown(empId, date, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesSchedules[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}
function buildProjectDropdown(empId, date, currentProjectId){
  const sel = document.createElement('select');
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesProjects[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

// Build a project dropdown for half-day (AM/PM) rows. Uses a key that
// appends the half identifier (e.g. '123___2023-08-19___AM') so that
// overrides can be stored separately for morning and afternoon entries.
function buildProjectDropdownHalf(empId, date, half, currentProjectId){
  const sel = document.createElement('select');
  // Include a none/default option
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    // Persist override keyed by empId + date + half
    overridesProjects[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    // Re-render to apply changes
    renderResults();
  });
  return sel;
}

// Build a schedule dropdown for half-day (AM/PM) rows. Similar to
// buildScheduleDropdown but stores overrides using a half-specific key.
function buildScheduleDropdownHalf(empId, date, half, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    overridesSchedules[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

function renderResults(){
  renderScheduleSelector();
  renderProjectFilterOptions();

  const startDate = document.getElementById('weekStart').value || null;
  const endDate = document.getElementById('weekEnd').value || null;
  currentProjectFilter = document.getElementById('filterProject') ? document.getElementById('filterProject').value : 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);

  
  const nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
const groups = {};
  for(const r of storedRecords){
    if(startDate && r.date < startDate) continue;
    if(endDate && r.date > endDate) continue;
    const key = r.date + '___' + r.empId;
    if(!groups[key]) groups[key]=[];
    groups[key].push(r.time);
  }

  const keys = Object.keys(groups).sort((a,b)=>{
    const [da,ea]=a.split('___'), [db,eb]=b.split('___');
    const nameA=(storedEmployees[ea] ? storedEmployees[ea].name : '').toLowerCase();
    const nameB=(storedEmployees[eb] ? storedEmployees[eb].name : '').toLowerCase();
    if(nameA && nameB){ if(nameA!==nameB) return nameA.localeCompare(nameB); if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb)); }
    if(nameA && !nameB) return -1; if(!nameA && nameB) return 1; if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb));
  });

  const tbody = document.querySelector('#resultsTable tbody'); tbody.innerHTML='';
  // Initialize totals for DTR summary. We will accumulate regular and OT hours and unique employee IDs
  let _dtrTotalReg = 0;
  let _dtrTotalOt  = 0;
  const _dtrEmpIds = new Set();

  const __nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
  for(const key of keys){
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId] || null;
      if (__nameQuery) { const _nm = (emp && emp.name ? String(emp.name).toLowerCase() : ''); if (_nm.indexOf(__nameQuery) === -1) continue; }
let empProjId = emp ? (emp.projectId || '') : '';
    const overrideKeyProj = empId + '___' + date;
    if(overridesProjects[overrideKeyProj] !== undefined) empProjId = overridesProjects[overrideKeyProj];
    const passesProject =
      currentProjectFilter === 'all' ||
      (currentProjectFilter === 'none' && !empProjId) ||
      currentProjectFilter === empProjId;
    if(!passesProject) continue;

    const times = Array.from(new Set(groups[key])).sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if(overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = storedSchedules[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);
    const rangesForEmp = {
      amIn: { start: schedule.rng_am_in_start || DEFAULT_RANGES.rng_am_in_start, end: schedule.rng_am_in_end || DEFAULT_RANGES.rng_am_in_end },
      amOut:{ start: schedule.rng_am_out_start || DEFAULT_RANGES.rng_am_out_start, end: schedule.rng_am_out_end || DEFAULT_RANGES.rng_am_out_end },
      pmIn: { start: schedule.rng_pm_in_start || DEFAULT_RANGES.rng_pm_in_start, end: schedule.rng_pm_in_end || DEFAULT_RANGES.rng_pm_in_end },
      pmOut:{ start: schedule.rng_pm_out_start || DEFAULT_RANGES.rng_pm_out_start, end: schedule.rng_pm_out_end || DEFAULT_RANGES.rng_pm_out_end },
      otIn: { start: schedule.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start, end: schedule.rng_ot_in_end || DEFAULT_RANGES.rng_ot_in_end },
      otOut:{ start: schedule.rng_ot_out_start || DEFAULT_RANGES.rng_ot_out_start, end: schedule.rng_ot_out_end || DEFAULT_RANGES.rng_ot_out_end }
    };

    const amInActual = pickEarliest(rangesForEmp.amIn), amOutActual = pickLatest(rangesForEmp.amOut);
    const pmInActual = pickEarliest(rangesForEmp.pmIn), pmOutActual = pickLatest(rangesForEmp.pmOut);

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otCandidates = times.filter(t => {
      const mins = toMins(t);
      return mins > pmOutRefMins && mins >= toMins(rangesForEmp.otIn.start) && mins <= toMins(rangesForEmp.otIn.end);
    });
    // --- Patched OT In/Out picking (DTR) ---
const otInCandidates = times.filter(t => {
  const m = toMins(t);
  return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otIn.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otIn.end);
});
const otInActual = otInCandidates.length ? otInCandidates[0] : null;

const otOutCandidates = times
  .filter(t => {
    const m = toMins(t);
    return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otOut.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otOut.end);
  })
  .filter(t => !otInActual || toMins(t) >= toMins(otInActual));
const otOutActual = otOutCandidates.length ? otOutCandidates[otOutCandidates.length - 1] : null;
// --- end patch ---

// Saturday fallback: if only a single OUT exists beyond the Saturday end, treat OT as (satEnd -> lastOut)
let otInCalc = otInActual;
let otOutCalc = otOutActual;
try {
  if (__isSaturday && __satEnd) {
    const lastOut = pmOutActual || amOutActual || null;
    const lastOutM = lastOut ? toMins(lastOut) : null;
    const satEndM = toMins(__satEnd);
    if (lastOutM !== null && lastOutM > satEndM) {
      if (!otInCalc) otInCalc = __satEnd;
      if (!otOutCalc) otOutCalc = lastOut;
    }
  }
} catch(e){ console.warn('Saturday OT fallback failed', e); }


    
    
    
    // Recompute regular time deterministically (no dependency on raw 'times' array)
    let totalMins = 0; const grace = Number(schedule.sch_grace) || 0;

    const clampSeg = (inStr, outStr, segStartStr, segEndStr) => {
      // Helper to add minutes
      const addMin = (m, d) => /* no-op placeholder removed */ m; // placeholder
    
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const segStart = toMins(segStartStr), segEndRaw = toMins(segEndStr);
      let segEnd = segEndRaw;
      // Auto-correct common input mistake: PM End typed as AM (e.g., 06:00 instead of 18:00)
      if (segEnd <= segStart && segStart >= 12*60 && segEnd <= 12*60) {
        segEnd += 12*60; // push to PM
      }
      if (segEnd <= segStart) return 0;
      if (inM <= segStart + grace) inM = segStart;
      const endM = Math.min(outM, segEnd);
      return Math.max(0, endM - inM);
    };

    if (__isSaturday && __satStart && __satEnd) {
      // Use the earliest actual IN and latest actual OUT between AM/PM within the Saturday window
      const firstIn  = amInActual || pmInActual || null;
      const lastOut  = pmOutActual || amOutActual || null;
      totalMins = clampSeg(firstIn, lastOut, __satStart, __satEnd);
    } else {
      // Weekdays: compute AM and PM independently; add them
      const hasBridge = !!(amInActual && !amOutActual && !pmInActual && pmOutActual);
      if (hasBridge) {
        const synthAmOut = schedule.sch_am_end || "12:00";
        const synthPmIn  = schedule.sch_pm_start || "13:00";
        totalMins =
          clampSeg(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
          clampSeg(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
      } else {
        const amMins = clampSeg(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
        const pmMins = clampSeg(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
        totalMins = amMins + pmMins;
      }
    }

    const totalRegularDecimal = minsToDecimal(totalMins);
let otMins = 0;
    if(otInCalc && otOutCalc){
      const otStartClamp = Math.max(toMins(otInCalc), toMins(__isSaturday ? (__satEnd || rangesForEmp.otIn.start) : rangesForEmp.otIn.start));
      const otEndClamp   = Math.min(toMins(otOutCalc), toMins(__isSaturday ? '23:59' : (rangesForEmp.otOut.end || rangesForEmp.otIn.end)));
      if(otEndClamp > otStartClamp) otMins = otEndClamp - otStartClamp;
    }
    
    // Saturday definitive OT computation: last OUT beyond Saturday end is OT
    try {
      if (__isSaturday && __satEnd) {
        const lastOut = (pmOutActual || amOutActual || null);
        if (lastOut) {
          const satEndM = toMins(__satEnd);
          const satStartClamp = Math.max(satEndM, toMins(schedule.rng_sat_ot_start || __satEnd || DEFAULT_RANGES.rng_sat_ot_start));
          const satEndClamp   = toMins(schedule.rng_sat_ot_end || DEFAULT_RANGES.rng_sat_ot_end);
          const lastOutM = toMins(lastOut);
          const startM = satStartClamp;
          const endM   = Math.min(lastOutM, satEndClamp);
          const diff = endM - startM;
          if (diff > 0) otMins = diff;
        }
      }
    } catch(e){ console.warn('Saturday OT direct compute failed', e); }
    const otDecimal = minsToDecimal(otMins);

    // --- Begin AM/PM Split Logic ---
    // If this record is flagged for split, render two separate rows (AM and PM)
    // instead of one combined row. A split is recorded in the `splits` object
    // keyed by the employee/date (empId + '___' + date). When a record is
    // split we compute the regular hours and overtime separately for the
    // morning and afternoon using the schedule assigned to that half (any
    // overrides are honoured). Each half has its own project and schedule
    // dropdowns. Grace periods are applied according to the selected schedule.
    const splitKey = empId + '___' + date;
    if (splits && splits[splitKey]) {
      // The employee name used for both halves
      const name = emp ? emp.name : '';
      // Helper to compute minutes for a segment using a specific schedule and grace
      const clampSegHalf = (inStr, outStr, segStartStr, segEndStr, sched) => {
        if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
        let inM = toMins(inStr);
        const outM = toMins(outStr);
        const segStart = toMins(segStartStr);
        let segEnd = toMins(segEndStr);
        // If a PM end is entered as an AM time (e.g., 06:00 instead of 18:00), fix it
        if (segEnd <= segStart && segStart >= 12 * 60 && segEnd <= 12 * 60) segEnd += 12 * 60;
        if (segEnd <= segStart) return 0;
        const g = Number(sched && sched.sch_grace) || 0;
        if (inM <= segStart + g) inM = segStart;
        const endM = Math.min(outM, segEnd);
        return Math.max(0, endM - inM);
      };
      // Computes OT minutes and the actual OT in/out times for the PM half
      const computeOtHalf = (sched) => {
        let otM = 0, otIn = null, otOut = null;
        // Reference end of the PM shift for deciding when OT starts
        let pmOutRef = pmOutActual ? toMins(pmOutActual) : toMins(sched.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end);
        // Check if the date is Saturday and fetch Saturday start/end times
        let isSat = false, satStart = null, satEnd = null;
        try {
          const dow = (function(d){
            const dt = new Date(d + 'T00:00');
            return (isNaN(dt) ? new Date(d) : dt).getDay();
          })(date);
          if (dow === 6) {
            isSat = true;
            satStart = sched.sch_sat_start || sched.sch_am_start || '08:00';
            satEnd   = sched.sch_sat_end   || sched.sch_pm_end || sched.sch_am_end || '11:00';
            pmOutRef = toMins(satEnd);
          }
        } catch(e) { /* ignore errors */ }
        // Build OT range windows using schedule or defaults
        const rng = {
          otIn: {
            start: sched.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start,
            end:   sched.rng_ot_in_end   || DEFAULT_RANGES.rng_ot_in_end
          },
          otOut: {
            start: sched.rng_ot_out_start || DEFAULT_RANGES.rng_ot_out_start,
            end:   sched.rng_ot_out_end   || DEFAULT_RANGES.rng_ot_out_end
          }
        };
        // Identify candidate OT IN times (first punch beyond pmOutRef in window)
        const otInCands = times.filter(t => {
          const m = toMins(t);
          return m > pmOutRef && m >= toMins(isSat ? satEnd : rng.otIn.start) && m <= toMins(isSat ? '23:59' : rng.otIn.end);
        });
        otIn = otInCands.length ? otInCands[0] : null;
        // Identify candidate OT OUT times (last punch beyond pmOutRef in window and after OT IN)
        const otOutCands = times.filter(t => {
          const m = toMins(t);
          return m > pmOutRef && m >= toMins(isSat ? satEnd : rng.otOut.start) && m <= toMins(isSat ? '23:59' : rng.otOut.end);
        }).filter(t => !otIn || toMins(t) >= toMins(otIn));
        otOut = otOutCands.length ? otOutCands[otOutCands.length - 1] : null;
        // Saturday fallback: treat a single OUT beyond Saturday end as OT
        if (isSat && satEnd) {
          const lastOut = pmOutActual || amOutActual || null;
          const lastOutM = lastOut ? toMins(lastOut) : null;
          const satEndM = toMins(satEnd);
          if (lastOutM !== null && lastOutM > satEndM) {
            if (!otIn) otIn = satEnd;
            if (!otOut) otOut = lastOut;
          }
        }
        // Compute OT minutes within clamped OT window
        if (otIn && otOut) {
          const startClamp = Math.max(toMins(otIn), toMins(isSat ? (satEnd || rng.otIn.start) : rng.otIn.start));
          const endClamp   = Math.min(toMins(otOut), toMins(isSat ? '23:59' : (rng.otOut.end || rng.otIn.end)));
          if (endClamp > startClamp) otM = endClamp - startClamp;
        }
        // Extra Saturday computation: last out beyond Saturday end counts fully as OT
        try {
          if (isSat && satEnd) {
            const lastOut = (pmOutActual || amOutActual || null);
            if (lastOut) {
              const satEndM = toMins(satEnd);
              const satStartClamp = Math.max(satEndM, toMins(sched.rng_sat_ot_start || DEFAULT_RANGES.rng_sat_ot_start));
              const satEndClamp   = toMins(sched.rng_sat_ot_end || DEFAULT_RANGES.rng_sat_ot_end);
              const lastOutM = toMins(lastOut);
              const startM = satStartClamp;
              const endM   = Math.min(lastOutM, satEndClamp);
              const diff = endM - startM;
              if (diff > 0) otM = diff;
            }
          }
        } catch(e) { /* ignore */ }
        return { mins: otM, otIn: otIn, otOut: otOut };
      };
      // Build two rows for AM and PM
      ['AM', 'PM'].forEach(function(half) {
        // Build keys for schedule and project overrides for this half
        const halfKey = empId + '___' + date + '___' + half;
        const schedIdHalf = (overridesSchedules && overridesSchedules[halfKey]) ? overridesSchedules[halfKey] : scheduleIdForEmp;
        const schedHalf = storedSchedules[schedIdHalf] || DEFAULT_SCHEDULE;
        // Regular minutes with grace for this half
        let regMinsHalf = 0;
        if (half === 'AM') {
          regMinsHalf = clampSegHalf(amInActual, amOutActual, schedHalf.sch_am_start || DEFAULT_SCHEDULE.sch_am_start, schedHalf.sch_am_end || DEFAULT_SCHEDULE.sch_am_end, schedHalf);
        } else {
          regMinsHalf = clampSegHalf(pmInActual, pmOutActual, schedHalf.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start, schedHalf.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end, schedHalf);
        }
        const regDecHalf = minsToDecimal(regMinsHalf);
        // OT calculation only applies to PM half
        let otDecHalf = '0.00';
        let otInHalf = null, otOutHalf = null;
        if (half === 'PM') {
          const otRes = computeOtHalf(schedHalf);
          otDecHalf = minsToDecimal(otRes.mins);
          otInHalf = otRes.otIn;
          otOutHalf = otRes.otOut;
        }
        // Determine project override for this half
        let projIdHalf;
        if (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey)) {
          projIdHalf = overridesProjects[halfKey];
        } else {
          projIdHalf = empProjId;
        }
        const trHalf = document.createElement('tr');
        let html = '';
        html += '<td>' + empId + '</td>';
        html += '<td>' + (name || '') + '</td>';
        // Placeholder cells for project and schedule dropdowns
        html += '<td></td><td></td>';
        html += '<td>' + date + '</td>';
        // Clock in/out for this half; blank for the other half
        if (half === 'AM') {
          html += (amInActual ? '<td>' + amInActual + '</td>' : '<td class="missing">‚Äî</td>');
          html += (amOutActual ? '<td>' + amOutActual + '</td>' : '<td class="missing">‚Äî</td>');
          html += '<td class="missing">‚Äî</td><td class="missing">‚Äî</td>';
        } else {
          html += '<td class="missing">‚Äî</td><td class="missing">‚Äî</td>';
          html += (pmInActual ? '<td>' + pmInActual + '</td>' : '<td class="missing">‚Äî</td>');
          html += (pmOutActual ? '<td>' + pmOutActual + '</td>' : '<td class="missing">‚Äî</td>');
        }
        // OT columns: only filled in for PM row
        if (half === 'PM') {
          html += (otInHalf ? '<td>' + otInHalf + '</td>' : '<td class="missing">‚Äî</td>');
          html += (otOutHalf ? '<td>' + otOutHalf + '</td>' : '<td class="missing">‚Äî</td>');
        } else {
          html += '<td class="missing">‚Äî</td><td class="missing">‚Äî</td>';
        }
        // Regular hours and OT hours columns
        html += '<td>' + regDecHalf + '</td><td>' + otDecHalf + '</td>';
        // Split action (unsplit) button
        html += '<td><button type="button" onclick="(function(){ splits[\'' + splitKey + '\'] = false; saveSplits(); renderResults(); })()">Unsplit</button></td>';
        trHalf.innerHTML = html;
        // Highlight if half-specific overrides are set
        const hasOverride = (overridesSchedules && overridesSchedules[halfKey]) || (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey));
        if (hasOverride) {
          trHalf.style.backgroundColor = '#fff3cd';
        }
        // Replace project cell with dropdown
        const pc = trHalf.cells[2];
        if (pc) {
          pc.innerHTML = '';
          pc.appendChild(buildProjectDropdownHalf(empId, date, half, projIdHalf));
        }
        // Replace schedule cell with dropdown
        const sc = trHalf.cells[3];
        if (sc) {
          sc.innerHTML = '';
          sc.appendChild(buildScheduleDropdownHalf(empId, date, half, schedIdHalf));
        }

        // Attach metadata to the split row for later reference (e.g., deletion)
        // Each split row knows its empId, date and which half it represents (AM or PM)
        trHalf.dataset.empId = empId;
        trHalf.dataset.date = date;
        trHalf.dataset.half = half;
        // Store the specific times associated with this half. These are used by the
        // delete function to remove only the relevant times. For the AM half we
        // include amIn and amOut times. For the PM half we include pmIn, pmOut
        // and any OT in/out times.
        (function(){
          const timesForHalf = [];
          if (half === 'AM') {
            if (amInActual) timesForHalf.push(amInActual);
            if (amOutActual) timesForHalf.push(amOutActual);
          } else {
            if (pmInActual) timesForHalf.push(pmInActual);
            if (pmOutActual) timesForHalf.push(pmOutActual);
            if (otInHalf) timesForHalf.push(otInHalf);
            if (otOutHalf) timesForHalf.push(otOutHalf);
          }
          trHalf.dataset.times = JSON.stringify(timesForHalf);
        })();
        tbody.appendChild(trHalf);
        // Accumulate DTR summary totals for this half
        // Parse numeric values of regular and OT hours
        const _regVal = parseFloat(regDecHalf) || 0;
        const _otVal  = parseFloat(otDecHalf) || 0;
        _dtrTotalReg += _regVal;
        _dtrTotalOt  += _otVal;
        _dtrEmpIds.add(empId);
      });
      // Skip default combined row rendering
      continue;
    }
    // --- End AM/PM Split Logic ---

    const name = emp ? emp.name : '';
    const scheduleName = storedSchedules[scheduleIdForEmp] ? storedSchedules[scheduleIdForEmp].name + (scheduleIdForEmp===defaultScheduleId ? ' (Default)' : '') : '';
    const projectName = (empProjId && storedProjects[empProjId]) ? storedProjects[empProjId].name : (emp && !emp.projectId ? '' : '');

    const cell = (v) => v ? '<td>'+v+'</td>' : '<td class="missing">‚Äî</td>';
    const tr = document.createElement('tr');
    tr.innerHTML =
      '<td>'+empId+'</td><td>'+name+'</td><td>'+projectName+'</td><td>'+scheduleName+'</td><td>'+date+'</td>' +
      cell(amInActual) + cell(amOutActual) + cell(pmInActual) + cell(pmOutActual) +
      (otInCalc ? '<td>'+otInCalc+'</td>' : '<td class=\"missing\">‚Äî</td>') +
      (otOutCalc ? '<td>'+otOutCalc+'</td>' : '<td class=\"missing\">‚Äî</td>') +
      '<td>'+totalRegularDecimal+'</td><td>'+otDecimal+'</td>' +
      '<td><button type="button" onclick="(function(){ splits[\'' + empId + '___' + date + '\'] = true; saveSplits(); renderResults(); })()">Split</button></td>';
    if(overridesSchedules[overrideKey] || overridesProjects[overrideKeyProj] !== undefined){
      tr.style.backgroundColor = '#fff3cd';
    }
    const projCell = tr.cells[2];
    if(projCell){ projCell.innerHTML = ''; projCell.appendChild(buildProjectDropdown(empId, date, empProjId)); }
    const schedCell = tr.cells[3];
    if(schedCell){ schedCell.innerHTML = ''; schedCell.appendChild(buildScheduleDropdown(empId, date, scheduleIdForEmp)); }
    tbody.appendChild(tr);
    // Accumulate totals for unsplit rows
    const _regVal = parseFloat(totalRegularDecimal) || 0;
    const _otVal  = parseFloat(otDecimal) || 0;
    _dtrTotalReg += _regVal;
    _dtrTotalOt  += _otVal;
    _dtrEmpIds.add(empId);
  }

  // Show/hide download button
  document.getElementById('downloadCSV').style.display =
    document.querySelectorAll('#resultsTable tbody tr').length ? 'inline-block' : 'none';
  // --- DTR Summary ---
  // After building the table, update the summary using accumulated totals
  (function(){
    const summaryEl = document.getElementById('dtrSummary');
    if (!summaryEl) return;
    const rowCount = document.querySelectorAll('#resultsTable tbody tr').length;
    if (!rowCount) {
      summaryEl.textContent = '';
      return;
    }
    // Compute combined total hours (regular + OT)
    const _dtrTotalHours = _dtrTotalReg + _dtrTotalOt;
    summaryEl.textContent = `Grand Total Hours: ${_dtrTotalHours.toFixed(2)} | Regular Hours: ${_dtrTotalReg.toFixed(2)} | OT Hours: ${_dtrTotalOt.toFixed(2)} | Employees: ${_dtrEmpIds.size}`;
  })();
}

document.getElementById('addProjectBtn').addEventListener('click', ()=>{
  const name = document.getElementById('projectNameInput').value.trim();
  if(!name) return alert('Enter project name');
  const id = 'proj_' + Date.now();
  storedProjects[id] = { name };
  document.getElementById('projectNameInput').value='';
  saveProjectsToLS();
});
document.getElementById('clearProjectsBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all projects?')) return;
  storedProjects = {}; saveProjectsToLS();
});

ensureSchedules();
renderScheduleSelector();
renderScheduleEditor();
renderEmployees();
renderProjects();
renderProjectFilterOptions();
const savedFilter = localStorage.getItem(LS_FILTER_PROJECT);
if(document.getElementById('filterProject') && savedFilter && [...document.getElementById('filterProject').options].some(o=>o.value===savedFilter)){
  document.getElementById('filterProject').value = savedFilter;
  currentProjectFilter = savedFilter;
}
renderResults();
document.addEventListener('DOMContentLoaded', function () {
  const dlBtn = document.getElementById('downloadEmployeesCSV');
  if (dlBtn) {
    dlBtn.addEventListener('click', () => {
      const rows = [['ID','Name','Hourly Rate','Bank Account','Schedule','Project']];
      Object.keys(storedEmployees).forEach(id => {
        const emp = storedEmployees[id] || {};
        const schedName = storedSchedules[emp.scheduleId]?.name || '';
        const projName = storedProjects[emp.projectId]?.name || '';
        const bank = emp.bankAccount || '';
      rows.push([id, emp.name || '', emp.hourlyRate || '', bank, schedName, projName]);
      });
      const csv = rows.map(r => r.map(v => {
        const s = String(v ?? '');
        return (s.includes(',') || s.includes('"') || s.includes('\\n'))
          ? '"' + s.replace(/"/g,'""') + '"'
          : s;
      }).join(',')).join('\\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'employees_backup.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
  }
});
  </script>
  <script>
function computeHoursForDateRange(startDate, endDate) {
  const totalsReg = {};
  const totalsOT = {};
  Object.keys(storedEmployees).forEach(id => {
    totalsReg[id] = 0;
    totalsOT[id] = 0;
  });

  const keys = Object.keys(storedSchedules).length ? storedSchedules : {default: DEFAULT_SCHEDULE};
  const grouped = {};

  for (const r of storedRecords) {
    if (startDate && r.date < startDate) continue;
    if (endDate && r.date > endDate) continue;
    const emp = storedEmployees[r.empId];
    if (!emp) continue;
    const dayKey = r.date + '___' + r.empId;
    if (!grouped[dayKey]) grouped[dayKey] = [];
    grouped[dayKey].push(r.time);
  }

  const toMins = hm => { const [h,m] = hm.split(':').map(Number); return h*60+m; };
  const minsToDec = mins => mins / 60;

  for (const key in grouped) {
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId];
    if (!emp) continue;

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if (overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = keys[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);

    const times = [...new Set(grouped[key])].sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    const amInActual = pickEarliest({start: schedule.rng_am_in_start, end: schedule.rng_am_in_end});
    const amOutActual = pickLatest({start: schedule.rng_am_out_start, end: schedule.rng_am_out_end});
    const pmInActual = pickEarliest({start: schedule.rng_pm_in_start, end: schedule.rng_pm_in_end});
    const pmOutActual = pickLatest({start: schedule.rng_pm_out_start, end: schedule.rng_pm_out_end});

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otInActual = pickEarliest({start: schedule.rng_ot_in_start, end: schedule.rng_ot_in_end});
    const otOutActual = pickLatest({start: schedule.rng_ot_out_start, end: schedule.rng_ot_out_end});

    let regMins = 0;
    const grace = Number(schedule.sch_grace) || 0;
    const segMins = (inStr, outStr, segStartStr, segEndStr) => {
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const sS = toMins(segStartStr), sEraw = toMins(segEndStr);
      let sE = sEraw;
      if (sE <= sS && sS >= 12*60 && sE <= 12*60) sE += 12*60; // fix 06:00 vs 18:00 typo
      if (sE <= sS) return 0;
      if (inM <= sS + grace) inM = sS; // grace on start
      const endM = Math.min(outM, sE);
      return Math.max(0, endM - inM);
    };
    // Normal pairs
    regMins += segMins(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
    regMins += segMins(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
    // Bridge case: AM IN + PM OUT only
    if (regMins === 0 && amInActual && !amOutActual && !pmInActual && pmOutActual) {
      const synthAmOut = schedule.sch_am_end || "12:00";
      const synthPmIn  = schedule.sch_pm_start || "13:00";
      regMins =
        segMins(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
        segMins(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
    }
    totalsReg[empId] += minsToDec(regMins);

    if (otInActual && otOutActual && toMins(otInActual) > pmOutRefMins) {
      totalsOT[empId] += minsToDec(toMins(otOutActual) - toMins(otInActual));
    }
  }
  return { totalsReg, totalsOT };
}
const dtrStartEl = document.getElementById('filterStart');
const dtrEndEl = document.getElementById('filterEnd');

function calculatePayrollFromRecords(){
  try { if (typeof renderResults === 'function') renderResults(); } catch(e){ console.warn('renderResults failed', e); }

  /*
   * Instead of deriving regular and OT hours from the filtered results table
   * (which can change when the DTR list is filtered), compute these values
   * directly from the underlying storedRecords for the selected date range.
   * This ensures that payroll calculations remain fixed regardless of
   * any filtering performed on the DTR tab.
   */
  try {
    // Determine the date range from the payroll period inputs.  Fall back
    // to the DTR filter inputs if the payroll period inputs are absent.
    const start = (typeof weekStartEl !== 'undefined' && weekStartEl && weekStartEl.value) ? weekStartEl.value : (dtrStartEl ? dtrStartEl.value : '');
    const end   = (typeof weekEndEl   !== 'undefined' && weekEndEl   && weekEndEl.value)   ? weekEndEl.value   : (dtrEndEl   ? dtrEndEl.value   : '');
    // Use the helper to compute per‚Äëemployee hours across the full dataset.
    const { totalsReg, totalsOT } = computeHoursForDateRange(start, end);
    // Initialize regHours and otHours with computed totals
    regHours = Object.assign({}, totalsReg || {});
    otHours  = Object.assign({}, totalsOT  || {});
    // Guarantee every employee has a defined entry (default 0)
    Object.keys(storedEmployees || {}).forEach(id => {
      if (!regHours.hasOwnProperty(id)) regHours[id] = 0;
      if (!otHours.hasOwnProperty(id))  otHours[id]  = 0;
    });
    // Persist hours to localStorage
    try {
      localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
      localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
    } catch (err) {
      console.warn('LS save failed', err);
    }
  } catch (err) {
    console.warn('Error computing hours from full records', err);
  }
  // Ensure hourly rates are populated for all employees
  Object.keys(storedEmployees || {}).forEach(id => {
    if (!payrollRates[id] || payrollRates[id] === 0) {
      payrollRates[id] = storedEmployees[id]?.hourlyRate || 0;
    }
  });
  // Persist rates
  try {
    localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
  } catch (err) {}
  // Rebuild the payroll table with the newly computed hours
  try {
    if (typeof renderTable === 'function') renderTable();
  } catch (err) {
    console.warn('renderTable failed', err);
  }
}

weekStartEl.addEventListener('change', () => {
  if (dtrStartEl) dtrStartEl.value = weekStartEl.value;
  calculatePayrollFromRecords();
  try { renderResults(); } catch(e){}
});
weekEndEl.addEventListener('change', () => {
  if (dtrEndEl) dtrEndEl.value = weekEndEl.value;
  calculatePayrollFromRecords();
  try { renderResults(); } catch(e){}
});
if (dtrStartEl) {
  dtrStartEl.addEventListener('change', () => {
    weekStartEl.value = dtrStartEl.value;
    calculatePayrollFromRecords();
  });
}
if (dtrEndEl) {
  dtrEndEl.addEventListener('change', () => {
    weekEndEl.value = dtrEndEl.value;
    calculatePayrollFromRecords();
  });
}

tabs.tabPayroll.addEventListener('click', () => {
  if (dtrStartEl && !weekStartEl.value) weekStartEl.value = dtrStartEl.value;
  if (dtrEndEl && !weekEndEl.value) weekEndEl.value = dtrEndEl.value;
  calculatePayrollFromRecords();
});
function backupData() {
  const data = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    data[key] = localStorage.getItem(key);
  }
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'payroll_backup.json';
  a.click();
}

function restoreData(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      for (const key in data) {
        localStorage.setItem(key, data[key]);
      }
      alert('Data restored! Reloading...');
      location.reload();
    } catch (err) {
      alert('Invalid backup file.');
    }
  };
  reader.readAsText(file);
}
document.addEventListener('DOMContentLoaded', () => {
  const container = document.createElement('div');
  container.style.marginTop = '20px';
  container.innerHTML = `
    <hr>
    <h3>Data Backup & Restore</h3>
    <button id="backupBtn">Backup Data</button>
    <input type="file" id="restoreInput" style="display:none;" />
    <button id="restoreBtn">Restore Data</button>
  `;
  document.body.appendChild(container);

  document.getElementById('backupBtn').addEventListener('click', backupData);
  document.getElementById('restoreBtn').addEventListener('click', () => {
    document.getElementById('restoreInput').click();
  });
  document.getElementById('restoreInput').addEventListener('change', function(){
    if (this.files.length) restoreData(this.files[0]);
  });
});
  </script>
 
<!-- Manual DTR Modal -->
<div id="manualDtrModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:1000; align-items:center; justify-content:center;">
  <div style="background:white; padding:20px; border-radius:8px; width:320px; max-width:95vw;">
    <h3 style="margin-top:0;">Enter Manual DTR</h3>
    <label>Employee:<br/>
      <select id="manualEmpSelect" style="width:100%;"></select>
    </label><br/><br/>
    <label>Date:<br/>
      <input type="date" id="manualDate" style="width:100%;"/>
    </label><br/><br/>
    <label>Time:<br/>
      <input type="time" id="manualTime" style="width:100%;"/>
    </label><br/><br/>
    <div style="text-align:right; display:flex; gap:8px; justify-content:flex-end;">
      <button id="cancelManualDtr">Cancel</button>
      <button id="saveManualDtr" class="primary">Save</button>
    </div>
  </div>
</div>

<script>
(function(){
  function openManualModal(){
    const modal = document.getElementById('manualDtrModal');
    const empSelect = document.getElementById('manualEmpSelect');
    const manualDate = document.getElementById('manualDate');
    const manualTime = document.getElementById('manualTime');
    if(!modal || !empSelect) return;
    empSelect.innerHTML = '';
    try {
      Object.keys(storedEmployees || {}).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        const nm = (storedEmployees[id] && storedEmployees[id].name) ? storedEmployees[id].name : '';
        opt.textContent = nm ? `${nm} (${id})` : id;
        empSelect.appendChild(opt);
      });
    } catch(e) {}
    manualDate.value = '';
    manualTime.value = '';
    modal.style.display = 'flex';
  }
  function closeManualModal(){
    const modal = document.getElementById('manualDtrModal');
    if(modal) modal.style.display = 'none';
  }
  function wireManualDTR(){
    const btn = document.getElementById('manualDtrBtn');
    const cancelBtn = document.getElementById('cancelManualDtr');
    const saveBtn = document.getElementById('saveManualDtr');
    if(btn) btn.addEventListener('click', openManualModal);
    if(cancelBtn) cancelBtn.addEventListener('click', closeManualModal);
    if(saveBtn) saveBtn.addEventListener('click', function(){
      const empId = (document.getElementById('manualEmpSelect')||{}).value;
      const dateVal = (document.getElementById('manualDate')||{}).value;
      const timeVal = (document.getElementById('manualTime')||{}).value;
      if(!empId || !dateVal || !timeVal){
        alert('Please fill all fields.');
        return;
      }
      try {
        storedRecords.push({ empId: String(empId), date: dateVal, time: timeVal });
        // Persist to Supabase for cross‚Äëdevice sync.  LocalStorage is not used
        // here to avoid hitting browser storage limits.
        if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
      } catch(e) { console.error('Saving manual DTR failed', e); }
      closeManualModal();
      if(typeof renderResults === 'function') renderResults();
    });
  }
  function ensureActionsHeader(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const theadRow = table.querySelector('thead tr');
    if(theadRow && !theadRow.querySelector('.actions-header')){
      const th = document.createElement('th');
      th.textContent = 'Actions';
      th.classList.add('actions-header');
      theadRow.appendChild(th);
    }
  }
  function addDtrDeleteButtons(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    ensureActionsHeader();
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => {
      if(tr.querySelector('.dtr-del-btn')) return;
      const td = document.createElement('td');
      td.className = 'actions-cell';
      const btn = document.createElement('button');
      btn.textContent = 'Delete';
      btn.className = 'dtr-del-btn';
      btn.addEventListener('click', () => {
        // Get empId and date from row cells (empId at col 0, date at col 4)
        const empIdCell = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
        const dateCell  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
        if(!empIdCell || !dateCell) return;
        // Determine if this row is part of a split (AM/PM). If so, use the attached
        // metadata to remove only the specific half. Otherwise, remove all times.
        const isSplitHalf = tr.dataset && tr.dataset.half;
        const confirmMsg = isSplitHalf
          ? `Delete this ${tr.dataset.half} DTR for ${empIdCell} on ${dateCell}?`
          : `Delete all DTR entries for ${empIdCell} on ${dateCell}?`;
        if(!confirm(confirmMsg)) return;
        try {
          if (isSplitHalf) {
            // Parse times to remove for this half. The dataset.times stores an array
            // of the exact time strings (e.g., "08:00", "12:00") that belong to
            // this AM or PM half. Only records with matching empId, date and time
            // found in this array will be removed.
            let timesForHalf = [];
            try {
              timesForHalf = JSON.parse(tr.dataset.times || '[]');
            } catch(e) { timesForHalf = []; }
            // Remove only the specific occurrences of each time listed for this half.
            // We iterate through the array of times and, for each, remove one matching
            // record (empId/date/time). This avoids removing duplicates beyond the
            // count present in timesForHalf (e.g., AM out and OT may share the same
            // time value, so we only remove the intended PM/OT instances).
            timesForHalf.forEach(t => {
              for (let i = 0; i < storedRecords.length; i++) {
                const rec = storedRecords[i];
                if (String(rec.empId) === String(empIdCell) && rec.date === dateCell && rec.time === t) {
                  storedRecords.splice(i, 1);
                  break; // remove only one matching occurrence per time value
                }
              }
            });
            // After removing the half, unset the split flag for this emp/date so
            // the remaining records render as a single row. This mirrors the
            // behavior of the "Unsplit" button.
            const splitKey = `${empIdCell}___${dateCell}`;
            if (splits && splits[splitKey]) {
              splits[splitKey] = false;
              if (typeof saveSplits === 'function') saveSplits();
            }
          } else {
            // Remove all records for this employee on this date
            for(let i = storedRecords.length - 1; i >= 0; i--){
              const rec = storedRecords[i];
              if(String(rec.empId) === String(empIdCell) && rec.date === dateCell){
                storedRecords.splice(i, 1);
              }
            }
          }
          // Persist updated records to Supabase so all devices reflect the
          // deletion.  LocalStorage is intentionally not used here to
          // prevent exceeding browser storage quotas.
          try {
            if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
          } catch (e) {
            console.warn('Failed to sync DTR deletion to Supabase', e);
          }
          renderResults();
        } catch(e){ console.error('DTR delete failed', e); }
      });
      td.appendChild(btn);
      tr.appendChild(td);
    });
  }
  function patchRenderResults(){
    if(typeof renderResults !== 'function') return false;
    const original = renderResults;
    window.renderResults = function(){
      const res = original.apply(this, arguments);
      try { addDtrDeleteButtons(); } catch(e){}
      // After rendering results, always check whether the selected payroll period is
      // locked and toggle editing accordingly. This ensures that dynamic
      // controls inserted by renderResults() respect the current lock state.
      try {
        if (typeof checkAndToggleEditState === 'function') {
          checkAndToggleEditState();
        }
      } catch(e) {}
      return res;
    };
    try { addDtrDeleteButtons(); } catch(e){}
    return true;
  }
  function init(){
    wireManualDTR();
    if(!patchRenderResults()){
      const iv = setInterval(() => {
        if(patchRenderResults()) clearInterval(iv);
      }, 200);
      setTimeout(() => clearInterval(iv), 6000);
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<script>
(function(){
  function q(id){ return document.getElementById(id); }
  function toMins(hm){ if(!hm) return null; var p=hm.split(':'), h=+p[0]||0, m=+p[1]||0; return h*60+m; }
  function minsToDec(mins){ return Math.round((mins/60)*100)/100; }
  function uniqSort(arr){ var seen={}, out=[]; for(var i=0;i<arr.length;i++){ var v=arr[i]; if(!seen[v]){ seen[v]=1; out.push(v);} } out.sort(); return out; }
  function max0(x){ return x>0?x:0; }

  // Extend tabs registry
  if (typeof tabs !== 'undefined' && tabs){
    tabs.tabProjectTotals   = document.getElementById('tabProjectTotals');
    tabs.panelProjectTotals = document.getElementById('panelProjectTotals');
  }

  // Wrap showTab to support projectTotals
  if (typeof showTab === 'function'){
    var _showTab = showTab;
    window.showTab = function(name){
      _showTab(name);
      if (name === 'projectTotals'){
        if (tabs.tabProjectTotals) tabs.tabProjectTotals.classList.add('active');
        if (tabs.panelProjectTotals) tabs.panelProjectTotals.classList.add('active');
        renderProjectTotals();
      }
    };
  }

  // Click to open our tab
  if (tabs && tabs.tabProjectTotals){
    tabs.tabProjectTotals.addEventListener('click', function(){ showTab('projectTotals'); });
  }

  // Re-render when date range changes while active
  ['weekStart','weekEnd'].forEach(function(id){
    var el = q(id);
    if (el) el.addEventListener('change', function(){
      if (tabs && tabs.tabProjectTotals && tabs.tabProjectTotals.classList.contains('active')) renderProjectTotals();
    });
  });

  
  // DTR name search live filter
  if (document.getElementById('dtrSearchName')) {
    document.getElementById('dtrSearchName').addEventListener('input', ()=>{
      renderResults();
    });
  }
// CSV export
  var dl = q('downloadProjectTotalsCSV');
  if (dl) dl.addEventListener('click', exportProjectTotalsCSV);

  // Core compute: honors date range + per-day project/schedule overrides + schedule windows, grace, OT windows
  function computeProjectTotals(startDate, endDate){
    var empMap = (typeof storedEmployees!=='undefined' && storedEmployees) || {};
    var schedMap = (typeof storedSchedules!=='undefined' && storedSchedules) || {};
    var defSchedId = (typeof defaultScheduleId!=='undefined' && defaultScheduleId) || null;
    var records = (typeof storedRecords!=='undefined' && storedRecords) || [];
    var projMap = (typeof storedProjects!=='undefined' && storedProjects) || {};
    var ovSched = (typeof overridesSchedules!=='undefined' && overridesSchedules) || {};
    var ovProj  = (typeof overridesProjects!=='undefined' && overridesProjects) || {};
    var DEF     = (typeof DEFAULT_SCHEDULE!=='undefined' && DEFAULT_SCHEDULE) || {};

    var dayGroups = {};
    for (var i=0;i<records.length;i++){
      var r = records[i];
      if (startDate && r.date < startDate) continue;
      if (endDate && r.date > endDate) continue;
      if (!empMap[r.empId]) continue;
      var key = r.date + '___' + r.empId;
      if (!dayGroups[key]) dayGroups[key] = [];
      dayGroups[key].push(r.time);
    }

    var totals = {}; // projectId => { name, reg, ot, total, employees:{} }
    var keys = Object.keys(dayGroups);
    for (var k=0;k<keys.length;k++){
      var key = keys[k];
      var parts = key.split('___');
      var date = parts[0], empId = parts[1];
      var emp = empMap[empId]; if (!emp) continue;

      var ovKey = empId + '___' + date;
      var projId = (ovProj.hasOwnProperty(ovKey) ? ovProj[ovKey] : (emp.projectId || '')) || '';
      var projName = (projId && projMap[projId]) ? (projMap[projId].name || projId) : '(No project)';

      var schedId = emp.scheduleId || defSchedId;
      if (ovSched[ovKey]) schedId = ovSched[ovKey];
      var S = (schedId && schedMap[schedId]) ? schedMap[schedId] : DEF;

      var times = uniqSort(dayGroups[key]);

      var win = {
        amIn:  {start:S.rng_am_in_start||'05:00', end:S.rng_am_in_end||'09:00'},
        amOut: {start:S.rng_am_out_start||'11:30', end:S.rng_am_out_end||'12:30'},
        pmIn:  {start:S.rng_pm_in_start||'12:30', end:S.rng_pm_in_end||'14:30'},
        pmOut: {start:S.rng_pm_out_start||'15:00', end:S.rng_pm_out_end||'20:00'},
        otIn:  {start:S.rng_ot_in_start||'19:00', end:S.rng_ot_in_end||'22:00'},
        otOut: {start:S.rng_ot_out_start||'19:00', end:S.rng_ot_out_end||'23:59'}
      };
      function pickEarliest(w){ for(var i2=0;i2<times.length;i2++){ var t=times[i2]; if(t>=w.start && t<=w.end) return t; } return null; }
      function pickLatest(w){ var last=null; for(var j2=0;j2<times.length;j2++){ var t2=times[j2]; if(t2>=w.start && t2<=w.end) last=t2; } return last; }

      var amIn  = pickEarliest(win.amIn);
      var amOut = pickLatest(win.amOut);
      var pmIn  = pickEarliest(win.pmIn);
      var pmOut = pickLatest(win.pmOut);

      var pmOutRefMins = pmOut ? toMins(pmOut) : toMins(S.sch_pm_end || '17:00');

      var otIn = null, otOut = null;
      for (var x=0;x<times.length;x++){
        var tt = times[x]; var m = toMins(tt);
        if (m>pmOutRefMins && m>=toMins(win.otIn.start) && m<=toMins(win.otIn.end)){ otIn = tt; break; }
      }
      for (var y=times.length-1;y>=0;y--){
        var tt2 = times[y]; var m2 = toMins(tt2);
        if (m2>pmOutRefMins && m2>=toMins(win.otOut.start) && m2<=toMins(win.otOut.end)){ otOut = tt2; if(!otIn || toMins(otOut)>=toMins(otIn)) break; }
      }

      var grace = Number(S.sch_grace)||0;
      var regMins = 0;

      if (amIn && pmOut && !amOut && !pmIn){
        var saS = toMins(S.sch_am_start||'08:00'), saE = toMins(S.sch_am_end||'12:00');
        var spS = toMins(S.sch_pm_start||'13:00'), spE = toMins(S.sch_pm_end||'17:00');
        var amInM = toMins(amIn), pmOutM = toMins(pmOut);
        var late = Math.max(0, amInM - saS);
        var under = Math.max(0, spE - pmOutM);
        var full = max0(saE-saS) + max0(spE-spS);
        regMins = (late <= grace) ? max0(full - under) : max0(full - late - under);
      } else {
        if (amIn && amOut){
          var inM = toMins(amIn), sS = toMins(S.sch_am_start||'08:00'), sE = toMins(S.sch_am_end||'12:00');
          if (inM <= sS + grace) inM = sS;
          var endM = Math.min(toMins(amOut), sE);
          if (endM > inM) regMins += (endM - inM);
        }
        if (pmIn && pmOut){
          var inM2 = toMins(pmIn), sS2 = toMins(S.sch_pm_start||'13:00'), sE2 = toMins(S.sch_pm_end||'17:00');
          if (inM2 <= sS2 + grace) inM2 = sS2;
          var endM2 = Math.min(toMins(pmOut), sE2);
          if (endM2 > inM2) regMins += (endM2 - inM2);
        }
      }

      var otMins = 0;
      if (otIn && otOut){
        var startClamp = Math.max(toMins(otIn), toMins(win.otIn.start));
        var endClamp   = Math.min(toMins(otOut), toMins(win.otOut.end));
        if (endClamp > startClamp) otMins = endClamp - startClamp;
      }

      var regDec = minsToDec(regMins);
      var otDec  = minsToDec(otMins);

      if (!totals[projId]) totals[projId] = { name: projName, reg: 0, ot: 0, total: 0, gross: 0, employees: {} };
      totals[projId].reg   = Math.round((totals[projId].reg + regDec)*100)/100;
      totals[projId].ot    = Math.round((totals[projId].ot  + otDec )*100)/100;
      totals[projId].total = Math.round((totals[projId].total + regDec + otDec)*100)/100;
      var rate = (emp && typeof emp.hourlyRate==='number') ? emp.hourlyRate : (+emp.hourlyRate||0);
      var otp = (document.getElementById('otMultiplier')&&parseFloat(document.getElementById('otMultiplier').value)) || 1.5;
      var grossInc = (regDec*rate) + (otDec*rate*otp);
      totals[projId].gross = Math.round((totals[projId].gross + grossInc)*100)/100;
      if (!totals[projId].employees[empId]) totals[projId].employees[empId] = { id: empId, name: (emp && emp.name) || '', reg: 0, ot: 0, total: 0, gross: 0, perDay: {} };
totals[projId].employees[empId].reg = Math.round((totals[projId].employees[empId].reg + regDec)*100)/100;
totals[projId].employees[empId].ot  = Math.round((totals[projId].employees[empId].ot  + otDec )*100)/100;
totals[projId].employees[empId].total = Math.round((totals[projId].employees[empId].total + regDec + otDec)*100)/100;
totals[projId].employees[empId].gross = Math.round((totals[projId].employees[empId].gross + grossInc)*100)/100;
// NEW: record per-day total hours (reg + OT) for this date
var _dTot = Math.round(((regDec + otDec))*100)/100;
if (!totals[projId].employees[empId].perDay) totals[projId].employees[empId].perDay = {};
totals[projId].employees[empId].perDay[date] = Math.round(((totals[projId].employees[empId].perDay[date]||0) + _dTot)*100)/100;
    }

    var rows = [];
    var pids = Object.keys(totals).sort(function(a,b){ var A=totals[a].name||''; var B=totals[b].name||''; return A.localeCompare(B); });
    for (var z=0; z<pids.length; z++){
      var pid = pids[z];
      var _emps = Object.values(totals[pid].employees || {}).sort(function(a,b){return (a.name||'').localeCompare(b.name||'') || String(a.id).localeCompare(String(b.id));});
rows.push({ projectId: pid, project: totals[pid].name, reg: totals[pid].reg, ot: totals[pid].ot, total: totals[pid].total, gross: totals[pid].gross, employees: Object.keys(totals[pid].employees).length , breakdown: _emps });
    }
    if (rows.length){
      var g = {reg:0, ot:0, total:0, gross:0, employees:0};
      for (var r=0;r<rows.length;r++){ g.reg+=rows[r].reg; g.ot+=rows[r].ot; g.total+=rows[r].total; g.gross+=rows[r].gross; g.employees+=rows[r].employees; }
      rows.push({ projectId: '__grand__', project: 'Grand Total', reg: Math.round(g.reg*100)/100, ot: Math.round(g.ot*100)/100, total: Math.round(g.total*100)/100, gross: Math.round(g.gross*100)/100, employees: g.employees });
    }
    return rows;
  }

  function renderProjectTotals(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var tbody = document.querySelector('#projectTotalsTable tbody'); if (!tbody) return;
    var data = computeProjectTotals(ws, we);
    tbody.innerHTML = '';
    if (!data.length){
      var tr = document.createElement('tr'); tr.innerHTML = '<td colspan="5" class="muted">No data for the selected date range.</td>'; tbody.appendChild(tr); return;
    }
    for (var i=0;i<data.length;i++){
      var row = data[i]; var tr = document.createElement('tr');
      tr.className = 'proj-row';
      if (row.projectId==='__grand__') tr.style.fontWeight = '700';
      tr.innerHTML = '<td>'+row.project+'</td>'
                   + '<td style="text-align:right">'+row.reg.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.ot.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.total.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+(row.gross!=null?row.gross.toFixed(2):'0.00')+'</td>'
                   + '<td style="text-align:right">'+row.employees+'</td>';
      tbody.appendChild(tr);
      if (row.projectId !== '__grand__' && Array.isArray(row.breakdown) && row.breakdown.length){
        tr.classList.add('has-breakdown');
        var dtr = document.createElement('tr');
        dtr.className = 'proj-emp-breakdown';
        var inner = '<td colspan="6" style="background:#f9fafb">'
  + '<div style="padding:8px 6px">'
  + '<strong>Employees (per-day hours):</strong>';

function dateRangeList(s, e){
  var out = []; if(!s || !e) return out;
  var d = new Date(s); var end = new Date(e);
  while (d <= end){ out.push(new Date(d)); d.setDate(d.getDate()+1); }
  return out;
}
var days = dateRangeList(ws, we);

inner += '<table style="width:100%;margin-top:6px;border-collapse:collapse">'
      + '<thead><tr>'
      + '<th style="text-align:left">ID</th>'
      + '<th style="text-align:left">Name</th>';
for (var di=0; di<days.length; di++){
  var dt = days[di];
  var label = (dt.getMonth()+1)+'/'+dt.getDate();
  inner += '<th style="text-align:right">'+label+'</th>';
}
inner += '<th style="text-align:right">Total Hrs</th>';
inner += '<th style="text-align:right">Total Amount</th>';
inner += '</tr></thead><tbody>';

for (var k=0;k<row.breakdown.length;k++){
  var e = row.breakdown[k];
  var totalRow = Number(e.total||0);
  var grossRow = Number(e.gross||0);
  inner += '<tr>'
        + '<td>'+(e.id ?? '')+'</td>'
        + '<td>'+(e.name ?? '')+'</td>';
  var perDay = (e.perDay||{});
  for (var di=0; di<days.length; di++){
    var dkey = days[di].toISOString().slice(0,10);
    var val = Number(perDay[dkey]||0).toFixed(2);
    inner += '<td style="text-align:right">'+val+'</td>';
  }
  inner += '<td style="text-align:right">'+ totalRow.toFixed(2) +'</td>';
  inner += '<td style="text-align:right">'+ grossRow.toFixed(2) +'</td>';
  inner += '</tr>';
}
inner += '</tbody></table></div></td>';
        dtr.innerHTML = inner;
        dtr.style.display = 'none';
        tbody.appendChild(dtr);
        // toggle and show detailed modal when a project row is clicked. The modal
        // provides a comprehensive breakdown and grand totals for the selected project.
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (function(detailRow, rowObj){
          return function(){
            // Show modal with project breakdown if available
            if (typeof showProjectReport === 'function') showProjectReport(rowObj);
            // Toggle the inline breakdown row visibility for quick reference
            if (detailRow) {
              detailRow.style.display = (detailRow.style.display === 'none' ? 'table-row' : 'none');
            }
          };
        })(dtr, row));
      }

    }
  }

  function exportProjectTotalsCSV(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var data = computeProjectTotals(ws, we);
    var rows = [['Week Start','Week End','Project','Regular Hours','OT Hours','Total Hours','Gross Amount','Employees']];
    for (var i=0;i<data.length;i++){ var r = data[i]; rows.push([ws,we,r.project,r.reg.toFixed(2),r.ot.toFixed(2),r.total.toFixed(2),(r.gross!=null?r.gross.toFixed(2):'0.00'),r.employees]); }
var csv = rows.map(function(r){
      return r.map(function(s){
        s = String(s==null?'':s);
        var needs = (s.indexOf('"')>=0) || (s.indexOf(',')>=0) || (s.indexOf('\n')>=0);
        if (needs) s = '"' + s.split('"').join('""') + '"';
        return s;
      }).join(',');
    }).join('\n');
    var blob = new Blob([csv], {type:'text/csv'}); var url = URL.createObjectURL(blob);
    var a = document.createElement('a'); a.href=url; a.download='project_totals.csv'; document.body.appendChild(a); a.click(); a.remove();
  }
})();
</script>


<script>
// --- Employees: small UX helpers ---
document.addEventListener('DOMContentLoaded', () => {
  const panel = document.querySelector('#panelEmployees');
  if (!panel) return;
  const form = panel.querySelector('form');
  if (!form) return;

  // Wrap form in a card if not already
  if (!form.closest('.form-card')) {
    const card = document.createElement('div');
    card.className = 'form-card';
    form.parentNode.insertBefore(card, form);
    card.appendChild(form);
  }

  // Enter-to-submit (except textarea)
  form.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
      e.preventDefault();
      const submit = form.querySelector('button[type="submit"], input[type="submit"]');
      if (submit) submit.click();
    }
  });

  // Auto-mark dangerous buttons
  form.querySelectorAll('button, input[type="button"]').forEach(el => {
    const text = (el.textContent || el.value || '').toLowerCase();
    if (/(clear|reset|delete|remove)/.test(text)) el.classList.add('btn-danger');
    if (/(save|add|submit|create)/.test(text)) el.classList.add('btn-primary');
  });

  // Group actions into a row if not already
  const actions = Array.from(form.querySelectorAll('button, input[type="submit"], input[type="button"]'));
  if (actions.length) {
    let bar = form.querySelector('.form-actions');
    if (!bar) {
      bar = document.createElement('div');
      bar.className = 'form-actions';
      // move trailing buttons into actions
      actions.forEach(btn => {
        if (!btn.closest('.form-actions')) bar.appendChild(btn);
      });
      form.appendChild(bar);
    }
  }
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('printProjectTotalsBtn');
  if (btn) btn.addEventListener('click', function(){ window.print(); });
});
</script>

<!-- Enhanced DTR Print -->
<script>
// Enhanced DTR print: clones the results table, removes 'Split' or 'Actions' columns,
// replaces dropdowns with selected text, and shows date range/project filter.
(function(){
  function printDTR(){
    try{
      var table = document.getElementById('resultsTable');
      if(!table){ alert('No DTR records to print.'); return; }
      // Capture selected texts from original selects
      var selectedTexts = [];
      var origSelects = table.querySelectorAll('select');
      origSelects.forEach(function(osel){
        var txt = '';
        try{
          var idx = osel.selectedIndex;
          if(idx >= 0 && osel.options[idx]){
            var opt = osel.options[idx];
            txt = (opt.textContent || opt.innerText || opt.value || '');
          }
        }catch(e){}
        selectedTexts.push(txt);
      });
      // Clone table
      var clone = table.cloneNode(true);
      // Remove columns labelled 'Split' or 'Actions'
      var dropIdx = [];
      clone.querySelectorAll('thead th').forEach(function(th, idx){
        var t = (th.textContent || '').trim().toLowerCase();
        if(t === 'split' || t === 'actions') dropIdx.push(idx);
      });
      if(dropIdx.length){
        // Remove header cells
        var headers = clone.querySelectorAll('thead th');
        headers.forEach(function(th, idx){
          if(dropIdx.indexOf(idx) !== -1){ th.remove(); }
        });
        // Remove columns from each row (in reverse order)
        clone.querySelectorAll('tbody tr').forEach(function(tr){
          var cells = tr.children;
          var sorted = dropIdx.slice().sort(function(a,b){ return b - a; });
          sorted.forEach(function(i){
            if(cells[i]) cells[i].remove();
          });
        });
      }
      // Replace select dropdowns in the clone with the captured text values
      var cloneSelects = clone.querySelectorAll('select');
      cloneSelects.forEach(function(csel, i){
        var td = csel.closest('td');
        if(td){ td.textContent = selectedTexts[i] || ''; }
      });
      // Remove any buttons inside the cloned table (e.g., split buttons)
      clone.querySelectorAll('button').forEach(function(btn){ btn.remove(); });
      // Build header for print
      var start = (document.getElementById('weekStart') || {}).value || '';
      var end = (document.getElementById('weekEnd') || {}).value || '';
      var hdr = 'Daily Time Records';
      if(start || end){
        hdr += ' ‚Äî ' + (start || '') + (end ? (' to ' + end) : '');
      }
      // Determine project filter text
      var filterSel = document.getElementById('filterProject');
      var filterTxt = '';
      if(filterSel){
        try{
          if(!filterSel.value || filterSel.value === 'all'){
            filterTxt = 'All Projects';
          } else {
            var o = filterSel.options[filterSel.selectedIndex];
            filterTxt = (o && (o.textContent || o.innerText || '')) || '';
          }
        }catch(e){}
      }
      var w = window.open('', '_blank', 'width=900,height=700');
      w.document.write('<!DOCTYPE html><html><head><meta charset="utf-8"><title>DTR Records</title>');
      w.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;margin:16px} h2{margin:0 0 6px} .muted{color:#555;margin:0 0 12px;font-size:12px} table{width:100%;border-collapse:collapse} th,td{border:1px solid #000;padding:6px;text-align:center;font-size:12px} th{background:#eee}</style>');
      w.document.write('</head><body>');
      w.document.write('<h2>' + hdr.replace(/</g, '&lt;') + '</h2>');
      if(filterTxt){
        w.document.write('<div class="muted">Project filter: ' + filterTxt.replace(/</g, '&lt;') + '</div>');
      }
      // Include summary of totals (Grand Total Hours, Regular, OT, Employees) if available
      try {
        var summaryEl = document.getElementById('dtrSummary');
        if(summaryEl){
          var summaryText = (summaryEl.textContent || '').trim();
          if(summaryText){
            // Escape angle brackets
            var safeSummary = summaryText.replace(/</g,'&lt;');
            w.document.write('<div style="margin:8px 0;font-weight:bold;font-size:12px;">'+ safeSummary +'</div>');
          }
        }
      } catch(e) {}
      w.document.write(clone.outerHTML);
      w.document.write('</body></html>');
      w.document.close();
      w.focus();
      w.print();
    }catch(err){
      alert('Unable to print DTR: ' + err);
    }
  }
  window.printDTR = printDTR;
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id === 'printDtrBtn'){
      printDTR();
    }
  });
})();
</script>



<script>
(function(){
  function _parse(n){ var x=parseFloat(String(n||'').replace(/[^0-9.\-]/g,'')); return isNaN(x)?0:x; }
  function _fmt(n){
    var v = Math.round((n||0)*100)/100;
    try { return v.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }
    catch(e){ return v.toFixed(2); }
  }

  // === Payroll ===
  function updatePayrollGrandTotals(){
    var tb = document.querySelector('#payrollTable tbody');
    var foot = document.querySelector('#payrollTotalsFoot');
    if (!tb || !foot) return;
    var t = {regHrs:0, otHrs:0, adjHrs:0, rate:0, regPay:0, otPay:0, grossPay:0, pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, totalDed:0, adjAmt:0, netPay:0};
    tb.querySelectorAll('tr').forEach(function(tr){
      t.regHrs   += _parse(tr.querySelector('.regHrs')?.value);
      t.otHrs    += _parse(tr.querySelector('.otHrs')?.value);
      // Sum adjustment hours from the adjHrs cell (displayed as text)
      t.adjHrs   += _parse(tr.querySelector('.adjHrs')?.textContent);
      t.rate     += _parse(tr.querySelector('.rate')?.value);
      t.regPay   += _parse(tr.querySelector('.regPay')?.textContent);
      t.otPay    += _parse(tr.querySelector('.otPay')?.textContent);
      t.grossPay += _parse(tr.querySelector('.grossPay')?.textContent);
      t.pagibig  += _parse(tr.querySelector('.pagibig')?.textContent);
      t.philhealth += _parse(tr.querySelector('.philhealth')?.textContent);
      t.sss      += _parse(tr.querySelector('.sss')?.textContent);
      t.loanSSS  += _parse(tr.querySelector('.loanSSS')?.value);
      t.loanPI   += _parse(tr.querySelector('.loanPI')?.value);
      t.vale     += _parse(tr.querySelector('.vale')?.value);
      t.valeWed  += _parse(tr.querySelector('.valeWed')?.value);
      t.totalDed += _parse(tr.querySelector('.totalDed')?.textContent);
      t.adjAmt   += _parse(tr.querySelector('.adjAmt')?.textContent);
      t.netPay   += _parse(tr.querySelector('.netPay')?.textContent);
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updatePayrollGrandTotals = updatePayrollGrandTotals;

  // === Deductions ===
  function _dedHeadMap(){
    var ths = Array.from(document.querySelectorAll('#deductionsTable thead th')).map(function(th){return (th.textContent||'').trim().toLowerCase();});
    function findIdx(keys){
      for (var i=0;i<ths.length;i++){
        for (var j=0;j<keys.length;j++){
          if (ths[i] === keys[j]) return i;
        }
        // loose contains for variants like "vale wed" vs "wed vale"
        for (var j=0;j<keys.length;j++){
          if (ths[i].indexOf(keys[j]) !== -1) return i;
        }
      }
      return -1;
    }
    return {
      id: findIdx(['id','emp id','employee id']),
      name: findIdx(['name','employee name']),
      pagibig: findIdx(['pag-ibig','pag ibig','pagibig']),
      philhealth: findIdx(['philhealth','phil health']),
      sss: findIdx(['sss']),
      loanSSS: findIdx(['sss loan','loan sss']),
      loanPI: findIdx(['pag-ibig loan','pag ibig loan','loan pi','pi loan']),
      vale: findIdx(['vale']),
      valeWed: findIdx(['vale wed','wed vale']),
      total: findIdx(['total','total deductions','total ded'])
    };
  }

  function updateDeductionsGrandTotals(){
    var tb = document.querySelector('#deductionsTable tbody');
    var foot = document.querySelector('#deductionsTable_foot');
    if (!tb || !foot) return;
    var map = _dedHeadMap();
    var t = {pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, total:0};
    tb.querySelectorAll('tr').forEach(function(tr){
      var c = tr.cells||[];
      function cell(idx){ return (idx>=0 && idx<c.length) ? c[idx].textContent : ''; }
      t.pagibig   += _parse(cell(map.pagibig));
      t.philhealth+= _parse(cell(map.philhealth));
      t.sss       += _parse(cell(map.sss));
      t.loanSSS   += _parse(cell(map.loanSSS));
      t.loanPI    += _parse(cell(map.loanPI));
      t.vale      += _parse(cell(map.vale));
      t.valeWed   += _parse(cell(map.valeWed));
      t.total     += _parse(cell(map.total));
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updateDeductionsGrandTotals = updateDeductionsGrandTotals;

  // Run on load
  function _initTotals(){
    try{ updatePayrollGrandTotals(); }catch(e){}
    try{ updateDeductionsGrandTotals(); }catch(e){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', _initTotals);
  } else { _initTotals(); }

  // Observe table changes to keep totals fresh
  try {
    var mo = new MutationObserver(function(){ try{updatePayrollGrandTotals();}catch(e){}; try{updateDeductionsGrandTotals();}catch(e){}; });
    var ptb = document.querySelector('#payrollTable tbody');
    var dtb = document.querySelector('#deductionsTable tbody');
    if (ptb) mo.observe(ptb, {childList:true, subtree:true, characterData:true});
    if (dtb) mo.observe(dtb, {childList:true, subtree:true, characterData:true});
  } catch(e){}

  // Also recalc on payroll inputs
  document.addEventListener('input', function(ev){
    if ((ev.target && ev.target.closest('#payrollTable'))) {
      try{ updatePayrollGrandTotals(); }catch(e){}
    }
  });

  // Patch into existing functions if present
  try {
    var _calcAll = window.calculateAll;
    if (typeof _calcAll === 'function'){
      window.calculateAll = function(){ var r = _calcAll.apply(this, arguments); try{updatePayrollGrandTotals();}catch(e){}; try{updateDeductionsGrandTotals();}catch(e){}; return r; };
    }
  } catch(e){}
  try {
    var _renderDed = window.renderDeductionsTable;
    if (typeof _renderDed === 'function'){
      window.renderDeductionsTable = function(){ var r = _renderDed.apply(this, arguments); try{updateDeductionsGrandTotals();}catch(e){}; return r; };
    }
  } catch(e){}

})();</script>

<script>
// Custom Payroll CSV export: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay)
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // If "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = parts[0].trim();
      var rhs = (parts.slice(1).join(',')).trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Else assume "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){
    var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,''));
    return isNaN(n) ? 0 : n;
  }
  function csvEscape(val){
    var s = String(val==null?'':val);
    var needs = /[",\n]/.test(s);
    if (needs) s = '"' + s.replace(/"/g,'""') + '"';
    return s;
  }
  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};
    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || '';
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });
    // Serialize
    return rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n');
  }
  function attachPayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    btn.addEventListener('click', function(){
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(e){
        console.error('Payroll CSV export failed', e);
        alert('Failed to build Payroll CSV.');
      }
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachPayrollCsv);
  } else {
    attachPayrollCsv();
  }
})();
</script>

<script>
// === Override Payroll CSV to: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay) ===
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // Handle "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = (parts.shift()||'').trim();
      var rhs = (parts.join(',')||'').trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Default "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){ var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,'')); return isNaN(n)?0:n; }
  function csvEscape(val){ var s=String(val==null?'':val); return /[",\n]/.test(s) ? ('"'+s.replace(/"/g,'""')+'"') : s; }

  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};

    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || ''; // Employee Account Number
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });

    return rows.map(r => r.map(csvEscape).join(',')).join('\n');
  }

  function overridePayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    // Remove all existing listeners by cloning
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(err){
        console.error('Payroll CSV export failed', err);
        alert('Failed to build Payroll CSV.');
      }
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', overridePayrollCsv);
  } else {
    overridePayrollCsv();
  }
})();
</script>


</div>






<link rel="preconnect" href="https://cdn.jsdelivr.net"/>


</div>




<script>
document.addEventListener('DOMContentLoaded', function(){
  var nodes = document.querySelectorAll('#cloudSyncCard');
  for (var i=1;i<nodes.length;i++){ nodes[i].remove(); }
});
</script>

<!-- Payslip Button functionality -->
<script>
// Add click listener for payslip buttons on payroll table
document.addEventListener('click', function(e) {
  var target = e.target;
  if (target && target.classList && target.classList.contains('payslipBtn')) {
    // Find the row for this button
    var row = target.closest('tr');
    if (!row) return;
    // Extract basic employee info
    var id = (row.cells[0]?.textContent || '').trim();
    var name = (row.cells[1]?.textContent || '').trim();
    // Helper to get value from input or text content
    function getVal(sel, prop) {
      var el = row.querySelector(sel);
      if (!el) return '';
      if (prop === 'value') return el.value || '';
      return el.textContent || '';
    }
    var reg = getVal('.regHrs', 'value');
    var ot = getVal('.otHrs', 'value');
    var rate = getVal('.rate', 'value');
    var regPay = getVal('.regPay', 'textContent');
    var otPay = getVal('.otPay', 'textContent');
    var gross = getVal('.grossPay', 'textContent');
    var pagibig = getVal('.pagibig', 'textContent');
    var philhealth = getVal('.philhealth', 'textContent');
    var sss = getVal('.sss', 'textContent');
    var sssLoan = getVal('.loanSSS', 'value');
    var piLoan = getVal('.loanPI', 'value');
    var valeAmt = getVal('.vale', 'value');
    var wedValeAmt = getVal('.valeWed', 'value');
    var total = getVal('.totalDed', 'textContent');
    var net = getVal('.netPay', 'textContent');
    var adjAmt = getVal('.adjAmt', 'textContent');
    // Period from week start/end inputs if available
    var ws = (typeof weekStartEl !== 'undefined' && weekStartEl) ? (weekStartEl.value || '') : '';
    var we = (typeof weekEndEl !== 'undefined' && weekEndEl) ? (weekEndEl.value || '') : '';
    // Build payslip HTML
    var html = '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Payslip - ' + name + '</title>' +
      '<style>body{font-family:Arial,Helvetica,sans-serif;padding:20px;line-height:1.4;} h2{text-align:center;}' +
      'table{border-collapse:collapse;width:100%;margin-top:12px;} th,td{border:1px solid #e2e8f0;padding:8px;text-align:left;font-size:14px;}' +
      'th{background:#f1f5f9;}</style></head><body>' +
      '<h2>Payslip</h2>' +
      '<p><strong>Employee ID:</strong> ' + id + '</p>' +
      '<p><strong>Name:</strong> ' + name + '</p>' +
      '<p><strong>Period:</strong> ' + ws + (we ? (' to ' + we) : '') + '</p>' +
      '<table>' +
      '<tr><th>Description</th><th>Value</th></tr>' +
      '<tr><td>Regular Hours</td><td>' + reg + '</td></tr>' +
      '<tr><td>OT Hours</td><td>' + ot + '</td></tr>' +
      '<tr><td>Hourly Rate</td><td>' + rate + '</td></tr>' +
      '<tr><td>Regular Pay</td><td>' + regPay + '</td></tr>' +
      '<tr><td>OT Pay</td><td>' + otPay + '</td></tr>' +
      '<tr><td>Gross Pay</td><td>' + gross + '</td></tr>' +
      '<tr><td>Pag-IBIG</td><td>' + pagibig + '</td></tr>' +
      '<tr><td>PhilHealth</td><td>' + philhealth + '</td></tr>' +
      '<tr><td>SSS</td><td>' + sss + '</td></tr>' +
      '<tr><td>SSS Loan</td><td>' + sssLoan + '</td></tr>' +
      '<tr><td>Pag-IBIG Loan</td><td>' + piLoan + '</td></tr>' +
      '<tr><td>Vale</td><td>' + valeAmt + '</td></tr>' +
      '<tr><td>Wed Vale</td><td>' + wedValeAmt + '</td></tr>' +
      '<tr><td>Adjustments</td><td>' + adjAmt + '</td></tr>' +
      '<tr><td>Total Deductions</td><td>' + total + '</td></tr>' +
      '<tr><th>Net Pay</th><th>' + net + '</th></tr>' +
      '</table>' +
      '</body></html>';
    // Open new window and write payslip content
    var w = window.open('', '', 'width=600,height=800');
    if (!w) return; // popup blocked
    w.document.open();
    w.document.write(html);
    w.document.close();
    w.focus();
    // Uncomment the line below to automatically trigger print dialog
    // setTimeout(function(){ w.print(); }, 0);
  }
});
</script>







<script>
(function(){
  const LS_FROM = 'dtr_filter_from';
  const LS_TO   = 'dtr_filter_to';

  function getEl(id){ return document.getElementById(id); }
  function loadSaved(){
    const from = localStorage.getItem(LS_FROM) || '';
    const to   = localStorage.getItem(LS_TO) || '';
    const f = getEl('dtrDateFrom'), t = getEl('dtrDateTo');
    if (f) f.value = from;
    if (t) t.value = to;
  }

  function withinRange(dateStr, from, to){
    if (!dateStr) return false;
    const s = dateStr.trim();
    if (!s) return false;
    if (from && s < from) return false;
    if (to   && s > to)   return false;
    return true;
  }

  function applyDtrDateFilter(){
    const f = getEl('dtrDateFrom')?.value || '';
    const t = getEl('dtrDateTo')?.value || '';
    try { localStorage.setItem(LS_FROM, f); } catch(e){}
    try { localStorage.setItem(LS_TO, t); } catch(e){}

    const tbody = document.querySelector('#resultsTable tbody');
    if (!tbody) return;
    const hasRange = !!(f || t);

    Array.from(tbody.rows).forEach(tr=>{
      // Adjust the index below if your Date column index is different.
      // Assuming the "Date" column is 4 (0-based), change as necessary.
      const dateStr = (tr.cells[4]?.textContent || '').trim();
      const show = !hasRange || withinRange(dateStr, f, t);
      tr.style.display = show ? '' : 'none';
    });

    // After applying the date filter, recompute the DTR summary to reflect only visible rows.
    const summaryEl = document.getElementById('dtrSummary');
    if (summaryEl) {
      // Initialize totals
      let regSum = 0;
      let otSum  = 0;
      const empSet = new Set();
      const rows = Array.from(tbody.rows);
      let visibleCount = 0;
      rows.forEach(row => {
        // Skip rows hidden by the date filter
        if (row.style.display === 'none') return;
        visibleCount++;
        // Extract values from the Total Regular Hrs and OT Hrs columns (indices 11 and 12)
        const regVal = parseFloat((row.cells[11]?.textContent || '').trim()) || 0;
        const otVal  = parseFloat((row.cells[12]?.textContent || '').trim()) || 0;
        regSum += regVal;
        otSum  += otVal;
        // Collect unique employee IDs (column 0)
        const idCell = (row.cells[0]?.textContent || '').trim();
        if (idCell) empSet.add(idCell);
      });
      // If there are visible rows, update the summary text; otherwise clear it
      if (visibleCount > 0) {
        const totalHours = regSum + otSum;
        summaryEl.textContent = `Grand Total Hours: ${totalHours.toFixed(2)} | Regular Hours: ${regSum.toFixed(2)} | OT Hours: ${otSum.toFixed(2)} | Employees: ${empSet.size}`;
      } else {
        summaryEl.textContent = '';
      }
    }
  }

  function hookUI(){
    const f = getEl('dtrDateFrom');
    const t = getEl('dtrDateTo');
    const c = getEl('dtrDateClear');
    if (f) f.addEventListener('change', applyDtrDateFilter);
    if (t) t.addEventListener('change', applyDtrDateFilter);
    if (c) c.addEventListener('click', ()=>{
      if (f) f.value = '';
      if (t) t.value = '';
      try { localStorage.removeItem(LS_FROM); } catch(e){}
      try { localStorage.removeItem(LS_TO); } catch(e){}
      applyDtrDateFilter();
    });
  }

  function monkeyPatchRender(){
    const orig = window.renderResults;
    if (typeof orig === 'function') {
      window.renderResults = function(){
        orig.apply(this, arguments);
        applyDtrDateFilter();
      };
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    // Inject controls right before #resultsTable if not already in DOM.
    if (!document.getElementById('dtrDateControls')){
      const table = document.getElementById('resultsTable');
      if (table && table.parentNode){
        const wrapper = document.createElement('div');
        wrapper.innerHTML = '<!-- DTR Date Finder Controls -->\n<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;">\n  <label style="display:flex;align-items:center;gap:.35rem;">\n    <span>Date:</span>\n    <input id="dtrDateFrom" type="date" />\n  </label>\n  <span>‚Äî</span>\n  <label>\n    <input id="dtrDateTo" type="date" />\n  </label>\n  <button id="dtrDateClear" type="button">Clear</button>\n</div>';
        table.parentNode.insertBefore(wrapper.firstElementChild, table);
      }
    }
    loadSaved();
    hookUI();
    monkeyPatchRender();
    applyDtrDateFilter();
  });
})();
</script>


<script>
// === Thousands Separator Formatting for Amounts (Payroll & Deductions) ===
(function(){
  // Format helper: 1,234.56
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function formatAllNumbers(){
    var sels = '#payrollTable td.num, #payrollTable tfoot td.num, #deductionsTable td.num';
    document.querySelectorAll(sels).forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g, '').trim();
      var num = parseFloat(raw);
      if (isFinite(num)) td.textContent = fmt(num);
    });
  }

  // Patch calculateAll to apply formatting after calculations
  function patchCalculateAll(){
    try{
      var orig = window.calculateAll;
      if (typeof orig === 'function'){
        window.calculateAll = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      } else {
        // If not defined yet, retry after load
        document.addEventListener('DOMContentLoaded', function(){
          if (typeof window.calculateAll === 'function'){
            patchCalculateAll(); 
            try { formatAllNumbers(); } catch(e){}
          }
        });
      }
    }catch(e){}
  }

  // Also patch renderDeductionsTable so that a manual refresh there also formats
  function patchRenderDeductions(){
    try{
      var orig = window.renderDeductionsTable;
      if (typeof orig === 'function'){
        window.renderDeductionsTable = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      }
    }catch(e){}
  }

  // Initial hooks
  patchCalculateAll();
  patchRenderDeductions();
  document.addEventListener('DOMContentLoaded', function(){
    try { formatAllNumbers(); } catch(e){}
  });
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function formatAllNumbers(){
    var sels = '#payrollTable td.num,#payrollTable tfoot td.num,#deductionsTable td.num,#reportTable td.num,#reportTable tfoot td.num';
    document.querySelectorAll(sels).forEach(td=>{
      var raw=(td.textContent||'').replace(/,/g,'').trim();
      var num=parseFloat(raw);
      if(isFinite(num)) td.textContent=fmt(num);
    });
  }
  function patch(fnName){
    var orig=window[fnName];
    if(typeof orig==='function'){
      window[fnName]=function(){
        var out=orig.apply(this,arguments);
        try{formatAllNumbers();}catch(e){}
        return out;
      }
    }
  }
  patch('calculateAll');
  patch('renderDeductionsTable');
  patch('renderReportTable');
  document.addEventListener('DOMContentLoaded',formatAllNumbers);
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function formatCells(cells){
    cells.forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (raw === '') return;
      var num = parseFloat(raw);
      if (isFinite(num)) td.textContent = fmt(num);
    });
  }
  function formatProjectTotals(){
    var tbl = document.getElementById('projectTotalsTable');
    if(!tbl) return;
    var tds = tbl.querySelectorAll('tbody td, tfoot td');
    formatCells(Array.from(tds));
  }
  function formatProjectModal(){
    var box = document.getElementById('projectReportContent');
    if (!box) return;
    var tds = box.querySelectorAll('td');
    formatCells(Array.from(tds));
  }
  // Patch showProjectReport to format modal numbers
  (function(){
    var orig = window.showProjectReport;
    if (typeof orig === 'function'){
      window.showProjectReport = function(){
        var out = orig.apply(this, arguments);
        try { formatProjectModal(); } catch(e){}
        return out;
      };
    }
  })();
  // Observe changes on the project totals table and auto-format
  document.addEventListener('DOMContentLoaded', function(){
    formatProjectTotals();
    var tbl = document.getElementById('projectTotalsTable');
    if (tbl && window.MutationObserver){
      var timer = null;
      var mo = new MutationObserver(function(){
        clearTimeout(timer);
        timer = setTimeout(formatProjectTotals, 50);
      });
      mo.observe(tbl.tBodies[0] || tbl, { childList: true, subtree: true });
    }
  });
})();
</script>


<script>
(function(){
  const ACTIVE_KEY = 'payroll_active';            // object map: key=start_end, value={startDate,endDate,rows,totals}
  const CURRENT_KEY = 'current_active_week';      // string: "YYYY-MM-DD__YYYY-MM-DD"
  const HIST_KEY = 'payroll_hist';                // existing history (may contain locked snapshots)

  function loadJSON(k, d){ try{ return JSON.parse(localStorage.getItem(k)||''); }catch(_){ return d; } }
  function saveJSON(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){} }

  function toKey(s,e){ return (s||'') + '__' + (e||''); }
  function fromKey(k){ const [s,e] = String(k||'').split('__'); return {start:s,end:e}; }

  // Build active store from locked history (one-time, if active is empty)
  function maybeSeedActiveFromHistory(){
    let active = loadJSON(ACTIVE_KEY, null);
    if (active && typeof active === 'object' && Object.keys(active).length) return;
    const hist = loadJSON(HIST_KEY, []);
    active = {};
    (hist||[]).forEach(s=>{
      if (s && s.startDate && s.endDate /* && s.locked */){
        const key = toKey(s.startDate, s.endDate);
        active[key] = { startDate:s.startDate, endDate:s.endDate, rows:s.rows||[], totals:s.totals||{} };
      }
    });
    saveJSON(ACTIVE_KEY, active);
  }

  function upsertActiveWeek(snap){
    if(!snap || !snap.startDate || !snap.endDate) return;
    const key = toKey(snap.startDate, snap.endDate);
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    active[key] = { startDate:snap.startDate, endDate:snap.endDate, rows:snap.rows||[], totals:snap.totals||{} };
    saveJSON(ACTIVE_KEY, active);
    localStorage.setItem(CURRENT_KEY, key);
  }

  function listActiveWeeks(){
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    return Object.keys(active).sort().map(k=>({ key:k, ...fromKey(k) }));
  }

  function fillActiveWeekSelects(){
    const weeks = listActiveWeeks();
    const current = localStorage.getItem(CURRENT_KEY) || (weeks[weeks.length-1]?.key || '');
    if (current) localStorage.setItem(CURRENT_KEY, current);
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      const prev = sel.value;
      sel.innerHTML='';
      weeks.forEach(w=>{
        const opt = document.createElement('option');
        opt.value = w.key;
        opt.textContent = `${w.start} ‚Üí ${w.end}`;
        sel.appendChild(opt);
      });
      if (weeks.length){
        sel.value = current && weeks.some(w=>w.key===current) ? current : weeks[weeks.length-1].key;
      }
    });
  }

  function applyActiveWeekToGlobals(){
    const key = localStorage.getItem(CURRENT_KEY) || '';
    const {start,end} = fromKey(key);
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    if (ws) ws.value = start || ws.value;
    if (we) we.value = end || we.value;
  }

  function reRenderAll(){
    try{ applyActiveWeekToGlobals(); }catch(_){}
    try{ window.renderResults && renderResults(); }catch(_){}
    try{ window.calculateAll && calculateAll(); }catch(_){}
    try{ window.renderReportTable && renderReportTable(); }catch(_){}
    // If you have totals/project tables:
    try{ window.formatAllNumbers && formatAllNumbers(); }catch(_){}
  }

  // Wire the dropdown "Apply" buttons
  function hookActiveWeekUI(){
    document.querySelectorAll('.refreshActiveWeek').forEach(btn=>{
      if (btn._wired) return;
      btn._wired = true;
      btn.addEventListener('click', ()=>{
        const sel = btn.parentElement && btn.parentElement.querySelector('.activeWeekSelect');
        if (!sel) return;
        localStorage.setItem(CURRENT_KEY, sel.value || '');
        applyActiveWeekToGlobals();
        reRenderAll();
      });
    });
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      if (sel._wired) return;
      sel._wired = true;
      sel.addEventListener('change', ()=>{
        localStorage.setItem(CURRENT_KEY, sel.value || '');
      });
    });
  }

  // Patch Generate to upsert into ACTIVE store (while keeping existing behavior)
  function patchGenerateToActive(){
    const btn = document.getElementById('dashGenerate');
    if (!btn || btn._activeWired) return;
    btn._activeWired = true;
    btn.addEventListener('click', async ()=>{
      // Wait a moment for existing listeners to compute tables, then capture
      setTimeout(()=>{
        try{
          const ws = document.getElementById('weekStart')?.value;
          const we = document.getElementById('weekEnd')?.value;
          if (!ws || !we) return;
          // Try to collect current payroll rows/totals from existing functions
          if (typeof window.buildSnapshot === 'function'){
            (async ()=>{
              const snap = await window.buildSnapshot(ws, we);
              if (snap) upsertActiveWeek(snap);
              fillActiveWeekSelects();
            })();
          } else {
            // Fallback: minimal capture from payroll table if present
            const rows = [];
            document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
              rows.push(Array.from(tr.cells).map(td=>td.textContent.trim()));
            });
            upsertActiveWeek({ startDate: ws, endDate: we, rows, totals:{} });
            fillActiveWeekSelects();
          }
        }catch(_){}
      }, 300);
    }, { capture: true });
  }

  // On load
  document.addEventListener('DOMContentLoaded', ()=>{
    maybeSeedActiveFromHistory();
    fillActiveWeekSelects();
    hookActiveWeekUI();
    patchGenerateToActive();

    // Optional: visually disable weekStart/weekEnd outside dashboard
    try {
      const onHashChange = () => {
        const ws = document.getElementById('weekStart');
        const we = document.getElementById('weekEnd');
        // Simple heuristic: if dashboard panel isn't visible, keep inputs disabled
        const dash = document.getElementById('panelDashboard');
        const dashActive = dash && (dash.classList.contains('active') || dash.style.display !== 'none');
        const disabled = !dashActive;
        if (ws) ws.disabled = disabled;
        if (we) we.disabled = disabled;
      };
      onHashChange();
      window.addEventListener('hashchange', onHashChange);
    } catch(_){}
  });
})();
</script>

<!-- Script to manage global Active Payroll dropdown and New Period functionality -->
<script>
(function(){
  const PAYROLL_HIST_KEY = 'payroll_hist';
  const LS_ACTIVE_INDEX = 'payroll_active_index';

  function loadHistory() {
    try {
      const hist = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
      return Array.isArray(hist) ? hist : [];
    } catch (e) {
      return [];
    }
  }

  function saveActiveIndex(idx) {
    localStorage.setItem(LS_ACTIVE_INDEX, String(idx));
  }

  function getActiveIndex() {
    const v = localStorage.getItem(LS_ACTIVE_INDEX);
    const n = v == null ? -1 : parseInt(v, 10);
    return Number.isFinite(n) ? n : -1;
  }

  function toIsoDate(s){
  if(!s) return '';
  if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) {
    const mm = String(parseInt(m[1],10)).padStart(2,'0');
    const dd = String(parseInt(m[2],10)).padStart(2,'0');
    return m[3] + '-' + mm + '-' + dd;
  }
  const d = new Date(s);
  if (!isNaN(d)) return d.toISOString().slice(0,10);
  return '';
}
function updateWeekInputs(snap) {
  const startISO = toIsoDate(snap && snap.startDate);
  const endISO   = toIsoDate(snap && snap.endDate);

  const ws = document.getElementById('weekStart');
  const we = document.getElementById('weekEnd');
  if (ws) ws.value = startISO || '';
  if (we) we.value = endISO   || '';

  // Notify listeners that the week range changed (so Reports can re-render)
  try {
    if (ws) ws.dispatchEvent(new Event('change', { bubbles: true }));
    if (we) we.dispatchEvent(new Event('change', { bubbles: true }));
  } catch (_) {}

  // DTR date inputs (type=date) must receive ISO; then fire change events
  try {
    const df = document.getElementById('dtrDateFrom');
    const dt = document.getElementById('dtrDateTo');
    if (df) { df.value = startISO || ''; df.dispatchEvent(new Event('change', { bubbles: true })); }
    if (dt) { dt.value = endISO   || ''; dt.dispatchEvent(new Event('change', { bubbles: true })); }
  } catch (_) {}

  // Refresh DTR list immediately
  try { if (typeof renderResults === 'function') { renderResults(); } } catch (e) {}

  // Recalculate payroll if available
  try { if (typeof calculatePayrollFromRecords === 'function') { calculatePayrollFromRecords(); } } catch (e) {}

  // After updating the week range, toggle editing state based on whether the
  // selected period is locked. Without this, switching between periods would
  // incorrectly leave the UI enabled for locked snapshots or vice versa.
  try {
    if (typeof checkAndToggleEditState === 'function') {
      checkAndToggleEditState();
    }
  } catch (e) {}
}

  function populateDropdowns() {
    // Prefer the global payrollHistory array if available, else fall back to localStorage
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const history = Array.isArray(hist) ? hist : [];
    // Build list of items with their original indices; sort newest first by start date
    const items = history.map((s, i) => Object.assign({ i: i }, s)).sort((a, b) => {
      return (b.startDate || '').localeCompare(a.startDate || '');
    });
    const globalSelect = document.getElementById('activePayrollSelect');
    const panelSelects = Array.from(document.querySelectorAll('.activeWeekSelect'));
    function fill(selectEl) {
      if (!selectEl) return;
      // Rebuild the dropdown options
      selectEl.innerHTML = '';
      items.forEach(item => {
        const opt = document.createElement('option');
        opt.value = String(item.i);
        opt.textContent = `${item.startDate || ''} ‚Äî ${item.endDate || ''}${item.locked ? ' (locked)' : ''}`;
        selectEl.appendChild(opt);
      });
      // Always set the selected value to the saved active index so all selectors stay in sync
      const saved = String(getActiveIndex());
      if ([...selectEl.options].some(o => o.value === saved)) {
        selectEl.value = saved;
      } else if (selectEl.options.length) {
        selectEl.selectedIndex = 0;
      }
    }
    fill(globalSelect);
    panelSelects.forEach(sel => {
      if (sel !== globalSelect) fill(sel);
    });
    // after filling, apply active
    const idxVal = parseInt((globalSelect && globalSelect.value) || getActiveIndex(), 10);
    const snap = Number.isFinite(idxVal) ? history[idxVal] : null;
    if (snap) {
      saveActiveIndex(idxVal);
      updateWeekInputs(snap);
    }
  }

  function onSelectChange(e) {
    const idx = parseInt(e.target.value, 10);
    if (!Number.isFinite(idx)) return;
    const history = loadHistory();
    if (!history[idx]) return;
    saveActiveIndex(idx);
    updateWeekInputs(history[idx]);
    // Keep all selects in sync
    populateDropdowns();
  }

  function onNewPeriod() {
    const start = prompt('Enter start date (YYYY-MM-DD):');
    const end = start ? prompt('Enter end date (YYYY-MM-DD):') : null;
    if (!start || !end) return;
    // Use global payrollHistory if available to check for existing ranges
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const exists = hist.some(s => s && s.startDate === start && s.endDate === end);
    if (exists) {
      alert('A payroll snapshot for this date range already exists.');
      return;
    }
    if (typeof buildSnapshot === 'function') {
      (async () => {
        const snap = await buildSnapshot(start, end);
        if (!snap) {
          alert('Payroll table is missing or empty.');
          return;
        }
        const json = JSON.stringify(snap);
        const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        const now = new Date().toISOString();
        const newSnap = { startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false };
        // Push into global payrollHistory if it exists; else push into local history
        if (Array.isArray(window.payrollHistory)) {
          window.payrollHistory.push(newSnap);
          // Persist via existing saveHistory function if available
          if (typeof saveHistory === 'function') saveHistory();
        } else {
          // Fallback: update localStorage directly
          const localHist = loadHistory();
          localHist.push(newSnap);
          localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(localHist));
        }
        // Refresh tables
        if (typeof renderHistory === 'function') {
          try { renderHistory(); } catch (err) {}
        }
        if (typeof renderActivePayrolls === 'function') {
          try { renderActivePayrolls(); } catch (err) {}
        }
        // Compute index for active snapshot using global array or fallback local array
        let idx;
        if (Array.isArray(window.payrollHistory)) {
          idx = window.payrollHistory.length - 1;
        } else {
          const localHist2 = loadHistory();
          idx = localHist2.length - 1;
        }
        saveActiveIndex(idx);
        populateDropdowns();
      })();
    } else {
      alert('buildSnapshot function not available.');
    }
  }

  function onPanelApply(e) {
    const wrap = e.target.closest('.active-week-bar');
    if (!wrap) return;
    const sel = wrap.querySelector('.activeWeekSelect');
    if (!sel) return;
    onSelectChange({ target: sel });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const globalSelect = document.getElementById('activePayrollSelect');
    if (globalSelect) {
      globalSelect.addEventListener('change', onSelectChange);
    }
    const newBtn = document.getElementById('newPayrollPeriod');
    if (newBtn) {
      newBtn.addEventListener('click', onNewPeriod);
    }
    document.addEventListener('click', (e) => {
      if (e.target && e.target.classList && e.target.classList.contains('refreshActiveWeek')) {
        onPanelApply(e);
      }
    });
    populateDropdowns();
  });

  (function() {
    const tbody = document.querySelector('#historyTable tbody');
    if (!tbody) return;
    const observer = new MutationObserver(() => {
      try {
        populateDropdowns();
      } catch (err) {}
    });
    observer.observe(tbody, { childList: true, subtree: false });
  })();
})();
</script>

<script>
/* Cash Advance Tracker implementation.  Handles sub-tab navigation within the
 * Deductions tab and provides a per-employee cash advance table that stores
 * original amounts, deductions and current balances.  The tracker updates
 * the main Deductions table's Vale column via the `vale` object and calls
 * `calculateAll()` whenever a deduction or payment changes. */

(function(){
  // Ensure new cash-advance keys are mirrored to Supabase by adding them to KNOWN_KEYS.
  // Use window.KNOWN_KEYS exclusively because the constant KNOWN_KEYS is scoped to the
  // module that defines the Supabase adapter. Without referencing window.KNOWN_KEYS
  // here, attempts to push new keys could throw a ReferenceError if KNOWN_KEYS is
  // not defined in the global scope. Wrapping in a try/catch protects against any
  // unexpected errors while still allowing the page to function normally.
  try {
    const extra = ['payroll_cashAdvanceOrig', 'payroll_cashAdvanceDed', 'payroll_cashAdvanceBal'];
    if (window.KNOWN_KEYS) {
      extra.forEach(k => {
        const keys = window.KNOWN_KEYS;
        if (!Array.isArray(keys)) return;
        if (!keys.includes(k)) keys.push(k);
      });
    }
  } catch (err) {
    // Swallow errors silently; failure to add keys will simply leave them local-only.
  }

  // Render the cash advance tracker table
  function renderCashAdvanceTable() {
    const tb = document.querySelector('#cashAdvanceTable tbody');
    if (!tb) return;
    tb.innerHTML = '';
    (employeeList || []).forEach(emp => {
      const id = emp.id;
      const name = emp.name || '';
      const origVal = Number(cashOrig[id] ?? 0);
      const dedVal  = Number(cashDed[id] ?? 0);
      // Determine the current balance.  If no explicit balance is stored for
      // this employee yet, default to the original amount (not yet updated).
      const hasBal = cashBal.hasOwnProperty(id);
      const balVal = hasBal ? Number(cashBal[id] || 0) : origVal;
      // Decide if update button should be disabled and what label it should have.
      // The update button remains active after each click to allow multiple deductions until the balance is zero.
      let btnLabel = 'Update';
      let disabled = false;
      if (!origVal || !dedVal) {
        // Need both original amount and deduction to enable update
        disabled = true;
      } else if (balVal <= 0) {
        // Fully paid off
        btnLabel = 'Paid';
        disabled = true;
      }
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${id}</td>
        <td class="wrap">${name}</td>
        <td><input type="number" step="0.01" class="cashOrig" data-id="${id}" value="${origVal || ''}"></td>
        <td><input type="number" step="0.01" class="cashDed" data-id="${id}" value="${dedVal || ''}"></td>
        <td class="cashBal">${balVal ? balVal.toFixed(2) : '0.00'}</td>
        <td><button class="cashUpdateBtn" data-id="${id}" ${disabled ? 'disabled' : ''}>${btnLabel}</button></td>
      `;
      tb.appendChild(tr);
    });
    attachCashAdvanceHandlers();
  }

  function attachCashAdvanceHandlers() {
    // Handle original amount changes
    document.querySelectorAll('.cashOrig').forEach(inp => {
      // Update the in‚Äëmemory values on every keystroke but defer re‚Äërendering
      inp.addEventListener('input', () => {
        const id = inp.getAttribute('data-id');
        const val = parseFloat(inp.value);
        if (!isNaN(val) && val > 0) {
          cashOrig[id] = +(val.toFixed(2));
          // Reset balance to original whenever original amount changes
          cashBal[id] = +(val.toFixed(2));
        } else {
          delete cashOrig[id];
          delete cashBal[id];
        }
        localStorage.setItem(LS_CASH_ORIG, JSON.stringify(cashOrig));
        localStorage.setItem(LS_CASH_BAL, JSON.stringify(cashBal));
        // Do not call renderCashAdvanceTable() here; this would rebuild the table
        // on every keystroke and cause the input to lose focus.  Re‚Äërender on blur instead.
      });
      // When the user finishes editing (on blur/change), rebuild the table so buttons/labels refresh
      inp.addEventListener('change', () => {
        renderCashAdvanceTable();
      });
    });
    // Handle deduction changes
    document.querySelectorAll('.cashDed').forEach(inp => {
      // Update the deduction and recalculate totals on each keystroke but do not re‚Äërender
      inp.addEventListener('input', () => {
        const id = inp.getAttribute('data-id');
        const val = parseFloat(inp.value);
        if (!isNaN(val) && val > 0) {
          cashDed[id] = +(val.toFixed(2));
          // Persist the deduction for this employee
          vale[id] = +(val.toFixed(2));
        } else {
          delete cashDed[id];
          delete vale[id];
        }
        localStorage.setItem(LS_CASH_DED, JSON.stringify(cashDed));
        localStorage.setItem(LS_VALE, JSON.stringify(vale));
        calculateAll();
        // Avoid calling renderCashAdvanceTable() here; it would reset focus on every key press.
      });
      // Rebuild the table when the user commits their change (on blur/change)
      inp.addEventListener('change', () => {
        renderCashAdvanceTable();
      });
    });
    // Handle update (apply a single deduction)
    document.querySelectorAll('.cashUpdateBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-id');
        const orig = Number(cashOrig[id] ?? 0);
        const ded  = Number(cashDed[id] ?? 0);
        // Only proceed if we have valid original and deduction amounts
        if (!orig || !ded) return;
        // Determine the current balance; fall back to original amount if no stored balance exists.
        const currentBal = cashBal.hasOwnProperty(id) ? Number(cashBal[id] || 0) : orig;
        // Compute new balance by subtracting the deduction from the current balance.
        let newBal = +(currentBal - ded);
        if (newBal <= 0) {
          // Fully paid off: set balance to zero and clear deduction and vale
          newBal = 0;
          delete cashDed[id];
          delete vale[id];
          localStorage.setItem(LS_CASH_DED, JSON.stringify(cashDed));
          localStorage.setItem(LS_VALE, JSON.stringify(vale));
        }
        // Persist the new balance
        cashBal[id] = +(newBal.toFixed(2));
        localStorage.setItem(LS_CASH_BAL, JSON.stringify(cashBal));
        calculateAll();
        // Re-render the table to reflect the updated balance; the update button remains active.
        renderCashAdvanceTable();
      });
    });
  }

  // Wire up the sub-tab navigation within the Deductions tab
  document.addEventListener('DOMContentLoaded', () => {
    const navBtns = document.querySelectorAll('#deductionsTab .subtab-nav .subtab-btn');
    navBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        navBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const target = btn.getAttribute('data-subtab');
        // Show the selected panel and hide others
        document.querySelectorAll('#deductionsTab .subtab-panel').forEach(panel => {
          panel.style.display = (panel.id === target) ? '' : 'none';
        });
      });
    });
    // Initialize panel visibility on page load
    document.querySelectorAll('#deductionsTab .subtab-panel').forEach(panel => {
      panel.style.display = (panel.id === 'dedMainSection') ? '' : 'none';
    });
    renderCashAdvanceTable();
  });
  // On page load, immediately check whether the currently selected payroll period
  // is locked and toggle the UI accordingly. Without this, the DTR panel may
  // remain interactive on initial load even if the chosen period has been
  // previously locked. The check is wrapped in a try-catch to avoid
  // exceptions during startup.
  document.addEventListener('DOMContentLoaded', () => {
    try {
      if (typeof checkAndToggleEditState === 'function') {
        checkAndToggleEditState();
      }
    } catch (e) {}
  });
})();
</script>

<!-- =====================================================================
     DTR Cloud Persistence with Supabase

     The payroll application originally stored uploaded DTR records exclusively
     in localStorage.  Browsers typically limit localStorage to about 5¬†MB,
     which can be quickly exceeded when importing large attendance files.  To
     provide true cross‚Äëdevice persistence and remove the size constraint,
     the functions below save and load the DTR dataset via Supabase.  They
     expect a table named `dtr_records` in your Supabase database with the
     following schema:

         CREATE TABLE dtr_records (
           id text PRIMARY KEY,
           data jsonb
         );

     The policy can mirror the permissive configuration used for kv_store:

         -- Allow anon users to read and write the single row
         CREATE POLICY "Allow all access to dtr_records" ON dtr_records
           FOR ALL USING (true) WITH CHECK (true);

     The row uses a fixed primary key (id = 'records') so that each upsert
     overwrites the existing dataset.  If you wish to store separate sets
     by period or company, you can adjust the id accordingly.  When the
     page loads it attempts to fetch the remote DTR and, if found, will
     populate the global `storedRecords` array and update localStorage.
     Uploaded files are automatically persisted to the cloud via
     saveDtrToCloud(), invoked in the file upload handler above.
===================================================================== -->
<script>
/*
 * Save the entire DTR dataset to Supabase.  This helper uses the
 * globally scoped `supabase` client (injected by the KV sync adapter)
 * to upsert the records into the `dtr_records` table.  The primary
 * key is fixed to 'records' so that only a single row is maintained.
 */
async function saveDtrToCloud(records) {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa) return;
    const { error } = await supa
      .from('dtr_records')
      .upsert({ id: 'records', data: records }, { onConflict: 'id' });
    if (error) console.error('Supabase DTR save error:', error.message);
  } catch (e) {
    console.error('Supabase DTR save failed', e);
  }
}

/*
 * Retrieve the DTR dataset from Supabase.  Returns an array of
 * attendance records if available, otherwise null.  The returned
 * object is expected to have the shape { data: [...] }, so we
 * unwrap the nested data field when present.
 */
async function loadDtrFromCloud() {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa) return null;
    const { data, error } = await supa
      .from('dtr_records')
      .select('data')
      .eq('id', 'records')
      .single();
    if (error) {
      // Only warn on fetch errors to avoid blocking page load.  The
      // application will fall back to localStorage if the fetch fails.
      console.warn('Supabase DTR fetch error:', error.message);
      return null;
    }
    return data && Array.isArray(data.data) ? data.data : null;
  } catch (e) {
    console.error('Supabase DTR fetch failed', e);
    return null;
  }
}

// On initial load, attempt to hydrate storedRecords from Supabase.  If
// remote data exists it will overwrite the current storedRecords array
// and localStorage.  This ensures that the latest DTR data is available
// across devices while preserving offline capability.  The call is
// performed after DOMContentLoaded to ensure that other scripts have
// defined storedRecords and renderResults() before we modify them.
document.addEventListener('DOMContentLoaded', async function () {
  try {
    // Prefer the new attendance table if available.  This fetches all
    // records when no start/end dates are provided.  If data exists
    // it will replace the in-memory storedRecords and skip the old
    // bulk JSON hydration logic.
    const remoteRows = await loadAttendanceByDateRange();
    if (Array.isArray(remoteRows) && remoteRows.length) {
      if (typeof storedRecords !== 'undefined') {
        storedRecords = remoteRows;
      } else {
        window.storedRecords = remoteRows;
      }
      // Avoid filling up localStorage with the full dataset; remove any
      // prior cached copy instead of re-saving it.  Offline access may
      // be limited but the remote store will persist across devices.
      try { localStorage.removeItem(LS_RECORDS); } catch (_) {}
      // Render the DTR grid using the fresh data
      if (typeof renderResults === 'function') {
        try { renderResults(); } catch (e) {}
      }
      return;
    }
  } catch (e) {
    console.error('Supabase attendance hydration failed', e);
  }
  try {
    // Fallback to the legacy bulk JSON record when attendance table is
    // empty or unavailable.  This mirrors the previous behaviour of
    // loading a single row of JSON from the dtr_records table.
    const remote = await loadDtrFromCloud();
    if (remote && Array.isArray(remote)) {
      if (typeof storedRecords !== 'undefined') {
        storedRecords = remote;
      } else {
        window.storedRecords = remote;
      }
      // Persist into localStorage for offline fallback; this may exceed
      // browser storage quotas on very large datasets, in which case
      // saving may silently fail.
      try { localStorage.setItem(LS_RECORDS, JSON.stringify(remote)); } catch (e) {}
      if (typeof renderResults === 'function') {
        try { renderResults(); } catch (e) {}
      }
    }
  } catch (e) {
    console.error('Error hydrating DTR from Supabase', e);
  }
});
</script>

</body>
</html>
