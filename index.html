
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PayrollPro</title>

  <!-- Performance: preconnect to critical origins and modulepreload -->
  <link rel="preconnect" href="https://qzkzugzfpegozpiqutdv.supabase.co" crossorigin>
  <link rel="dns-prefetch" href="//qzkzugzfpegozpiqutdv.supabase.co">
  <link rel="preconnect" href="https://esm.sh" crossorigin>
  <link rel="dns-prefetch" href="//esm.sh">
  <link rel="modulepreload" href="https://esm.sh/@supabase/supabase-js@2?bundle" crossorigin>

  <script type="module">
    // Non-invasive performance tweaks: lazy-load offscreen media, async decode images.
    const onReady = (cb) => {
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once: true });
      else cb();
    };
    onReady(() => {
      try {
        const vh = window.innerHeight || document.documentElement.clientHeight || 800;
        document.querySelectorAll('img').forEach(img => {
          try { if (!img.hasAttribute('decoding')) img.setAttribute('decoding', 'async'); } catch {}
          if (!img.hasAttribute('loading')) {
            const rect = img.getBoundingClientRect();
            if (rect && rect.top > vh) { try { img.setAttribute('loading', 'lazy'); } catch {} }
          }
        });
        document.querySelectorAll('iframe').forEach(el => {
          if (!el.hasAttribute('loading')) { try { el.setAttribute('loading', 'lazy'); } catch {} }
        });
      } catch { /* no-op */ }
    });
  </script>

<!-- === Supabase KV Sync Adapter (no-login, auto-sync) === -->
<script>
  // Global KV helpers for classic scripts; Supabase-aware if available.
  (function () {
    if (!window.__kvUnifiedLogged) {
      console.log("KV: using unified read/write");
      window.__kvUnifiedLogged = true;
    }
    if (!window.readKV) {
      window.readKV = async function readKV(key, defaultValue = null) {
        try {
          if (window.supabase && window.SUPABASE_TABLE) {
            const { data, error } = await window.supabase
              .from(window.SUPABASE_TABLE)
              .select('value')
              .eq('key', key)
              .maybeSingle();
            if (error || !data) return defaultValue;
            return (data.value ?? defaultValue);
          } else {
            const raw = localStorage.getItem(key);
            if (raw === null) return defaultValue;
            try { return JSON.parse(raw); } catch { return raw; }
          }
        } catch (e) {
          console.warn('readKV failed', e);
          return defaultValue;
        }
      };
    }
    if (!window.writeKV) {
      window.writeKV = async function writeKV(key, value) {
        try {
          if (window.supabase && window.SUPABASE_TABLE) {
            const { error } = await window.supabase
              .from(window.SUPABASE_TABLE)
              .upsert({ key, value }, { onConflict: 'key' });
            try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
            if (error) console.warn('writeKV error', error);
          } else {
            try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
          }
          return true;
        } catch (e) {
          console.warn('writeKV failed', e);
          try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
          return false;
        }
      };
    }
  })();
</script>
<script type="module">
// Minimal, no-login cloud persistence by mirroring localStorage to Supabase.
// 1) Create a table in Supabase named: kv_store
//    Columns:
//      key text PRIMARY KEY
//      value jsonb
//      updated_at timestamptz DEFAULT now()
// 2) Turn RLS ON and add permissive policies if you truly want no-login use:
//    - SELECT: USING (true)
//    - INSERT: WITH CHECK (true)
//    - UPDATE: USING (true)  WITH CHECK (true)   // optional; you can omit to prevent edits
//    - DELETE: USING (false)                      // optional; disallow deletes
// 3) Paste your Supabase project URL and anon key below.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2?bundle"

const SUPABASE_URL = window.SUPABASE_URL || "https://qzkzugzfpegozpiqutdv.supabase.co"
const SUPABASE_KEY = window.SUPABASE_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6a3p1Z3pmcGVnb3pwaXF1dGR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4MTc5MDMsImV4cCI6MjA3MTM5MzkwM30.mdFYuFjbRfsILWPkQQmVUCDR7dGqEo-mdPZ6iwolvGk"
const TABLE = "kv_store"
// List of localStorage keys that should be mirrored to Supabase.  If you add
// new keys anywhere in the application that you want to persist across
// devices, add them here as well.  Without inclusion in this list the
// `Storage.prototype.setItem` hook will ignore them and they will remain
// strictly deviceâ€‘local.
const KNOWN_KEYS = [
  "att_employees_v2",
  "att_schedules_v2",
  "att_schedules_default",
  "att_projects_v1",
  "att_filter_project_v1",
  "att_overrides_schedules",
  "att_overrides_projects",
  "att_splits_v1",
  // payroll configuration keys
  "payroll_rates",
  "payroll_reg_hours",
  "payroll_ot_hours",
  "payroll_ot_multiplier",
  "payroll_week_start",
  "payroll_week_end",
  "payroll_deduction_divisor",
  "payroll_sss_table",
  "payroll_loan_sss",
  "payroll_loan_pagibig",
  "payroll_vale",
  "payroll_vale_wed",
  "payroll_hist",
  // additional filter & state keys not previously persisted
  "dtr_filter_from",
  "dtr_filter_to",
  "payroll_active_index"
  ,"payroll_adjustments"
  ,"payroll_pagibig_rate"
  ,"payroll_philhealth_rate"
  ,"payroll_pagibig_table"
  ,"payroll_philhealth_table"
  ,"payroll_adjustment_hours"
  ,"payroll_bantay"
  ,"payroll_bantay_proj"
  ,"payroll_contrib_flags"
  ,"att_overrides_hours_v1"
  ,"payroll_lock_state"
]

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

// Expose the Supabase client on the global window so that other
// nonâ€‘module scripts (e.g. the boot guard) can access it without
// reâ€‘importing the library.  Also expose the table name used for
// key/value storage.  Without this, any attempt to read from
// Supabase outside of this module would require a duplicate client
// instantiation, and due to the asynchronous execution order of
// module scripts it is not guaranteed that the client would be
// available when the boot guard runs.  Assigning to `window`
// provides a simple, predictable global reference.
window.supabase = supabase;
window.SUPABASE_TABLE = TABLE;

function markHydrated() {
  try { window.__kv_hydrated = true; } catch {}
  try { window.dispatchEvent(new Event('kv-hydrated')); } catch {}
}

function queueHydrateRerender() {
  markHydrated();
  try { if (typeof refreshPeriodScopedCachesFromStorage === 'function') refreshPeriodScopedCachesFromStorage(); } catch {}
  const rerender = () => {
    try {
      if (typeof renderAdjustmentsTable === 'function') renderAdjustmentsTable();
      else if (typeof renderAdjustmentsFoot === 'function') renderAdjustmentsFoot();
    } catch {}
    try { if (typeof window.calculateAll === 'function') window.calculateAll(); } catch {}
    try { if (typeof window.renderResults === 'function') window.renderResults(); } catch {}
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { setTimeout(rerender, 0); }, { once: true });
  } else {
    setTimeout(rerender, 0);
  }
}

if (!window.__kvSubscribed) {
  try {
    const channel = supabase.channel('kv_store_sync');
    window.__kvSubscribed = true;
    window.__kvChannel = channel;

    channel.on('postgres_changes', { event: '*', schema: 'public', table: TABLE }, (payload) => {
        try {
          const eventType = payload && payload.eventType;
          const key = (payload && payload.new && payload.new.key) || (payload && payload.old && payload.old.key);
          if (!key || !KNOWN_KEYS.includes(key)) return;
          if (eventType === 'INSERT' || eventType === 'UPDATE') {
            const serialized = safeStringify(payload && payload.new ? payload.new.value : undefined);
            const nextValue = serialized == null ? 'null' : String(serialized);
            const current = localStorage.getItem(key);
            if (nextValue !== current) {
              try { __origSetItem.call(localStorage, key, nextValue); } catch {}
              queueHydrateRerender();
            }
          } else if (eventType === 'DELETE') {
            if (localStorage.getItem(key) !== null) {
              try { __origRemoveItem.call(localStorage, key); } catch {}
              queueHydrateRerender();
            }
          }
        } catch (err) {
          console.warn('Supabase realtime sync failed', err);
        }
      });

    const subscribeResult = channel.subscribe((status) => {
        if (status === 'CHANNEL_ERROR') {
          console.warn('Supabase channel subscribe failed');
        }
      });

    if (subscribeResult && typeof subscribeResult.catch === 'function') {
      subscribeResult.catch((err) => {
        console.warn('Supabase channel subscribe promise rejected', err);
      });
    }
    if (!window.__kvUnloadCleanup) {
      window.addEventListener('beforeunload', () => {
        try {
          if (window.__kvChannel) {
            if (typeof window.__kvChannel.unsubscribe === 'function') {
              window.__kvChannel.unsubscribe();
            } else if (window.supabase && typeof window.supabase.removeChannel === 'function') {
              window.supabase.removeChannel(window.__kvChannel);
            }
          }
        } catch {}
      }, { once: true });
      window.__kvUnloadCleanup = true;
    }
  } catch (err) {
    console.warn('Supabase realtime channel setup failed', err);
  }
}

const __origSetItem = Storage.prototype.setItem
const __origRemoveItem = Storage.prototype.removeItem

async function cloudUpsert(key, value) {
  try {
    // Try upsert
    const { error } = await supabase
      .from(TABLE)
      .upsert({ key, value: tryParse(value) }, { onConflict: "key" })
    if (error) console.warn("Supabase upsert error:", error.message)
  } catch (e) { console.warn("Supabase upsert failed", e) }
}
async function cloudDelete(key) {
  try {
    const { error } = await supabase.from(TABLE).delete().eq("key", key)
    if (error) console.warn("Supabase delete error:", error.message)
  } catch (e) { console.warn("Supabase delete failed", e) }
}
function tryParse(v) {
  try { return JSON.parse(v) } catch { return v }
}

// Write-through on any localStorage change
Storage.prototype.setItem = function(k, v) {
  try { __origSetItem.call(this, k, v) } catch {}
  // Only mirror known keys to reduce noise
  if (KNOWN_KEYS.includes(k)) cloudUpsert(k, v)
}
Storage.prototype.removeItem = function(k) {
  try { __origRemoveItem.call(this, k) } catch {}
  if (KNOWN_KEYS.includes(k)) cloudDelete(k)
}

// On first load, pull from cloud and hydrate localStorage automatically.
// If we detect changes vs. current localStorage, we populate and reload once
// so the rest of the app sees the new data without manual "sync".
;(async function initialHydrate(){
  try {
    const { data, error } = await supabase
      .from(TABLE)
      .select("key, value")
      .in("key", KNOWN_KEYS)
    if (error) { console.warn("Supabase fetch error:", error.message); return }
    let changed = false
    for (const row of (data || [])) {
      const k = row.key
      const cloudStr = safeStringify(row.value)
      const cur = localStorage.getItem(k)
      // Conflict resolution: if both sides look like period-scoped maps
      // and have __meta.lastUpdatedAt, prefer the newer side.
      let preferLocal = false
      try {
        const cloudObj = (row && typeof row.value === 'object') ? row.value : JSON.parse(cloudStr || 'null')
        const localObj = cur ? JSON.parse(cur) : null
        const lc = localObj && localObj.__meta && Number(localObj.__meta.lastUpdatedAt)
        const rc = cloudObj && cloudObj.__meta && Number(cloudObj.__meta.lastUpdatedAt)
        if (lc && rc && lc > rc) preferLocal = true
      } catch(_) {}
      if (preferLocal) {
        try { await supabase.from(TABLE).upsert({ key: k, value: JSON.parse(cur) }, { onConflict: 'key' }) } catch(_){ }
        continue
      }
      if (cloudStr != null && cloudStr !== cur) {
        try { __origSetItem.call(localStorage, k, cloudStr) } catch {}
        changed = true
      }
    }
    if (changed) {
      // Avoid reload: signal hydration complete and re-render once safely.
      try { sessionStorage.removeItem("__kv_reloaded"); } catch {}
      queueHydrateRerender();
    } else {
      markHydrated();
    }
  } catch (e) {
    console.warn("Initial hydrate failed", e);
    markHydrated();
  }
})()

function safeStringify(v){
  try { return typeof v === "string" ? v : JSON.stringify(v) } catch { return null }
}
</script>

<!-- Style to visually and functionally lock panels when payroll data is locked.
     When #panelMain has the 'locked' class, pointer events are disabled on
     all of its children and the panel appears dimmed. This prevents any
     interaction with DTR fields while still allowing navigation to other tabs. -->
<style>
  #panelMain.locked {
    pointer-events: none;
    opacity: 0.6;
  }

/* === PATCH: Adjustments & Bantay column widths === */
#payrollTable th:nth-child(10), #payrollTable td:nth-child(10) { width: 100px; min-width: 100px; } /* Adjustments */
#payrollTable th:nth-child(11), #payrollTable td:nth-child(11) { width: 100px; min-width: 100px; } /* Bantay */
/* === END PATCH === */

/* === PERF: faster layout for payroll table === */
#payrollTable { table-layout: fixed; }
#payrollTable th, #payrollTable td { white-space: nowrap; }

.toolbar { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin: 8px 0 12px; flex-wrap: wrap; }
.toolbar .toolbar-left { display: flex; gap: 8px; flex-wrap: wrap; }
.save-indicator { color: #555; font-size: 0.9em; }
.save-indicator.saved { color: #2d7a2d; font-weight: 600; }
.save-indicator.error { color: #a40000; font-weight: 600; }


/* === Reports: Stabilize last 4 totals columns to prevent twitch === */
#r_table, #projectTotalsTable { table-layout: fixed; }
#r_table th:nth-last-child(4), #r_table td:nth-last-child(4),
#projectTotalsTable th:nth-last-child(4), #projectTotalsTable td:nth-last-child(4) { width: 100px; min-width: 100px; max-width: 110px; }
#r_table th:nth-last-child(3), #r_table td:nth-last-child(3),
#projectTotalsTable th:nth-last-child(3), #projectTotalsTable td:nth-last-child(3) { width: 100px; min-width: 100px; max-width: 110px; }
#r_table th:nth-last-child(2), #r_table td:nth-last-child(2),
#projectTotalsTable th:nth-last-child(2), #projectTotalsTable td:nth-last-child(2) { width: 120px; min-width: 120px; max-width: 140px; }
#r_table th:nth-last-child(1), #r_table td:nth-last-child(1),
#projectTotalsTable th:nth-last-child(1), #projectTotalsTable td:nth-last-child(1) { width: 110px; min-width: 110px; max-width: 120px; }
/* Make first (personnel) column robust but constrained */
#r_table th:first-child, #r_table td:first-child,
#projectTotalsTable th:first-child, #projectTotalsTable td:first-child {
  text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  width: 170px; min-width: 170px; max-width: 170px;
}

/* Manual DTR indicator */
#resultsTable .manual-indicator { color: #ef4444; margin-left: 4px; font-weight: 700; }

</style>
<!-- === / Supabase KV Sync Adapter === -->

<!-- Multi payslip printing functionality -->

<script>
// Safe print helper to avoid uncaught errors like
// "Failed to execute 'print' on 'Window': The provided callback is no longer runnable."
function safePrint(win){
  try { (win || window).print(); } catch(e){ console.warn('print failed', e); }
}
</script>
<script>
(function(){
  function toNum(val){
    var num = parseFloat(String(val == null ? '' : val).replace(/,/g,''));
    return isNaN(num) ? 0 : num;
  }
  function fmt(val){
    return toNum(val).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }
  function currentDivisor(){
    var key = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
    var div = 0;
    if (typeof window !== 'undefined' && typeof window.divisor !== 'undefined'){
      var winDiv = Number(window.divisor);
      if (!isNaN(winDiv) && winDiv > 0) div = winDiv;
    }
    if (!(div > 0)){
      try {
        if (typeof localStorage !== 'undefined' && localStorage){
          var stored = localStorage.getItem(key);
          if (stored != null){
            var parsed = parseInt(stored, 10);
            if (!isNaN(parsed) && parsed > 0) div = parsed;
          }
        }
      } catch (e){}
    }
    if (!(div > 0)) div = 1;
    return div;
  }
  function loanSharePerPeriod(raw){
    var amount = toNum(raw);
    var div = currentDivisor();
    if (!(div > 0)) div = 1;
    var per = amount / div;
    if (!isFinite(per)) per = 0;
    return per.toFixed(2);
  }
  try {
    if (typeof window !== 'undefined'){
      window.getCurrentDeductionDivisor = currentDivisor;
      window.computeLoanPerPeriodShare = loanSharePerPeriod;
    }
  } catch(e){}
  function dash(val){
    var out = (val == null ? '' : val).toString();
    if (!out) return '';
    var num = parseFloat(out.replace(/,/g,''));
    if (!isNaN(num) && num === 0) return '-';
    return out;
  }
  function readCell(row, selector, mode){
    if (!row || !selector) return '';
    var el = row.querySelector(selector);
    if (!el) return '';
    if (mode === 'value'){ return (el.value != null ? String(el.value) : String(el.textContent || '')).trim(); }
    return (el.textContent != null ? String(el.textContent) : (el.value != null ? String(el.value) : '')).trim();
  }
  function collectRowData(row){
    if (!row) return null;
    var data = {
      id: (row.cells[0] && row.cells[0].textContent ? row.cells[0].textContent.trim() : ''),
      name: (row.cells[1] && row.cells[1].textContent ? row.cells[1].textContent.trim() : ''),
      rate: readCell(row, '.rate', 'value'),
      regHours: readCell(row, '.regHrs', 'value'),
      otHours: readCell(row, '.otHrs', 'value'),
      adjustmentHours: readCell(row, '.adjHrs'),
      totalHours: readCell(row, '.totalHrs'),
      regPay: readCell(row, '.regPay'),
      otPay: readCell(row, '.otPay'),
      gross: readCell(row, '.grossPay'),
      pagibig: readCell(row, '.pagibig'),
      philhealth: readCell(row, '.philhealth'),
      sss: readCell(row, '.sss'),
      sssLoan: readCell(row, '.loanSSS', 'value'),
      piLoan: readCell(row, '.loanPI', 'value'),
      vale: readCell(row, '.vale', 'value'),
      valeWed: readCell(row, '.valeWed', 'value') || readCell(row, '.valeWed'),
      bantay: readCell(row, '.bantay', 'value'),
      adjustments: readCell(row, '.adjAmt'),
      totalDeductions: readCell(row, '.totalDed'),
      net: readCell(row, '.netPay')
    };
    const datasetEffective = key => readRowDeductionDataset(row, key, 'effective');
    const applyDatasetValue = (prop, key) => {
      const value = datasetEffective(key);
      if (value != null) {
        data[prop] = value;
      }
    };
    applyDatasetValue('pagibig', 'pagibig');
    applyDatasetValue('philhealth', 'philhealth');
    applyDatasetValue('sss', 'sss');
    applyDatasetValue('totalDeductions', 'total');
    var sssLoanRaw = toNum(data.sssLoan);
    var piLoanRaw = toNum(data.piLoan);
    data.sssLoanRaw = sssLoanRaw;
    data.piLoanRaw = piLoanRaw;
    var datasetLoanSss = datasetEffective('loanSSS');
    var datasetLoanPi = datasetEffective('loanPI');
    data.sssLoan = datasetLoanSss != null ? datasetLoanSss : loanSharePerPeriod(sssLoanRaw);
    data.piLoan = datasetLoanPi != null ? datasetLoanPi : loanSharePerPeriod(piLoanRaw);
    var datasetVale = datasetEffective('vale');
    if (datasetVale != null) data.vale = datasetVale;
    var datasetValeWed = datasetEffective('valeWed');
    if (datasetValeWed != null) data.valeWed = datasetValeWed;
    var adjRawDataset = row && row.dataset ? toNum(row.dataset.adjustmentRaw) : 0;
    var adjPosDataset = row && row.dataset ? toNum(row.dataset.adjustmentPositive) : 0;
    var adjDedDataset = row && row.dataset ? toNum(row.dataset.adjustmentDeduction) : 0;
    var datasetAdjDeduction = datasetEffective('adjustments');
    if (datasetAdjDeduction != null) {
      adjDedDataset = toNum(datasetAdjDeduction);
    }
    if (!(adjPosDataset > 0) && !(adjDedDataset > 0)){
      var mapVal = 0;
      try {
        if (typeof adjustments !== 'undefined' && adjustments && data.id){
          mapVal = Number(adjustments[data.id] ?? 0) || 0;
        }
      } catch(e){ mapVal = 0; }
      var split = splitAdjustmentValue(mapVal);
      adjRawDataset = split.raw;
      adjPosDataset = split.positive;
      adjDedDataset = split.deduction;
    }
    data.adjustmentRaw = adjRawDataset;
    data.adjustmentPositive = adjPosDataset;
    data.adjustmentDeductions = adjDedDataset;
    if (!data.adjustments || toNum(data.adjustments) === 0){
      data.adjustments = adjPosDataset > 0 ? adjPosDataset.toFixed(2) : data.adjustments;
    }
    if (!data.totalHours){
      var r = toNum(data.regHours);
      var o = toNum(data.otHours);
      var a = toNum(data.adjustmentHours);
      var total = r + o + a;
      data.totalHours = total ? total.toFixed(2) : '';
    }
    return data;
  }
  function formatPeriod(ws, we){
    var start = (ws || '').trim();
    var end = (we || '').trim();
    if (start && end) return start + ' to ' + end;
    return start || end || '';
  }
  function buildPayslip(data, periodText){
    if (!data) return '';
    var period = (periodText || '').trim();
    var periodLine = period ? `<p class="meta"><strong>Period:</strong> ${period}</p>` : '';
    var dedRows = '';
    function addDed(label, value){
      if (toNum(value) > 0){ dedRows += `<tr><td>${label}</td><td>${fmt(value)}</td></tr>`; }
    }
    addDed('Pag-IBIG', data.pagibig);
    addDed('PhilHealth', data.philhealth);
    addDed('SSS', data.sss);
    addDed('SSS Loan', data.sssLoan);
    addDed('Pag-IBIG Loan', data.piLoan);
    addDed('Account', data.vale);
    addDed('Wed Vale', data.valeWed);
    addDed('Adjustments', data.adjustmentDeductions);
    var bantayRow = toNum(data.bantay) !== 0 ? `<tr><td>Bantay</td><td>${fmt(data.bantay)}</td></tr>` : '';
    var adjRow = toNum(data.adjustmentPositive) !== 0 ? `<tr><td>Adjustments</td><td>${fmt(data.adjustmentPositive)}</td></tr>` : '';
    var totalRow = toNum(data.totalDeductions) > 0 ? `<tr><td>Total Deductions</td><td>${fmt(data.totalDeductions)}</td></tr>` : '';
    var rateRaw = (data.rate != null ? String(data.rate).trim() : '');
    var rateDisplay = rateRaw ? fmt(data.rate) : '-';
    return `<div class="payslip">
      <h3>Payslip</h3>
      <p class="meta"><strong>Employee ID:</strong> ${data.id || ''}</p>
      <p class="meta"><strong>Name:</strong> ${data.name || ''}</p>
      ${periodLine}
      <table>
        <tr><th>Description</th><th>Amount</th></tr>
        <tr><td>Total Hours</td><td>${dash(data.totalHours)}</td></tr>
        <tr><td>Hourly Rate</td><td>${rateDisplay}</td></tr>
        ${bantayRow}
        ${adjRow}
        <tr><td>Gross Amount</td><td>${dash(data.gross)}</td></tr>
        ${dedRows}
        ${totalRow}
        <tr><th>Net Pay</th><th>${dash(data.net)}</th></tr>
      </table>
    </div>`;
  }
  var styles = `@page { size: letter portrait; margin: 0.25in; }
html, body { width: 8.5in; height: 11in; margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:0 0.1in;}
.payslip-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:0.03in;}
.payslip-grid.single{grid-template-columns:repeat(1,1fr);max-width:3in;margin:0 auto;}
.payslip{box-sizing:border-box;padding:0.06in;border:1px solid #475569;height:2.6in;overflow:hidden;border-radius:3px;background:#fff;box-shadow:0 0 0 1px rgba(15,23,42,0.2);}
table{border-collapse:collapse;width:100%;font-size:8.5px;}
th,td{border:1px solid #e2e8f0;padding:1px;text-align:left;}
th{background:#f1f5f9;}
.page-break{page-break-after:always;break-after:page;}
h3{margin:0 0 3px 0;font-size:10px;}
.payslip .meta{margin:0 0 2px 0;font-size:8px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}`;

  window.collectPayslipRowData = collectRowData;
  window.buildCompactPayslip = buildPayslip;
  window.formatPayslipPeriod = formatPeriod;
  window.PAYSLIP_PRINT_STYLES = styles;
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  var multiBtn = document.getElementById('printAllPayslipsBtn');
  if (!multiBtn) return;
  multiBtn.addEventListener('click', function() {
    var rows = document.querySelectorAll('#payrollTable tbody tr');
    if (!rows || rows.length === 0) return;
    var wsEl = document.getElementById('weekStart');
    var weEl = document.getElementById('weekEnd');
    var ws = wsEl ? (wsEl.value || '') : '';
    var we = weEl ? (weEl.value || '') : '';
    var styles = window.PAYSLIP_PRINT_STYLES || '';
    if (!styles){
      styles = `@page { size: letter portrait; margin: 0.25in; }
html, body { width: 8.5in; height: 11in; margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:0 0.1in;}
.payslip-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:0.03in;}
.payslip-grid.single{grid-template-columns:repeat(1,1fr);max-width:3in;margin:0 auto;}
.payslip{box-sizing:border-box;padding:0.06in;border:1px solid #475569;height:2.6in;overflow:hidden;border-radius:3px;background:#fff;box-shadow:0 0 0 1px rgba(15,23,42,0.2);}
table{border-collapse:collapse;width:100%;font-size:8.5px;}
th,td{border:1px solid #e2e8f0;padding:1px;text-align:left;}
th{background:#f1f5f9;}
.page-break{page-break-after:always;break-after:page;}
h3{margin:0 0 3px 0;font-size:10px;}
.payslip .meta{margin:0 0 2px 0;font-size:8px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}`;
    }
    var html = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>All Payslips</title>
<style>${styles}</style></head><body><div class="payslip-grid">`;
    rows.forEach(function(row, idx){
      var data = (typeof window.collectPayslipRowData === 'function') ? window.collectPayslipRowData(row) : null;
      if (!data) return;
      var periodText = (typeof window.formatPayslipPeriod === 'function') ? window.formatPayslipPeriod(ws, we) : ((ws && we) ? (ws + ' to ' + we) : (ws || we || ''));
      var slip = (typeof window.buildCompactPayslip === 'function') ? window.buildCompactPayslip(data, periodText) : '';
      if (!slip) return;
      html += slip;
      if ((idx + 1) % 12 === 0 && idx !== rows.length - 1) {
        html += `</div><div class="page-break"></div><div class="payslip-grid">`;
      }
    });
    html += `</div></body></html>`;
    var w = window.open('', '', 'width=800,height=900');
    if (!w) return;
    w.document.open(); w.document.write(html); w.document.close();
    w.focus(); setTimeout(function(){ try { safePrint(w); } catch(e){} }, 0);
  });
});
</script>


<script>
// === PATCH v15: Strong zero formatting in Reports/Payroll tab ===
(function(){
  function zeroToDashInTable(){
    try{
      const tbl = document.getElementById('payrollTable');
      if(!tbl || !tbl.tBodies || !tbl.tBodies[0]) return;
      const tbody = tbl.tBodies[0];
      // Inputs: blank zeros only for the three computed fields
      tbody.querySelectorAll('input.regHrs, input.otHrs, input.rate').forEach(inp=>{
        const v = parseFloat((inp.value||'').toString().replace(/,/g,''));
        if(!isNaN(v) && v===0){ inp.value = ''; }
      });
      // Text cells: convert 0/0.00 to '-' (only numeric cells)
      Array.from(tbody.querySelectorAll('td.num')).forEach(td=>{
        if(td.querySelector('input')) return; // inputs handled above
        const raw = (td.textContent||'').replace(/,/g,'').trim();
        if(raw==='') return;
        const n = parseFloat(raw);
        if(!isNaN(n) && isFinite(n) && n===0){
          td.textContent = '-';
        }
      });
      // Footer totals too
      if(tbl.tFoot){
        Array.from(tbl.tFoot.querySelectorAll('td')).forEach(td=>{
          const raw = (td.textContent||'').replace(/,/g,'').trim();
          if(!raw) return;
          const n = parseFloat(raw);
          if(!isNaN(n) && n===0){ td.textContent = '-'; }
        });
      }
    }catch(e){ /* no-op */ }
  }

  // Debounced wrapper
  let __zTimer=null;
  function applyZeroSoon(){
    clearTimeout(__zTimer);
    __zTimer = setTimeout(zeroToDashInTable, 0);
  }

  // Hook common renderers (if defined later too)
  ['calculateAll','renderTable','renderDeductionsTable','renderReportTable'].forEach(fn=>{
    const hook = ()=>{
      const orig = window[fn];
      if(typeof orig==='function' && !orig.__zeroWrapped){
        window[fn] = function(){
          const out = orig.apply(this, arguments);
          applyZeroSoon();
          return out;
        };
        window[fn].__zeroWrapped = true;
      }
    };
    hook();
    document.addEventListener('readystatechange', hook);
    window.addEventListener('load', hook);
    setTimeout(hook, 0);
  });

  // Observe tbody for DOM changes
  const startObserver = ()=>{
    const tbl = document.getElementById('payrollTable');
    if(tbl && tbl.tBodies && tbl.tBodies[0]){
      // observer removed for perf
applyZeroSoon();
    }
  };
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', startObserver);
  }else{
    startObserver();
  }

  // Periodic fallback (lightweight) in case rendering bypasses hooks
})();
// === END PATCH v15 ===
</script>


<script>
(function(){
  function zeroBlankInputs(){
    try{
    document.querySelectorAll('#payrollTable input.regHrs, #payrollTable input.otHrs, #payrollTable input.rate').forEach(function(inp){
        var v = parseFloat((inp.value||'').toString().replace(/,/g,''));
        if(!isNaN(v) && v===0){ inp.value = ''; }
      });
    }catch(e){}
  }
  function hideThenFormat(run){
    var tbl = document.getElementById('payrollTable');
    var prevVis = tbl ? tbl.style.visibility : null;
    if (tbl) tbl.style.visibility = 'hidden';
    var out;
    try { out = run(); } catch(e){ out = undefined; }
    try { zeroBlankInputs(); } catch(e){}
    if (tbl) tbl.style.visibility = (prevVis==null? '' : prevVis);
    return out;
  }
  ['renderTable','calculateAll'].forEach(function(fn){
    var orig = window[fn];
    if (typeof orig === 'function' && !orig.__noflash){
      window[fn] = function(){ return hideThenFormat(function(){ return orig.apply(this, arguments); }); };
      window[fn].__noflash = true;
    }
  });
})();
</script>


<script>
(function(){
  function dashReports(){ try { if (typeof applyCommas === 'function') applyCommas(); } catch(e){} }
  const panel = document.getElementById('panelReports') || document.body;
  // observer removed for perf
window.addEventListener('load', dashReports);
})();
</script>



  <meta charset="utf-8"/>
  <title>
   Attendance &mdash; Schedules + Ranges (Merged) + Projects
  </title>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <style>
  /*
   * Allow the application to consume the full viewport width so wide tables (like
   * the DTR grid) are not artificially constrained. The original max-width of
   * 1200px caused wide tables to be clipped on larger screens and hid
   * additional columns. Removing the fixed max-width lets the container grow
   * with the window size, and combined with overflow handling on the panel
   * ensures that all columns remain accessible via horizontal scrolling when
   * necessary.
   */
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;max-width:100%;color:#0b1220}
  header{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab-btn{padding:8px 12px;cursor:pointer;border:1px solid #cbd5e1;background:#f8fafc;border-radius:6px}
  .tab-btn.active{background:#0ea5a4;color:#fff}
  section.panel{display:none}
  section.panel.active{display:block;padding-top:8px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  input[type=file],input[type=date],input[type=time],input[type=number],button,select{padding:6px 8px}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border:1px solid #e2e8f0;padding:8px;text-align:center;font-size:13px}
  th{background:#f1f5f9;position:sticky;top:0;z-index:1}
  .missing{background:#ffdede;color:#7a0000;font-weight:700}
  .note{color:#64748b;font-size:13px;margin-top:6px}
  input.cell{width:100%;box-sizing:border-box}
  .small{font-size:12px;color:#64748b}
  .muted{color:#64748b;font-size:12px}
  @media (max-width:800px){th,td{font-size:12px}}
  .section-title{margin-top:12px;margin-bottom:4px;font-weight:700}
  /* Ensure DTR table columns stay visible and don't collapse in Chrome. Allow
     horizontal scrolling if needed by preventing cells from shrinking and
     wrapping. */
  #panelMain {
    overflow-x: auto;
  }
  #panelMain #resultsTable {
    /*
     * Use max-content so the table grows to accommodate all of its columns.
     * This prevents Chrome from collapsing column widths to fit a parent with
     * limited width and ensures that long headers (e.g. "Clock Out 4",
     * "Night Differential") do not disappear. When combined with the
     * overflow-x:auto on #panelMain, a horizontal scrollbar will appear
     * whenever the total table width exceeds the viewport, allowing users to
     * scroll horizontally to view hidden columns.
     */
    table-layout: auto;
    width: max-content;
  }
  #panelMain #resultsTable th,
  #panelMain #resultsTable td {
    white-space: nowrap;
  }

  /* Make the wrapper around the DTR results scrollable on the x-axis. Without
     this wrapper, wide tables can be clipped by parent containers with
     overflow hidden. */
  .results-wrapper {
    overflow-x: auto;
  }
  </style>
  <style>

  /* Hide individual deduction columns in Payroll table (show only Total Deductions).
     After adding the Adjustment column before Bantay, the indices shift by one.
     Hide Pag‑IBIG to Wed Vale columns (cols 13–19) for thead and tbody.
     The tfoot row has a collapsed first cell; hide cols 12–18 instead. */
  #payrollTab #payrollTable thead th:nth-child(13),
  #payrollTab #payrollTable tbody td:nth-child(13),
  #payrollTab #payrollTable thead th:nth-child(14),
  #payrollTab #payrollTable tbody td:nth-child(14),
  #payrollTab #payrollTable thead th:nth-child(15),
  #payrollTab #payrollTable tbody td:nth-child(15),
  #payrollTab #payrollTable thead th:nth-child(16),
  #payrollTab #payrollTable tbody td:nth-child(16),
  #payrollTab #payrollTable thead th:nth-child(17),
  #payrollTab #payrollTable tbody td:nth-child(17),
  #payrollTab #payrollTable thead th:nth-child(18),
  #payrollTab #payrollTable tbody td:nth-child(18),
  #payrollTab #payrollTable thead th:nth-child(19),
  #payrollTab #payrollTable tbody td:nth-child(19) { display: none; }
  #payrollTab #payrollTable tfoot td:nth-child(12),
  #payrollTab #payrollTable tfoot td:nth-child(13),
  #payrollTab #payrollTable tfoot td:nth-child(14),
  #payrollTab #payrollTable tfoot td:nth-child(15),
  #payrollTab #payrollTable tfoot td:nth-child(16),
  #payrollTab #payrollTable tfoot td:nth-child(17),
  #payrollTab #payrollTable tfoot td:nth-child(18) { display: none; }
/* === PATCH: column widths for Hourly Rate, Regular Hours, OT Hours === */
#payrollTable th, #payrollTable td { white-space: nowrap; }
#payrollTable th:nth-child(3), #payrollTable td:nth-child(3) { width: 110px; min-width: 110px; } /* Hourly Rate */
#payrollTable th:nth-child(4), #payrollTable td:nth-child(4) { width: 120px; min-width: 120px; } /* Regular Hours */
#payrollTable th:nth-child(5), #payrollTable td:nth-child(5) { width: 120px; min-width: 120px; } /* OT Hours */
/* keep inputs filling their cells cleanly */
#payrollTable td input.cell { width: 100%; box-sizing: border-box; }
/* === END PATCH === */


  
/* ===== Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  #panelProjectTotals, #panelProjectTotals * { visibility: visible !important; }
  #panelProjectTotals { position: absolute; left: 0; top: 0; width: 100%; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}
</style>

  <style id="payrollScopedStyles">
  #panelPayroll {
    --border:#e2e8f0; --bg:#f8fafc; --bg2:#f1f5f9; --text:#0b1220;
    /* Updated accent color to gold */
    --accent:#FFD700; --muted:#64748b;
  }
  #panelPayroll *, #panelPayroll *::before, #panelPayroll *::after { box-sizing:border-box }
  #panelPayroll { color:var(--text) }
  #panelPayroll header { display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;flex-wrap:wrap }
  #panelPayroll h2 { margin:0 }
  #panelPayroll .tabs { display:flex;gap:6px;flex-wrap:wrap }
  #panelPayroll .tab-btn { padding:8px 12px;border:1px solid var(--border);background:white;border-radius:8px;cursor:pointer }
  #panelPayroll .tab-btn.active { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll .tab { display:none }
  #panelPayroll .tab.active { display:block }
  #panelPayroll .controls { display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:10px 0 }
  #panelPayroll label { font-size:12px;color:var(--muted) }
  #panelPayroll input[type=date], 
  #panelPayroll input[type=number], 
  #panelPayroll input[type=text], 
  #panelPayroll select, 
  #panelPayroll button { padding:6px 8px;border:1px solid var(--border);border-radius:6px }
  #panelPayroll button.primary { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll table { border-collapse:collapse;width:100%;margin-top:12px }
  #panelPayroll th, #panelPayroll td { border:1px solid var(--border);padding:8px;text-align:center;font-size:13px }
  #panelPayroll th { background:var(--bg2);position:sticky;top:0;z-index:1 }
  #panelPayroll td.num { text-align:right }
  #panelPayroll input.cell { width:100%;padding:4px;border:1px solid var(--border);border-radius:4px;text-align:right }
/* === PATCH: make computed hours/rate look like plain text & non-interactive === */
#panelPayroll input.regHrs,
#panelPayroll input.otHrs,
#panelPayroll input.rate {
  pointer-events: none;      /* no clicks */
  border: none;              /* look like text */
  background: transparent;
  color: inherit;
  padding: 0;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: textfield;
  appearance: none;
  text-align: right;
}
#panelPayroll input.regHrs[disabled],
#panelPayroll input.otHrs[disabled],
#panelPayroll input.rate[disabled] {
  color: inherit;            /* avoid greyed-out disabled look */
}
/* hide number spinners where applicable */
#panelPayroll input.regHrs::-webkit-outer-spin-button,
#panelPayroll input.regHrs::-webkit-inner-spin-button,
#panelPayroll input.otHrs::-webkit-outer-spin-button,
#panelPayroll input.otHrs::-webkit-inner-spin-button,
#panelPayroll input.rate::-webkit-outer-spin-button,
#panelPayroll input.rate::-webkit-inner-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}
/* === END PATCH === */

  #panelPayroll .note { font-size:12px;color:var(--muted) }
  #panelPayroll .section { background:var(--bg);padding:10px;border:1px solid var(--border);border-radius:10px;margin-top:8px }
  #panelPayroll .danger { color:#b91c1c }
  #panelPayroll .wrap { white-space:normal }

  </style>
  <style id="payroll-tabs-fix">
   #panelPayroll .tab{display:none} #panelPayroll .tab.active{display:block}
  </style>
 
<style>
/* --- Employees: Clean Add Employee UI --- */
#panelEmployees .form-card{
  background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,0.04);margin-bottom:12px;
}
#panelEmployees form{
  display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;align-items:start;
}
#panelEmployees label{display:block;font-size:12px;color:#334155;margin-bottom:6px;font-weight:600;}
#panelEmployees input, #panelEmployees select, #panelEmployees textarea{
  width:100%;padding:10px 12px;border:1px solid #cbd5e1;border-radius:10px;outline:none;
}
#panelEmployees input:focus, #panelEmployees select:focus, #panelEmployees textarea:focus{
  border-color:#64748b;box-shadow:0 0 0 3px rgba(100,116,139,0.15);
}
#panelEmployees input:invalid, #panelEmployees select:invalid, #panelEmployees textarea:invalid{
  border-color:#ef4444;
}
#panelEmployees .form-actions{grid-column:1 / -1;display:flex;gap:10px;justify-content:flex-end;margin-top:2px;}
#panelEmployees button, #panelEmployees input[type="submit"], #panelEmployees input[type="button"]{
  border:1px solid #cbd5e1;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer;background:#f8fafc;
}
#panelEmployees button:hover, #panelEmployees input[type="submit"]:hover, #panelEmployees input[type="button"]:hover{
  filter:brightness(0.98);
}
#panelEmployees .btn-primary{background:#0ea5e9;border-color:#0284c7;color:#fff;}
#panelEmployees .btn-danger{background:#fee2e2;border-color:#fecaca;color:#b91c1c;}
#panelEmployees small.hint{display:block;color:#64748b;margin-top:4px;font-size:11px;}
@media (max-width:1100px){
  #panelEmployees form{grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
}
</style>

<style>

/* ===== Strong Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  section.panel { display: none !important; }
  #panelProjectTotals { 
    position: absolute; left: 0; top: 0; width: 100%;
    display: block !important; 
    visibility: visible !important;
  }
  #panelProjectTotals * { visibility: visible !important; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}

</style>

<style>

/* --- Per-project per page when printing --- */
@media print {
  /* If a project has a breakdown row, break after that row; otherwise break after the project header row */
  #panelProjectTotals tr.proj-emp-breakdown { page-break-after: always; }
  #panelProjectTotals tr.proj-row.no-breakdown { page-break-after: always; }
}

</style>

<style>
#payrollTab #payrollTable tfoot td,
#deductionsTab #deductionsTable tfoot td{ font-weight:700; background:#fff7ed; border-top:2px solid #e2e8f0; }
#payrollTab #payrollTable tfoot td.label-cell,
#deductionsTab #deductionsTable tfoot td.label-cell{ text-align:left; }
#payrollTab #payrollTable tfoot td.num,
#deductionsTab #deductionsTable tfoot td.num{ text-align:right; }
#deductionsTab .column-toggle-controls{ display:flex; flex-wrap:wrap; gap:0.35rem 1rem; align-items:center; margin:0.5rem 0 0; font-size:0.95rem; }
#deductionsTab .column-toggle-controls span{ font-weight:600; margin-right:0.5rem; }
#deductionsTab .column-toggle-controls label{ display:flex; align-items:center; gap:0.35rem; }
#deductionsTab [data-col].deduction-excluded{ opacity:0.45; position:relative; }
#deductionsTab [data-col].deduction-excluded::after{ content:'Excluded'; font-size:0.65rem; font-weight:600; letter-spacing:0.03em; text-transform:uppercase; color:#c2410c; position:absolute; inset:auto 0.25rem 0.15rem auto; background:rgba(255,247,237,0.9); padding:0.1rem 0.3rem; border-radius:0.35rem; }
#deductionsTab #deductionsTable td.editable-deduction{ padding:4px 8px; }
#deductionsTab #deductionsTable td.editable-deduction input.deduction-input{
  width:100%;
  box-sizing:border-box;
  text-align:right;
  padding:6px 8px;
  border:1px solid #cbd5e1;
  border-radius:6px;
  background:#ffffff;
  color:#0f172a;
  font-size:13px;
}
#deductionsTab #deductionsTable td.editable-deduction input.deduction-input.deduction-excluded{
  opacity:0.6;
}
#payrollTable .deduction-excluded{ opacity:0.55; position:relative; }
#payrollTable .deduction-excluded::after{ content:'Excluded'; font-size:0.6rem; font-weight:600; letter-spacing:0.02em; text-transform:uppercase; color:#9a3412; position:absolute; inset:auto 0.2rem 0.1rem auto; background:rgba(254,242,242,0.9); padding:0.1rem 0.25rem; border-radius:0.3rem; }
</style>
    <!-- Added payroll dashboard theme -->
    <style>
        /* Override default margins and background */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        /* Contribution tab helpers */
        .contrib-hero {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.14));
            border: 1px solid rgba(99, 102, 241, 0.15);
            border-radius: 16px;
            padding: 18px 20px;
            margin-bottom: 18px;
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 16px;
            align-items: start;
        }
        .contrib-hero h3 {
            margin: 0 0 6px;
            font-size: 20px;
            color: #312e81;
        }
        .contrib-hero p {
            margin: 0 0 8px;
            color: #1f2937;
        }
        .contrib-key-list {
            margin: 0;
            padding-left: 18px;
            color: #374151;
            display: grid;
            gap: 4px;
        }
        .contrib-pill-stack {
            display: grid;
            gap: 8px;
        }
        .contrib-pill {
            border-radius: 12px;
            padding: 10px 12px;
            background: #fff;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04);
        }
        .contrib-pill strong { color: #4338ca; display: block; margin-bottom: 4px; }
        .contrib-pill small { color: #4b5563; line-height: 1.4; display: block; }
        .table-card {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 14px;
            padding: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            margin-bottom: 16px;
        }
        .table-card .controls button {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #f8fafc;
            color: var(--text);
            font-weight: 600;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
        }
        .table-card .controls button.primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            box-shadow: 0 6px 16px rgba(255, 215, 0, 0.18);
        }
        .table-card .controls button.danger {
            background: #fee2e2;
            color: #b91c1c;
            border-color: #fecdd3;
        }
        .table-card .controls button:focus-visible {
            outline: 2px solid rgba(255, 215, 0, 0.35);
            outline-offset: 2px;
        }
        .table-card__header {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        .table-card__title {
            margin: 0;
            color: #111827;
            font-size: 18px;
        }
        .table-card__subtitle { margin: 4px 0 0; color: #4b5563; font-size: 13px; line-height: 1.5; }
        .table-card__tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .table-card__tag {
            background: #eef2ff;
            color: #4338ca;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .table-card .controls { margin-top: 6px; flex-wrap: wrap; }
        .table-card .controls label { margin-top: 6px; }
        .table-card table { margin-top: 6px; }
        .contrib-note { margin-top: 10px; color: #374151; }
        .contrib-note strong { color: #111827; }
        @media (max-width: 960px) {
            .contrib-hero { grid-template-columns: 1fr; }
            .table-card__header { flex-direction: column; }
        }
        .app-container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            padding: 30px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }
        .sidebar-header {
            padding: 0 30px 30px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        .logo {
            font-size: 24px;
            font-weight: 800;
            /* Updated logo color to yellow */
            color: #FFD700;
            background: none;
            -webkit-background-clip: border-box;
            background-clip: border-box;
            background-clip: border-box;
            background-clip: border-box;
            -webkit-text-fill-color: #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .nav-menu {
            list-style: none;
            padding: 0 15px;
        }
        .nav-item {
            margin-bottom: 8px;
        }
        .nav-link {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            text-decoration: none;
            color: #6b7280;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        .nav-link:hover {
            background: #f3f4f6;
            color: #374151;
            transform: translateX(5px);
        }
        .nav-link.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 30px;
            /*
             * Permit horizontal scrolling within the main content area. The
             * original style hid any overflow on the x-axis, which meant
             * wide tables (such as the DTR results grid) could not be
             * scrolled into view and appeared to be missing columns. By
             * changing overflow-x to auto, the browser will show a
             * horizontal scrollbar when necessary, ensuring all columns
             * remain accessible.
             */
            overflow-x: auto;
        }
        .content-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .page-title {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .page-subtitle {
            color: #6b7280;
            font-size: 14px;
        }
        .date-range {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .date-input {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
        .date-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .warning-note {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #92400e;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 13px;
            margin-top: 15px;
            border-left: 4px solid #f59e0b;
        }
        .mobile-menu-btn {
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.35);
            background: rgba(255, 255, 255, 0.08);
            color: #ffffff;
            border-radius: 12px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-left: auto;
        }
        .mobile-menu-btn:focus-visible {
            outline: 2px solid #ffd700;
            outline-offset: 2px;
        }
        .mobile-menu-btn:hover {
            background: rgba(255, 255, 255, 0.18);
            border-color: rgba(255, 255, 255, 0.55);
        }
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: inline-flex;
            }
            .main-content {
                margin-left: 0;
                padding: 88px 16px 20px;
            }
            .date-range {
                justify-content: center;
            }
        }
        /* Hide original top-level navigation tabs but keep payroll sub-tabs visible */
        .tabs { display: none !important; }
        /* Explicitly show the sub-tabs inside the Payroll panel. */
    #panelPayroll .tabs {
            display: flex !important;
        }
    </style>
    <!-- Additional styles for new header UI -->
    <style>
      body {
        background: #f8f8f8;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: linear-gradient(135deg, #000 0%, #333 100%);
        color: white;
        padding: 10px 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
      }
      .header .logo {
        font-size: 24px;
        font-weight: 800;
        color: #FFD700;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .header .nav-menu {
        list-style: none;
        display: flex;
        gap: 20px;
        margin: 0;
        padding: 0;
        align-items: center;
      }
      .header .nav-menu .nav-item .nav-link {
        border: none;
        background: none;
        color: white;
        font-weight: 600;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .header .nav-menu .nav-item .nav-link:hover {
        background-color: #FFD700;
        color: #000;
      }
      .header .nav-menu .nav-item .nav-link.active {
        background-color: #FFD700;
        color: #000;
      }
      .sidebar {
        display: none !important;
      }
      .main-content {
        margin-left: 0 !important;
        padding-top: 90px;
      }
      .header .header-content {
        align-items: center;
      }
      .header nav {
        display: flex;
        align-items: center;
      }
      .header nav .nav-menu {
        display: flex;
        align-items: center;
      }
      @media (max-width: 768px) {
        .header {
          padding: 14px 16px;
        }
        .header .header-content {
          width: 100%;
          gap: 12px;
        }
        .header nav {
          width: 100%;
        }
        .header nav .nav-menu {
          display: none;
          flex-direction: column;
          align-items: stretch;
          width: 100%;
          background: rgba(0, 0, 0, 0.92);
          border-radius: 16px;
          padding: 12px 0;
          gap: 4px;
          margin: 4px 0 0;
          box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }
        .header nav.open .nav-menu {
          display: flex;
        }
        .header nav .nav-item {
          width: 100%;
        }
        .header nav .nav-link {
          width: 100%;
          justify-content: flex-start;
          font-size: 15px;
        }
        .header nav .nav-link.active,
        .header nav .nav-link:hover {
          transform: none;
        }
      }
</style>
</head>

<!-- UI fixes: restore emojis and icons if text got corrupted by encoding -->
<style>
  /* Replace corrupted nav icon text with emojis */
  .header .nav-icon { font-size: 0; line-height: 1; }
  #tabDashboard .nav-icon::before { content: "📊"; font-size: 14px; }
  #tabMain .nav-icon::before      { content: "🕒"; font-size: 14px; }
  #tabSchedule .nav-icon::before  { content: "🗓️"; font-size: 14px; }
  #tabEmployees .nav-icon::before { content: "👥"; font-size: 14px; }
  #tabProjects .nav-icon::before  { content: "🚀"; font-size: 14px; }
  #tabPayroll .nav-icon::before   { content: "💰"; font-size: 14px; }
  #tabProjectTotals .nav-icon::before { content: "📈"; font-size: 14px; }
  #tabContributionSummary .nav-icon::before { content: "💳"; font-size: 14px; }
  /* Sidebar duplicates */
  #old-tabDashboard .nav-icon::before { content: "📊"; }
  #old-tabMain .nav-icon::before      { content: "🕒"; }
  #old-tabSchedule .nav-icon::before  { content: "🗓️"; }
  #old-tabEmployees .nav-icon::before { content: "👥"; }
  #old-tabProjects .nav-icon::before  { content: "🚀"; }
  #old-tabPayroll .nav-icon::before   { content: "💰"; }
  #old-tabProjectTotals .nav-icon::before { content: "📈"; }
  #old-tabContributionSummary .nav-icon::before { content: "💳"; }

  /* Mobile menu icon */
  .mobile-menu-btn span { font-size: 0; }
  .mobile-menu-btn span::before { content: "☰"; font-size: 20px; }
  .mobile-menu-btn[aria-expanded="true"] span::before { content: "✕"; }

  /* Sidebar logo: render clean text */
  .sidebar .logo { font-size: 0; }
  .sidebar .logo::before { content: "💰 PayrollHub"; font-size: 24px; }

  /* Page title icon */
  .page-title > span:first-child { font-size: 0; } .page-title > span:first-child::before { content: "📊"; font-size: 32px; } .page-title > span.icon-emoji { font-size: 32px !important; } .page-title > span.icon-emoji::before { content: none !important; }

</style>

<!-- Boot guard to ensure global stored data is available early -->
<script>
/*
  Immediately initialize global data stores used throughout the app.
  In addition to reading from localStorage, this version attempts to
  fetch persisted values from Supabase.  Because the Supabase
  client is exposed on `window.supabase` by the kv sync adapter,
  we can asynchronously query the kv_store table for each known
  key.  If a value exists in Supabase, it takes precedence over
  localStorage; otherwise, the localStorage fallback is used.  This
  ensures that data entered on one device is available on other
  devices without relying on cached local storage.
*/
(function(){
  // Helper to fetch a single key from Supabase.  Returns a Promise
  // that resolves to the parsed JSON value or undefined on error.
  function fetchFromSupabase(key){
    return new Promise((resolve) => {
      try {
        const client = window.supabase;
        const table = window.SUPABASE_TABLE;
        if (!client || !table) return resolve(undefined);
        client
          .from(table)
          .select('value')
          .eq('key', key)
          .maybeSingle()
          .then(({ data, error }) => {
            if (error || !data) return resolve(undefined);
            const v = data.value;
            if (v == null) return resolve(undefined);
            // If the stored value is a string, assume it is JSON and parse
            if (typeof v === 'string') {
              try { return resolve(JSON.parse(v)); } catch { return resolve(undefined); }
            }
            // Otherwise return the JSON value directly
            return resolve(v);
          })
          .catch(() => resolve(undefined));
      } catch (ex) {
        resolve(undefined);
      }
    });
  }
  (async function(){
    try {
      // Employees store (att_employees_v2)
      if (typeof window.storedEmployees === 'undefined') {
        const supaVal = await fetchFromSupabase('att_employees_v2');
        if (supaVal !== undefined) {
          window.storedEmployees = supaVal;
        } else {
          // fallback to localStorage
          window.storedEmployees = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
        }
      }
      // Attendance records store (att_records_v2)
      if (typeof window.storedRecords === 'undefined') {
        /*
         * Always initialize the attendance record array as empty.  Unlike other
         * data stores, DTR records are persisted in a dedicated Supabase table
         * (`dtr_records`) and should not be bootstrapped from localStorage.  By
         * starting with an empty array here, the application ensures that any
         * locally cached data is ignored until the remote dataset is loaded.
         */
        window.storedRecords = window.storedRecords || []; }
      // Projects store (att_projects_v1)
      if (typeof window.storedProjects === 'undefined') {
        const supaVal = await fetchFromSupabase('att_projects_v1');
        if (supaVal !== undefined) {
          window.storedProjects = supaVal;
        } else {
          window.storedProjects = JSON.parse(localStorage.getItem('att_projects_v1') || '{}');
        }
      }
      // Schedules store (att_schedules_v2) â€“ ensures schedules are available early
      if (typeof window.storedSchedules === 'undefined') {
        const supaVal = await fetchFromSupabase('att_schedules_v2');
        if (supaVal !== undefined) {
          window.storedSchedules = supaVal;
        } else {
          window.storedSchedules = JSON.parse(localStorage.getItem('att_schedules_v2') || '{}');
        }
      }
    } catch (e) {
      console.warn('Boot guard init failed', e);
    }
  })();
})();
</script>

  <!-- Begin App Container with Sidebar and Main Content -->
  <div class="app-container">
      <!-- Added top navigation header to adapt payroll UI -->
      <header class="header">
        <div class="header-content">
          <div class="logo">PayrollPro</div>
          <button class="mobile-menu-btn" type="button" aria-expanded="false" aria-controls="primaryNav" aria-label="Toggle navigation" onclick="toggleMobileMenu(this)">
            <span aria-hidden="true"></span>
          </button>
          <nav id="primaryNav">
            <ul class="nav-menu">
              <li class="nav-item"><button class="nav-link tab-btn active" id="tabDashboard" data-page="dashboard"><span class="nav-icon">ðŸ“Š</span> Dashboard</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabMain" data-page="dtr"><span class="nav-icon">ðŸ•</span> DTR</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabSchedule" data-page="schedules"><span class="nav-icon">ðŸ“…</span> Schedules</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabEmployees" data-page="employees"><span class="nav-icon">ðŸ‘¥</span> Employees</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabProjects" data-page="projects"><span class="nav-icon">ðŸš€</span> Projects</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabPayroll" data-page="payroll"><span class="nav-icon">ðŸ’°</span> Payroll</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabProjectTotals" data-page="totals"><span class="nav-icon">ðŸ“ˆ</span> Reports</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabContributionSummary" data-page="contribSummary"><span class="nav-icon">ðŸ’³</span> Contributions</button></li>
            </ul>
          </nav>
        </div>
      </header>
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">
          ðŸ’¼ PayrollHub
        </div>
      </div>
      <nav>
        <ul class="nav-menu">
          <li class="nav-item">
            <button class="nav-link tab-btn active" id="old-tabDashboard" data-page="dashboard">
              <span class="nav-icon">ðŸ“Š</span>
              Dashboard
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabMain" data-page="dtr">
              <span class="nav-icon">ðŸ•</span>
              DTR
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabSchedule" data-page="schedules">
              <span class="nav-icon">ðŸ“…</span>
              Schedules
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabEmployees" data-page="employees">
              <span class="nav-icon">ðŸ‘¥</span>
              Employees
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabProjects" data-page="projects">
              <span class="nav-icon">ðŸš€</span>
              Projects
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabPayroll" data-page="payroll">
              <span class="nav-icon">ðŸ’°</span>
              Payroll
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabProjectTotals" data-page="totals">
              <span class="nav-icon">ðŸ“ˆ</span>
              Reports
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabContributionSummary" data-page="contribSummary">
              <span class="nav-icon">ðŸ’³</span>
              Contributions
            </button>
          </li>
        </ul>
      </nav>
    </aside>
    <main class="main-content">
      <div class="content-header">
        <h1 class="page-title">
          <span style="font-size: 32px;">ðŸ“Š</span>
          Dashboard
        </h1>
        <p class="page-subtitle">Manage your payroll system efficiently</p>
        <!-- Hide the legacy date range controls but keep them in the DOM for backwards compatibility -->
        <div class="date-range" id="dateRangeLegacy" style="display:none">
          <span style="font-weight: 600; color: #374151;">Start:</span>
          <input id="weekStart" type="date" class="date-input">
          <span style="font-weight: 600; color: #374151;">End:</span>
          <input id="weekEnd" type="date" class="date-input">
          <button id="dashGenerate" style="margin-left: 8px;">Generate</button>
        </div>
        <!-- New Active Payroll picker -->
        <div class="date-range" id="activePayrollPicker" style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
          <span style="font-weight:600;color:#374151;">Payroll period:</span>
          <select id="activePayrollSelect" class="date-input activeWeekSelect" style="min-width:260px;"></select>
          <button id="newPayrollPeriod" type="button" class="date-input">New period</button>
          <button id="lockSnapshotBtn" type="button" class="date-input">Lock &amp; Snapshot</button>
          <button id="unlockPeriodBtn" type="button" class="date-input">Unlock</button>
          <span id="dashLockStatus" style="display:none;font-size:12px;color:#111827;font-weight:600;"></span>
        </div>
        <!-- New Period Modal (pre-rendered for instant open) -->
        <style>
          /* Modal overlay */
          #newPeriodModal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);z-index:2000;align-items:center;justify-content:center}
          /* Modal card */
          #newPeriodModal .card{background:#fff;padding:18px 18px 14px;border-radius:12px;box-shadow:0 12px 34px rgba(0,0,0,.22);width:480px;max-width:96vw;font-family:inherit;box-sizing:border-box;border:1px solid #e5e7eb}
          #newPeriodModal h3{margin:0 0 10px 0;font-size:18px}
          #newPeriodModal label{display:block;font-size:13px;color:#374151;margin-top:8px}
          #newPeriodModal input[type=date]{width:100%;margin-top:4px;padding:8px;border:1px solid #D1D5DB;border-radius:8px;box-sizing:border-box}
          #newPeriodModal .row{display:flex;gap:12px;margin-top:4px;flex-wrap:wrap}
          #newPeriodModal .row > div{flex:1 1 0;min-width:0}
          #newPeriodModal .actions{margin-top:14px;display:flex;gap:8px;justify-content:flex-end}
          #newPeriodModal .spinner{width:16px;height:16px;border:2px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;animation:npSpin 0.8s linear infinite;display:none}
          #newPeriodModal .status{font-size:12px;color:#6B7280;margin-right:auto;display:none;align-items:center;gap:6px}
          @keyframes npSpin{to{transform:rotate(360deg)}}
          #newPeriodModal .error{color:#b91c1c;font-size:12px;display:none;margin-top:8px}
          #historyTable tbody tr{cursor:pointer;}
          @media (max-width: 520px){
            #newPeriodModal .card{width:94vw}
            #newPeriodModal .row > div{flex-basis:100%}
          }
        </style>
        <div id="newPeriodModal">
          <div class="card">
            <h3>New Payroll Period</h3>
            <div class="row">
              <div>
                <label>Start date
                  <input type="date" id="newPeriodStart" />
                </label>
              </div>
              <div>
                <label>End date
                  <input type="date" id="newPeriodEnd" />
                </label>
              </div>
            </div>
            <div class="error" id="newPeriodErr">End date must be on/after start date.</div>
            <div class="actions">
              <div class="status" id="newPeriodStatus"><span class="spinner" id="newPeriodSpin"></span><span>Creating snapshot…</span></div>
              <button id="cancelNewPeriod" type="button">Cancel</button>
              <button id="saveNewPeriod" type="button" class="primary">Create</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Begin original content -->

<!-- Original tab buttons and header removed in favour of sidebar navigation -->
  <!-- Dashboard panel to host high-level metrics and payroll history -->
  <section class="panel active" id="panelDashboard">
   <h3>Dashboard</h3>
   <!-- Date range picker and action buttons -->
   <!-- The Generate button has been moved into the date-range picker; retain the controls container for future actions if needed. -->
   <div class="controls"></div>
   <!-- Container for viewing a snapshot or diff results -->
   <div id="snapshotView" style="margin-top:12px;"></div>

   <!-- Active Payrolls table showing all un-locked snapshots -->
   <h4>Active Payrolls</h4>
   <table id="activePayrollTable">
     <thead>
       <tr>
         <th>Start</th>
         <th>End</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <!-- Payroll History table showing all generated/locked snapshots -->
   <h4>Payroll History</h4>
   <table id="historyTable">
     <thead>
       <tr>
         <th>Start</th>
         <th>End</th>
         <th>Locked At</th>
         <th>Net Pay</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <!-- Full Backup & Restore (Dashboard) -->
   <h4 style="margin-top:18px">Full Backup & Restore</h4>
   <div class="controls" id="dashBackupControls" style="gap:8px; align-items:center; flex-wrap:wrap;">
     <button id="dashBackupNow" class="primary" type="button">Backup Now</button>
     <button id="dashRestoreFile" type="button">Restore From File</button>
     <input id="dashRestoreInput" type="file" accept=".json" style="display:none" />
     <!-- Cloud listing and restore removed by request -->
     <span id="dashBackupStatus" style="font-size:12px;color:#334155"></span>
   </div>
   <div id="dashBackupLog" style="display:none;margin:8px 0;padding:10px;border:1px solid #e5e7eb;background:#fff;border-radius:8px;font-size:12px;color:#111;line-height:1.35;max-width:920px;"></div>
  </section>

  <script>
  // === Dashboard Full Backup & Restore ===
  (function(){
    const statusEl = document.getElementById('dashBackupStatus');
    const logEl = document.getElementById('dashBackupLog');
    const btnBackup = document.getElementById('dashBackupNow');
    const btnRestoreFile = document.getElementById('dashRestoreFile');
    const inputRestore = document.getElementById('dashRestoreInput');
    // Only keep local backup and file-restore controls
    if(!btnBackup || !btnRestoreFile || !inputRestore) return;

    // Lazily resolve Supabase to avoid capturing `null` before the module loads
    const getSupa = () => (window.supabase || null);
    const KV_TABLE = window.SUPABASE_TABLE || 'kv_store';
    const DTR_TABLE = 'dtr_records';
    const BUCKET = 'backups';

    function setStatus(msg, isError){ if(statusEl){ statusEl.textContent = msg; statusEl.style.color = isError?'#b91c1c':'#334155'; } }
    function log(msg){ try{ logEl.style.display='block'; const d=document.createElement('div'); d.textContent=msg; logEl.appendChild(d);}catch(e){} }
    function clearLog(){ try{ logEl.innerHTML=''; logEl.style.display='none'; }catch(e){} }
    function tryJSON(v){ try{ return JSON.parse(v); }catch{ return v; } }

    async function fetchKVAll(){
      const supa = getSupa();
      if(!supa) return { rows:[], error:'No Supabase client' };
      try{
        const { data, error } = await supa.from(KV_TABLE).select('key,value');
        return { rows: data||[], error: error? error.message : null };
      }catch(e){ return { rows:[], error: String(e) } }
    }
    async function fetchDTR(){
      const supa = getSupa();
      if(!supa) return { rows:[], error:'No Supabase client' };
      try{
        const { data, error } = await supa.from(DTR_TABLE).select('*').limit(1);
        if(error) return { rows:[], error: error.message };
        // Support schemas {id, data} or flat arrays
        if(Array.isArray(data) && data.length){
          const row = data[0];
          if(row && Array.isArray(row.data)) return { rows: row.data, error:null };
        }
        return { rows:[], error:null };
      }catch(e){ return { rows:[], error:String(e) } }
    }

    function snapshotLocalStorage(){
      const kv = {};
      try{
        for(let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if(!k || k.startsWith('__') || k.startsWith('vscode')) continue;
          kv[k] = tryJSON(localStorage.getItem(k));
        }
      }catch(e){}
      return kv;
    }

    async function buildBundle(){
      clearLog(); setStatus('Building backup...', false);
      const ls = snapshotLocalStorage();
      log('Collected localStorage keys: ' + Object.keys(ls).length);
      const kvRes = await fetchKVAll(); if(kvRes.error) log('KV fetch warning: ' + kvRes.error); else log('KV rows: ' + kvRes.rows.length);
      const dtrRes = await fetchDTR(); if(dtrRes.error) log('DTR fetch warning: ' + dtrRes.error); else log('DTR rows: ' + dtrRes.rows.length);
      const bundle = {
        schema: 'payrollhub.full.v1',
        created_at: new Date().toISOString(),
        localStorage: ls,
        kv: kvRes.rows||[],
        dtr: dtrRes.rows||[]
      };
      return bundle;
    }

    async function uploadBundleToCloud(bundle){
      const supa = getSupa();
      if(!supa || !supa.storage){ log('No Supabase storage client (skipping cloud upload)'); return null; }
      try{
        const json = JSON.stringify(bundle);
        const name = 'full_backup_' + new Date().toISOString().replace(/[:.]/g,'_') + '.json';
        const blob = new Blob([json], { type: 'application/json' });
        const { error } = await supa.storage.from(BUCKET).upload(name, blob, { upsert: true, contentType: 'application/json' });
        if(error){ log('Upload failed: ' + error.message); return null; }
        log('Uploaded to storage: ' + name);
        return name;
      }catch(e){ log('Upload failed: ' + String(e)); return null; }
    }

    // Cloud listing removed

    function applyLocalStorage(ls){
      try{ Object.keys(ls||{}).forEach(k=>{ try{ localStorage.setItem(k, JSON.stringify(ls[k])); }catch(_){} }); }catch(e){}
    }
    async function applyKV(kv){
      const supa = getSupa();
      if(!supa) return;
      try{
        for(const row of (kv||[])){
          if(!row || !row.key) continue;
          try{ await supa.from(KV_TABLE).upsert({ key: row.key, value: row.value }, { onConflict: 'key' }); }catch(_){}
        }
      }catch(e){ log('KV upsert error: ' + String(e)); }
    }
    async function applyDTR(rows){
      const supa = getSupa();
      if(!supa) return;
      try{
        await supa.from(DTR_TABLE).upsert({ id:'records', data: Array.isArray(rows)?rows:[] }, { onConflict:'id' });
        window.storedRecords = Array.isArray(rows)?rows:[];
        try{ localStorage.setItem('att_records_v2', JSON.stringify(window.storedRecords)); }catch(_){ }
      }catch(e){ log('DTR upsert error: ' + String(e)); }
    }

    btnBackup.addEventListener('click', async ()=>{
      btnBackup.disabled = true; setStatus('Building backup...', false); clearLog();
      try{
        const bundle = await buildBundle();
        // Download locally
        try{
          const url = URL.createObjectURL(new Blob([JSON.stringify(bundle)],{type:'application/json'}));
          const a=document.createElement('a'); a.href=url; a.download='payroll_full_backup_'+ new Date().toISOString().slice(0,10)+'.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500);
          log('Downloaded local backup');
        }catch(e){ log('Local download failed: ' + String(e)); }
        // Upload to cloud
        await uploadBundleToCloud(bundle);
        setStatus('Backup complete', false);
      }catch(e){ setStatus('Backup error: ' + String(e), true); }
      finally{ btnBackup.disabled = false; }
    });

    btnRestoreFile.addEventListener('click', ()=> inputRestore.click());
    inputRestore.addEventListener('change', async (ev)=>{
      const f = ev.target.files && ev.target.files[0]; ev.target.value=''; if(!f) return;
      setStatus('Restoring from file...', false); clearLog();
      try{
        const text = await f.text(); const bundle = JSON.parse(text||'{}');
        if(!bundle || bundle.schema !== 'payrollhub.full.v1') throw new Error('Invalid bundle schema');
        applyLocalStorage(bundle.localStorage || {}); log('Applied localStorage');
        await applyKV(bundle.kv || []); log('Applied KV table');
        await applyDTR(bundle.dtr || []); log('Applied DTR rows');
        setStatus('Restore complete', false); alert('Restore complete.');
      }catch(e){ setStatus('Restore failed: ' + String(e), true); alert('Restore failed: ' + String(e)); }
    });

    // Cloud restore removed
  })();
  // === / Dashboard Full Backup & Restore ===
  </script>

  <!-- Original Main panel (DTR) no longer active by default -->
  <section class="panel" id="panelMain">
<!-- Removed DTR-specific Active Payroll selector -->

   <div class="controls">
    <label>
     Upload .DAT/.TXT (multiple)
     <input accept=".dat,.txt" id="fileInput" multiple="" type="file"/>
    </label>
    <button id="manualDtrBtn">Enter Manual DTR</button>
    <button id="printDtrBtn">Print DTR</button>
    <label>
     Project:
     <select id="filterProject" title="Filter by project">
     </select>
    </label>
    <label> Search Name: <input id="dtrSearchName" type="text" placeholder="Type a name" style="width:220px" /></label>
   </div>
   <div class="note">
    Regular hours computed per schedule segments. Grace applies to AM/PM in. OT detected after PM out reference.
   </div>
   <!-- Alert to display when there is no remote DTR data and no local DTR data.  This
        banner is hidden by default and shown via showRemoteDtrAlert() -->
   <div id="remoteDtrAlert" style="display:none;margin:8px 0;padding:10px;border:1px solid #facc15;background:#fef9c3;color:#713f12;border-radius:6px;font-weight:600;">
     âš  No remote DTR data found. Import a .DAT/.TXT file on this device to populate cloud data.
   </div>
   <!-- Wrap the results table in a scrollable container so horizontal overflow
        is always visible. Without this wrapper some layouts (especially when
        embedding this page in an iframe or within a limited-width container)
        can hide the horizontal scroll bar and make it appear as if columns
        are missing. -->
   <div class="results-wrapper">
   <!-- DTR Date Finder Controls -->
<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;">
  <label style="display:flex;align-items:center;gap:.35rem;">
    <span>Date:</span>
    <input id="dtrDateFrom" type="date" />
  </label>
  <span>-</span>
  <label>
    <input id="dtrDateTo" type="date" />
  </label>
  <button id="dtrDateClear" type="button">Clear</button>
</div>
<table aria-live="polite" id="resultsTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Project
      </th>
      <th>
       Schedule
      </th>
      <th>
       Date
      </th>
      <th>
       Clock In 1
      </th>
      <th>
       Clock Out 1
      </th>
      <th>
       Clock In 2
      </th>
      <th>
       Clock Out 2
      </th>
      <th>
       OT In
      </th>
      <th>
       OT Out
      </th>
      <th>
       Regular Hrs
      </th>
      <th>
       OT Hrs
      </th>
      <th>Total Hours</th>
      <th>
       Split
      </th>
      <!-- Added explicit Actions column to ensure consistent header structure -->
      <th class="actions-header">
       Actions
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
   <!-- Summary of DTR totals and employee count -->
   <div id="dtrSummary" style="margin-top:4px;font-weight:bold;"></div>
   </div>
  </section>
  
  <section class="panel" id="panelSchedule">
   <h3>
    Schedules
   </h3>
   <div class="controls">
    <label>
     Choose schedule:
     <select id="scheduleSelect">
     </select>
    </label>
    <button id="addScheduleBtn">
     Add
    </button>
    <button id="deleteScheduleBtn">
     Delete
    </button>
    <button id="setDefaultScheduleBtn">
     Set Default
    </button>
   </div>
   <div class="section-title">
    Schedule segments
   </div>
   <table id="scheduleTable">
    <thead>
     <tr>
      <th>
       Segment
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       AM
      </td>
      <td>
       <input class="cell" data-key="sch_am_start" name="sch_am_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_am_end" name="sch_am_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       PM
      </td>
      <td>
       <input class="cell" data-key="sch_pm_start" name="sch_pm_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_pm_end" name="sch_pm_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday</td>
      <td><input class="cell" data-key="sch_sat_start" name="sch_sat_start" type="time"/></td>
      <td><input class="cell" data-key="sch_sat_end" name="sch_sat_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <label>
     Grace Minutes:
     <input class="cell" data-key="sch_grace" name="sch_grace" min="0" style="width:90px" type="number"/>
    </label>
    <label style="margin-left:8px">
     Schedule name:
     <input class="cell" id="scheduleName" style="width:200px"/>
    </label>
    <button id="saveScheduleBtn">
     Save
    </button>
   </div>
   <div class="section-title">
    Ranges (detection per schedule)
   </div>
   <table id="rangesTable">
    <thead>
     <tr>
      <th>
       Slot
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       Clock In 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_start" name="rng_am_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_end" name="rng_am_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_start" name="rng_am_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_end" name="rng_am_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock In 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_start" name="rng_pm_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_end" name="rng_pm_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_start" name="rng_pm_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_end" name="rng_pm_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT In
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_start" name="rng_ot_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_end" name="rng_ot_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT Out
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_start" name="rng_ot_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_end" name="rng_ot_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday OT In</td>
      <td><input class="cell" data-key="rng_sat_ot_start" name="rng_sat_ot_start" type="time"/></td>
      <td><input class="cell" data-key="rng_sat_ot_end" name="rng_sat_ot_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <button id="saveRangesBtn">
     Save Ranges
    </button>
    <button id="resetRangesBtn">
     Reset Ranges
    </button>
   </div>
  </section>
  
  <section class="panel" id="panelEmployees">
   <h3>
    Employees
   </h3>
   <div class="controls">
    <input class="cell" id="empIdInput" placeholder="ID" style="width:120px"/>
    <input class="cell" id="empNameInput" placeholder="Name" style="width:220px"/>
    <input class="cell" id="empRateInput" min="0" placeholder="Hourly Rate" step="0.01" style="width:140px" type="number"/>
    <input class="cell" id="empBankInput" placeholder="Bank Account" style="width:220px"/>
    <label>
     Company:
     <select id="empCompanySelect">
     </select>
    </label>
    <label>
     Schedule:
     <select id="empScheduleSelect">
     </select>
    </label>
    <label>
     Project:
     <select id="empProjectSelect">
     </select>
    </label>
    <button id="addEmployeeBtn">
     Add
    </button>
    <button id="clearEmployeesBtn">
     Clear All Employees
    </button>
   </div>
   <div class="controls" style="margin-top:6px;align-items:center;">
    <label style="font-weight:600">
     Upload employee list (no header):
    </label>
    <input accept=".xlsx,.xls,.csv" id="empFileInput" type="file"/>
    <button id="downloadEmployeesCSV">
     Download Employees CSV
    </button>
    <div class="muted">
     Cols: A = ID, B = Name, C = Hourly Rate (optional), D = Company (optional), E = Schedule Name (optional), F = Project Name (optional), G = Bank Account (optional). Older files without Company still import (defaulting to the first option).
    </div>
   </div>


   <table id="employeesTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Hourly Rate
      </th>
      <th>
       Schedule
      </th>
      <th>
       Project
      </th>
      <th>
       Company
      </th>
      <th>
       Bank Account
      </th>
      <th>
       Pag-IBIG
      </th>
      <th>
       PhilHealth
      </th>
      <th>
       SSS
      </th>
      <th>
       Action
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  
  <section class="panel" id="panelProjects">
   <h3>
    Projects
   </h3>
   <div class="controls">
    <input class="cell" id="projectNameInput" placeholder="Project Name" style="width:220px"/>
    <label>
     Company:
     <select id="projectCompanySelect">
     </select>
    </label>
    <button id="addProjectBtn">
     Add
    </button>
    <button id="clearProjectsBtn">
     Clear All Projects
    </button>
   </div>
   <table id="projectsTable">
    <thead>
     <tr>
      <th>
       Project Name
      </th>
      <th>
       Company
      </th>
      <th>
       Action
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  <section class="panel" id="panelPayroll">
   <div id="payrollWrapper">
    <header>
     <h2>
      Payroll
     </h2>
     <div class="tabs">
      <button class="tab-btn active" data-tab="payrollTab">
       Payroll
      </button>
      <!-- Renamed SSS sub-tab to Contributions to include additional government contributions -->
      <button class="tab-btn" data-tab="contributionsTab">
       Contributions
      </button>
      <button class="tab-btn" data-tab="deductionsTab">
       Deductions
      </button>
      <!-- New sub-tab for manual adjustments -->
      <button class="tab-btn" data-tab="adjustmentsTab">Adjustments</button>
     </div>
    </header>
    <div class="tab active" id="payrollTab">
     <div class="controls">
      <label>
       OT Multiplier
       <br/>
       <input id="otMultiplier" step="0.01" style="width:100px" type="number" value="1.50"/>
      </label>
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisor">
        <option value="1">
         1
        </option>
        <option value="2">
         2
        </option>
        <option value="3">
         3
        </option>
        <option value="4">
         4
        </option>
        <option value="5">
         5
        </option>
       </select>
      </label>
      <div style="flex:1 1 auto">
      </div>
      <button class="primary" id="downloadPayrollCSV">
       Download Payroll CSV
      </button>
      <button id="printPayrollBtn" type="button">
       Print Report
      </button>
      <button id="printPayrollExcelBtn" type="button">
       Print Report Excel
      </button>
      <button id="printAllPayslipsBtn" type="button">
       Print Payslips
      </button>
     </div>
     <table id="payrollTable">
      <thead>
       <tr>
        <th>
         ID
        </th>
        <th>
         Name
        </th>
        <th>
         Hourly Rate
        </th>
        <th>
         Regular Hours
        </th>
        <th>
         OT Hours
        </th>
        <th>
         Adjustment Hrs
        </th>
        
        <th>Total Hours</th>
        <th>
         Regular Pay
        </th>
        <th>
         OT Pay
        </th>
        <th>
         Adjustments
        </th>
        <th>
         Bantay
        </th>
        <th>
         Gross Pay
        </th>
        <th>
         Pag-IBIG
        </th>
        <th>
         PhilHealth
        </th>
        <th>
         SSS
        </th>
        <th>
         SSS Loan
        </th>
        <th>
         Pag-IBIG Loan
        </th>
        <th>
         Account
        </th>
        <th>
         Wed Vale
        </th>
        <th>
         Total Deductions
        </th>
        <th>
         Net Pay
        </th>
       <th>
        Payslip
       </th>
      </tr>
     </thead>
      <tbody>
       <tr><td class="totalDed">100</td></tr>
       <tr><td class="totalDed">200</td></tr>
       <tr><td class="totalDed">50</td></tr>
      </tbody>
      <tfoot id="payrollTotalsFoot">
  <tr>
    <td colspan="2" class="label-cell">Grand Total</td>
    <td class="num" data-col="rate"></td>
    <td class="num" data-col="regHrs">0.00</td>
    <td class="num" data-col="otHrs">0.00</td>
    <td class="num" data-col="adjHrs">0.00</td>
    <td class="num" data-col="totalHrs">0.00</td>
      <td class="num" data-col="regPay">0.00</td>
      <td class="num" data-col="otPay">0.00</td>
      <td class="num" data-col="adjAmt">0.00</td>
      <td class="num" data-col="bantay">0.00</td>
      <td class="num" data-col="grossPay">0.00</td>
    <td class="num" data-col="pagibig">0.00</td>
    <td class="num" data-col="philhealth">0.00</td>
    <td class="num" data-col="sss">0.00</td>
    <td class="num" data-col="loanSSS">0.00</td>
    <td class="num" data-col="loanPI">0.00</td>
      <td class="num" data-col="vale">0.00</td>
      <td class="num" data-col="valeWed">0.00</td>
      <td class="num" data-col="totalDed">0.00</td>
      <td class="num" data-col="netPay">0.00</td>
    <td></td>
  </tr>
</tfoot>

     </table>
     <div class="section note">
      Reads employees from localStorage key
      <code>
       att_employees_v2
      </code>
      (id&rarr;{name}). If none found, shows a sample row.
     </div>
    </div>
    <!-- Renamed SSS tab to Contributions for clarity -->
    <div class="tab" id="contributionsTab">
     <div class="contrib-hero">
      <div>
       <h3>Government contributions at a glance</h3>
       <p>Configure the tables below so PayrollPro can match each worker to the correct statutory contribution.</p>
       <ul class="contrib-key-list">
        <li>Ranges are matched against <strong>monthly income</strong> from payroll calculations.</li>
        <li>Each edit saves automatically &mdash; no extra confirmation needed.</li>
        <li>Use CSV import/export to align with government updates.</li>
       </ul>
      </div>
      <div class="contrib-pill-stack">
       <div class="contrib-pill">
        <strong>SSS</strong>
        <small>Employee and employer peso shares per income bracket.</small>
       </div>
       <div class="contrib-pill">
        <strong>Pag-IBIG</strong>
        <small>Decimal employee rate applied to regular pay (employer assumed to match).</small>
       </div>
       <div class="contrib-pill">
        <strong>PhilHealth</strong>
        <small>Decimal employee rate per bracket; applied to monthly income.</small>
       </div>
      </div>
     </div>

     <div class="table-card">
      <div class="table-card__header">
       <div>
        <p class="table-card__tag">SSS</p>
        <h4 class="table-card__title">Monthly SSS shares</h4>
        <p class="table-card__subtitle">Use the peso amounts that apply to each bracket. PayrollPro will pick the row where <em>min &le; income &le; max</em>.</p>
       </div>
       <div class="table-card__tags">
        <span class="table-card__tag">Peso values</span>
        <span class="table-card__tag">Auto-save</span>
       </div>
      </div>
      <div class="controls">
       <button id="addSssRow">
        Add Row
       </button>
       <button class="primary" id="resetSss">
        Reset to Defaults (Custom)
       </button>
       <button class="danger" id="clearSss">
        Clear SSS Table
       </button>
       <button id="exportSss">
        Export CSV
       </button>
       <label>
        Import CSV (min,max,employeeShare,employerShare)
        <br/>
        <input accept=".csv,text/csv" id="importSss" type="file"/>
       </label>
      </div>
      <table id="sssTable">
       <thead>
        <tr>
         <th>
          Range From (â‚±)
         </th>
         <th>
          Range To (â‚±)
         </th>
         <th>
          Employee Share (â‚±)
         </th>
         <th>
          Employer Share (â‚±)
         </th>
         <th>
          Actions
         </th>
        </tr>
       </thead>
       <tbody>
       </tbody>
      </table>
      <div class="section note contrib-note">
       <strong>How it is used:</strong> Monthly Income = Hourly Rate &times; 8 &times; 24. The matching bracket supplies the employee and employer shares.
      </div>
     </div>

     <div class="table-card">
      <div class="table-card__header">
       <div>
        <p class="table-card__tag">Pag-IBIG</p>
        <h4 class="table-card__title">Pag-IBIG employee rates</h4>
        <p class="table-card__subtitle">Enter rates as decimals (0.02 = 2%). Applied to regular pay; employer share is assumed to mirror the employee rate.</p>
       </div>
       <div class="table-card__tags">
        <span class="table-card__tag">Rate table</span>
        <span class="table-card__tag">Bracketed</span>
       </div>
      </div>
      <div class="controls">
        <button id="addPagibigRow">
         Add Row
        </button>
        <button class="primary" id="resetPagibig">
         Reset to Defaults
        </button>
        <button class="danger" id="clearPagibig">
         Clear Pag-IBIG Table
        </button>
      </div>
      <table id="pagibigTable">
        <thead>
          <tr>
            <th>Range From (â‚±)</th>
            <th>Range To (â‚±)</th>
            <th>Rate (decimal)</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
      <div class="section note contrib-note">
        Keep ranges continuous so every salary finds a matching rate. Export before major edits so you can restore if needed.
      </div>
     </div>

     <div class="table-card">
      <div class="table-card__header">
       <div>
        <p class="table-card__tag">PhilHealth</p>
        <h4 class="table-card__title">PhilHealth employee rates</h4>
        <p class="table-card__subtitle">Provide decimal rates per income band. The rate is applied to monthly income to compute the employee share.</p>
       </div>
       <div class="table-card__tags">
        <span class="table-card__tag">Rate table</span>
        <span class="table-card__tag">Bracketed</span>
       </div>
      </div>
      <div class="controls">
        <button id="addPhilRow">
         Add Row
        </button>
        <button class="primary" id="resetPhil">
         Reset to Defaults
        </button>
        <button class="danger" id="clearPhil">
         Clear PhilHealth Table
        </button>
      </div>
      <table id="philhealthTable">
        <thead>
          <tr>
            <th>Range From (â‚±)</th>
            <th>Range To (â‚±)</th>
            <th>Rate (decimal)</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
      <div class="section note contrib-note">
        Rates use decimal format (e.g. 0.025 = 2.5% employee share). Ensure the final row captures high earners.
      </div>
     </div>
    </div>
    <div class="tab" id="deductionsTab">
     <div id="dedMainSection" class="subtab-panel active">
     <div class="controls">
      <!-- Divisor selector for splitting deductions across pay periods (Deductions tab) -->
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisorDeds">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
       </select>
      </label>
      <div class="column-toggle-controls" id="deductionColumnToggles">
       <span>Include in deductions:</span>
       <label><input type="checkbox" data-col="pagibig" checked/> Pag-IBIG</label>
       <label><input type="checkbox" data-col="philhealth" checked/> PhilHealth</label>
       <label><input type="checkbox" data-col="sss" checked/> SSS</label>
       <label><input type="checkbox" data-col="loanSSS" checked/> SSS Loan</label>
       <label><input type="checkbox" data-col="loanPI" checked/> Pag-IBIG Loan</label>
       <label><input type="checkbox" data-col="vale" checked/> Account</label>
       <label><input type="checkbox" data-col="adjustments" checked/> Adjustments</label>
       <label><input type="checkbox" data-col="valeWed" checked/> Wed Vale</label>
       <label><input type="checkbox" data-col="total" checked/> Total Deductions</label>
      </div>
     </div>
     <div class="section note">
      Columns 6 to 10 are editable directly in this table. Enter the full loan or vale amount (before it is divided across the
      payroll periods) and use a positive value for deductions under Adjustments. All values are saved for the active payroll
      period and will carry over automatically to newly created periods without altering any historical payroll data. Set a field
      to 0 to clear it for the current period.
     </div>
     <table id="deductionsTable">
      <thead>
       <tr>
        <th data-col="id">ID</th>
        <th data-col="name">Name</th>
        <th data-col="pagibig">Pag-IBIG</th>
        <th data-col="philhealth">PhilHealth</th>
        <th data-col="sss">SSS</th>
        <th data-col="loanSSS">SSS Loan</th>
        <th data-col="loanPI">Pag-IBIG Loan</th>
        <th data-col="vale">Account</th>
        <th data-col="adjustments">Adjustments</th>
        <th data-col="valeWed">Wed Vale</th>
        <th data-col="total">Total Deductions</th>
       </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="deductionsTable_foot">
        <tr>
          <td class="label-cell" colspan="2">Grand Total</td>
          <td class="num" data-col="pagibig">0.00</td>
          <td class="num" data-col="philhealth">0.00</td>
          <td class="num" data-col="sss">0.00</td>
          <td class="num" data-col="loanSSS">0.00</td>
          <td class="num" data-col="loanPI">0.00</td>
          <td class="num" data-col="vale">0.00</td>
          <td class="num" data-col="adjustments">0.00</td>
          <td class="num" data-col="valeWed">0.00</td>
          <td class="num" data-col="total">0.00</td>
        </tr>
      </tfoot>

     </table>
     </div><!-- close dedMainSection -->
    </div>

    <!-- Manual Adjustments Tab -->
    <div class="tab" id="adjustmentsTab">
     <div class="section note">
      Enter positive adjustments to add to payroll. Enter negative amounts to create deductions&mdash;they will appear automatically in the Deductions tab and will not reduce the gross pay calculation. Adjustments are saved automatically to this browser; use the copy/restore buttons to move them to another device.
     </div>
     <div class="toolbar" id="adjustmentsControls">
      <div class="toolbar-left">
       <button type="button" id="copyAdjustmentsBtn">Copy adjustments</button>
       <button type="button" id="restoreAdjustmentsBtn">Restore adjustments</button>
      </div>
      <span class="save-indicator" id="adjustmentSaveStatus" aria-live="polite">Saved locally</span>
     </div>
     <table id="adjustmentsTable">
      <thead>
       <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Adjustment Amount</th>
        <th>Adjustment Hrs</th>
        </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="adjustmentsTableFoot">
       <tr>
        <td colspan="2" class="label-cell">Total Adjustments</td>
        <td class="num" data-col="adjAmt">0.00</td>
        <td class="num" data-col="adjHrs">0.00</td>
       </tr>
      </tfoot>
     </table>
    </div>

    <script>
const LS_RATES='payroll_rates', LS_REG_HRS='payroll_reg_hours', LS_OT_HRS='payroll_ot_hours';
const LS_OTMULT='payroll_ot_multiplier', LS_WEEKSTART='payroll_week_start', LS_WEEKEND='payroll_week_end';
const LS_DIVISOR='payroll_deduction_divisor', LS_SSS_TABLE='payroll_sss_table';
const LS_LOAN_SSS='payroll_loan_sss', LS_LOAN_PI='payroll_loan_pagibig';
const LS_VALE='payroll_vale', LS_VALE_WED='payroll_vale_wed';
// LocalStorage key for per-employee payroll adjustments
const LS_ADJ='payroll_adjustments';
// LocalStorage key for per-employee adjustment hours (OT adjustments)
const LS_ADJ_HRS='payroll_adjustment_hours';
// LocalStorage keys for dynamic Pagâ€‘IBIG and PhilHealth contribution rates (employee share)
const LS_PAGIBIG_RATE='payroll_pagibig_rate';
const LS_PHILHEALTH_RATE='payroll_philhealth_rate';
// LocalStorage keys for dynamic Pagâ€‘IBIG and PhilHealth contribution tables
const LS_PAGIBIG_TABLE='payroll_pagibig_table';
const LS_PHILHEALTH_TABLE='payroll_philhealth_table';
// LocalStorage key for per-employee Bantay allowance
const LS_BANTAY='payroll_bantay';
// Supabase-only key for per-employee Bantayâ†’Project assignment map
const LS_BANTAY_PROJ='payroll_bantay_proj';
let bantayProj = {};
;(async function(){
  try{
    let v = await window.readKV(LS_BANTAY_PROJ);
    if (!v) {
      try { v = JSON.parse(localStorage.getItem(LS_BANTAY_PROJ) || '{}'); } catch(_){}
    }
    if (v && typeof v==='object') bantayProj = v;
    try { localStorage.setItem(LS_BANTAY_PROJ, JSON.stringify(bantayProj)); } catch(_){ }
    try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(_){ }
  }catch(e){}
})();
// LocalStorage key for per-employee contribution flags (Pag-IBIG, PhilHealth, SSS)
const LS_CONTRIB_FLAGS='payroll_contrib_flags';

// Current employee contribution rates (decimal form).  Defaults: 0.02 (2%) for Pagâ€‘IBIG and 0.025 (2.5%) for PhilHealth.
let pagibigRate = parseFloat(localStorage.getItem(LS_PAGIBIG_RATE) ?? '0.02');
if (isNaN(pagibigRate)) pagibigRate = 0.02;
let philhealthRate = parseFloat(localStorage.getItem(LS_PHILHEALTH_RATE) ?? '0.025');
if (isNaN(philhealthRate)) philhealthRate = 0.025;
const SSS_SEED_2025 = [
  [1, 5249.99, 250, 250],
  [5250, 5749.99, 275, 275],
  [5750, 6249.99, 300, 300],
  [6250, 6749.99, 325, 325],
  [6750, 7249.99, 350, 350],
  [7250, 7749.99, 375, 375],
  [7750, 8249.99, 400, 400],
  [8250, 8749.99, 425, 425],
  [8750, 9249.99, 450, 450],
  [9250, 9749.99, 475, 475],
  [9750, 10249.99, 500, 500],
  [10250, 10749.99, 525, 525],
  [10750, 11249.99, 550, 550],
  [11250, 11749.99, 575, 575],
  [11750, 12249.99, 600, 600],
  [12250, 12749.99, 625, 625],
  [12750, 13249.99, 650, 650],
  [13250, 13749.99, 675, 675],
  [13750, 14249.99, 700, 700],
  [14250, 14749.99, 725, 725],
  [14750, 15249.99, 750, 750],
  [15250, 15749.99, 775, 775],
  [15750, 16249.99, 800, 800],
  [16250, 16749.99, 825, 825],
  [16750, 17249.99, 850, 850],
  [17250, 17749.99, 875, 875],
  [17750, 18249.99, 900, 900],
  [18250, 18749.99, 925, 925],
  [18750, 19249.99, 950, 950],
  [19250, 19749.99, 975, 975],
  [19750, 20249.99, 1000, 1000],
  [20250, 20749.99, 1025, 1025],
  [20750, 21249.99, 1050, 1050],
  [21250, 21749.99, 1075, 1075],
  [21750, 22249.99, 1100, 1100],
  [22250, 22749.99, 1125, 1125],
  [22750, 23249.99, 1150, 1150],
  [23250, 23749.99, 1175, 1175],
  [23750, 24249.99, 1200, 1200],
  [24250, 24749.99, 1225, 1225],
  [24750, 25249.99, 1250, 1250],
  [25250, 25749.99, 1275, 1275],
  [25750, 26249.99, 1300, 1300],
  [26250, 26749.99, 1325, 1325],
  [26750, 27249.99, 1350, 1350],
  [27250, 27749.99, 1375, 1375],
  [27750, 28249.99, 1400, 1400],
  [28250, 28749.99, 1425, 1425],
  [28750, 29249.99, 1450, 1450],
  [29250, 29749.99, 1475, 1475],
  [29750, 30249.99, 1500, 1500],
  [30250, 30749.99, 1525, 1525],
  [30750, 31249.99, 1550, 1550],
  [31250, 31749.99, 1575, 1575],
  [31750, 32249.99, 1600, 1600],
  [32250, 32749.99, 1625, 1625],
  [32750, 33249.99, 1650, 1650],
  [33250, 33749.99, 1675, 1675],
  [33750, 34249.99, 1700, 1700],
  [34250, 34749.99, 1725, 1725],
  [34750, 100000000, 1750, 1750]
];

function ensureSeededSSS() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2], employer: (typeof r[3] !== 'undefined' ? r[3] : r[2])}));
      localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
    } else {
      const normalized = cur.map(row => {
        const min = Number(row && typeof row.min !== 'undefined' ? row.min : 0) || 0;
        const max = Number(row && typeof row.max !== 'undefined' ? row.max : 0) || 0;
        const employee = Number(row && typeof row.employee !== 'undefined' ? row.employee : 0) || 0;
        const employerRaw = Number(row && typeof row.employer !== 'undefined' ? row.employer : employee);
        const employer = Number.isFinite(employerRaw) ? employerRaw : employee;
        return { min, max, employee, employer };
      });
      localStorage.setItem(LS_SSS_TABLE, JSON.stringify(normalized));
    }
  } catch (e) {
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2], employer: (typeof r[3] !== 'undefined' ? r[3] : r[2])}));
    localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededSSS();
// Seed the Pagâ€‘IBIG and PhilHealth tables with default rates if empty.  These tables
// define income ranges and the corresponding employee contribution rate (decimal).
const PAGIBIG_SEED = [
  [0, 100000000, 0.02]
];
const PHILHEALTH_SEED = [
  [0, 100000000, 0.025]
];

function ensureSeededPagibig() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_PAGIBIG_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
    localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(mapped));
  }
}

function ensureSeededPhilhealth() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_PHILHEALTH_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
    localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededPagibig();
ensureSeededPhilhealth();
let payrollRates = JSON.parse(localStorage.getItem(LS_RATES) || '{}');
let regHours = JSON.parse(localStorage.getItem(LS_REG_HRS) || '{}');
let otHours = JSON.parse(localStorage.getItem(LS_OT_HRS) || '{}');

// Per-employee contribution deduction flags. Each entry keyed by employee ID holds booleans {pagibig, philhealth, sss}
let contribFlags = JSON.parse(localStorage.getItem(LS_CONTRIB_FLAGS) || '{}');

let otMultiplier = parseFloat(localStorage.getItem(LS_OTMULT)) || 1.50;
let weekStartSaved = localStorage.getItem(LS_WEEKSTART) || '';
let weekEndSaved = localStorage.getItem(LS_WEEKEND) || '';
let divisor = parseInt(localStorage.getItem(LS_DIVISOR) || '1', 10);
const weekStartEl = document.getElementById('weekStart');
const weekEndEl = document.getElementById('weekEnd');
const otMultiplierEl = document.getElementById('otMultiplier');
const divisorEl = document.getElementById('deductionDivisor');
const divisorDedsEl = document.getElementById('deductionDivisorDeds');
const tbody = document.querySelector('#payrollTable tbody');
document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    try { if (typeof adjustmentRefresh?.flush === 'function') adjustmentRefresh.flush(); } catch (_) {}
    document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('#panelPayroll .tab').forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    const panel = document.querySelector('#panelPayroll #' + btn.dataset.tab);
    if (panel) panel.classList.add('active');
  });
});
otMultiplierEl.value = otMultiplier;
weekStartEl.value = weekStartSaved;
weekEndEl.value = weekEndSaved;
divisorEl.value = divisor;

function periodKey(){return (weekStartEl.value||'')+'_'+(weekEndEl.value||'');}
const PERIOD_META_KEY='__meta';
const PERIOD_DEFAULT_KEY='__default';
function isPlainObject(val){ return !!val && typeof val === 'object' && !Array.isArray(val); }
function clonePeriodData(src){
  if(!isPlainObject(src)) return {};
  try { return JSON.parse(JSON.stringify(src)); } catch (e) {
    const out = {};
    Object.keys(src || {}).forEach(k => { out[k] = src[k]; });
    return out;
  }
}
function splitPeriodKey(key){
  if (typeof key !== 'string') return { start: '', end: '' };
  const parts = key.split('_');
  return { start: parts[0] || '', end: parts[1] || '' };
}
function comparePeriodKeys(a, b){
  if (a === b) return 0;
  const pa = splitPeriodKey(a);
  const pb = splitPeriodKey(b);
  if (pa.start && pb.start && pa.start !== pb.start) return pa.start < pb.start ? -1 : 1;
  if (pa.start && !pb.start) return 1;
  if (!pa.start && pb.start) return -1;
  if (pa.end && pb.end && pa.end !== pb.end) return pa.end < pb.end ? -1 : 1;
  if (pa.end && !pb.end) return 1;
  if (!pa.end && pb.end) return -1;
  const aStr = typeof a === 'string' ? a : '';
  const bStr = typeof b === 'string' ? b : '';
  if (aStr === bStr) return 0;
  return aStr < bStr ? -1 : 1;
}
function sortedPeriodKeys(map){
  return Object.keys(map || {})
    .filter(k => k !== PERIOD_META_KEY && k !== PERIOD_DEFAULT_KEY)
    .sort(comparePeriodKeys);
}
function ensurePeriodMeta(map){
  if (!isPlainObject(map)) return { periodScoped: true, latestKey: '' };
  const meta = isPlainObject(map[PERIOD_META_KEY]) ? map[PERIOD_META_KEY] : {};
  meta.periodScoped = true;
  if (typeof meta.latestKey !== 'string') meta.latestKey = '';
  map[PERIOD_META_KEY] = meta;
  return meta;
}
function loadPeriodScopedMap(lsKey){
  let parsed;
  try { parsed = JSON.parse(localStorage.getItem(lsKey) || '{}'); }
  catch(e){ parsed = {}; }
  if (!isPlainObject(parsed)) parsed = {};
  const meta = parsed[PERIOD_META_KEY];
  if (!isPlainObject(meta) || meta.periodScoped !== true) {
    const legacy = parsed;
    parsed = {};
    parsed[PERIOD_META_KEY] = { periodScoped: true, latestKey: '' };
    parsed[PERIOD_DEFAULT_KEY] = isPlainObject(legacy) ? legacy : {};
  } else {
    parsed[PERIOD_META_KEY] = Object.assign({}, meta, { periodScoped: true });
  }
  const ensuredMeta = ensurePeriodMeta(parsed);
  const keys = sortedPeriodKeys(parsed);
  if (!ensuredMeta.latestKey && keys.length) {
    ensuredMeta.latestKey = keys[keys.length - 1];
  }
  if (!isPlainObject(parsed[PERIOD_DEFAULT_KEY]) && ensuredMeta.latestKey && isPlainObject(parsed[ensuredMeta.latestKey])) {
    parsed[PERIOD_DEFAULT_KEY] = clonePeriodData(parsed[ensuredMeta.latestKey]);
  }
  return parsed;
}
function findCarryTemplate(map, key, fallbackKey){
  const keys = sortedPeriodKeys(map);
  if (!keys.length) return null;
  let candidate = null;
  for (const existing of keys){
    if (comparePeriodKeys(existing, key) <= 0) {
      candidate = existing;
    } else {
      break;
    }
  }
  if (candidate && isPlainObject(map[candidate])) return map[candidate];
  if (fallbackKey && comparePeriodKeys(fallbackKey, key) <= 0 && isPlainObject(map[fallbackKey])) {
    return map[fallbackKey];
  }
  return null;
}
function ensurePeriodData(map, key, template, options){
  if (!isPlainObject(map)) return {};
  const allowDefault = !options || options.allowDefault !== false;
  if (!isPlainObject(map[key])) {
    let base = {};
    if (isPlainObject(template)) base = template;
    else if (allowDefault && isPlainObject(map[PERIOD_DEFAULT_KEY])) base = map[PERIOD_DEFAULT_KEY];
    map[key] = clonePeriodData(base);
  }
  return map[key];
}
function updatePeriodLatest(map, key, data){
  if (!isPlainObject(map) || !key) return;
  const meta = ensurePeriodMeta(map);
  if (!meta.latestKey || comparePeriodKeys(key, meta.latestKey) >= 0) {
    meta.latestKey = key;
    if (isPlainObject(data)) {
      map[PERIOD_DEFAULT_KEY] = clonePeriodData(data);
    }
  }
}
function persistPeriodScopedMap(lsKey, map){
  if (!isPlainObject(map)) return Promise.resolve();
  ensurePeriodMeta(map);
  try {
    if (isPlainObject(map.__meta)) map.__meta.lastUpdatedAt = Date.now();
  } catch(_){}
  try { localStorage.setItem(lsKey, JSON.stringify(map)); } catch(e){}
  const writer = (typeof window !== 'undefined' && typeof window.writeKV === 'function')
    ? window.writeKV
    : null;
  if (typeof writer === 'function') {
    try {
      const maybe = writer(lsKey, map);
      if (maybe && typeof maybe.then === 'function') {
        return maybe.catch(err=>{ console.warn('writeKV persist failed', err); });
      }
      return Promise.resolve(maybe);
    } catch(err){ console.warn('writeKV persist threw', err); }
  }
  return Promise.resolve();
}
let currentPeriodKey = periodKey();
let allLoanSSS = loadPeriodScopedMap(LS_LOAN_SSS);
let allLoanPI = loadPeriodScopedMap(LS_LOAN_PI);
let allVale = loadPeriodScopedMap(LS_VALE);
let allValeWed = loadPeriodScopedMap(LS_VALE_WED);
let loanSSS = ensurePeriodData(allLoanSSS, currentPeriodKey);
let loanPI = ensurePeriodData(allLoanPI, currentPeriodKey);
let vale = ensurePeriodData(allVale, currentPeriodKey);
let valeWed = ensurePeriodData(allValeWed, currentPeriodKey);
let periodPersistenceReady = false;
try {
  if (typeof window !== 'undefined' && window.__kv_hydrated === true) periodPersistenceReady = true;
} catch(_){}
let allAdjustments = JSON.parse(localStorage.getItem(LS_ADJ) || '{}');
let adjustments = allAdjustments[currentPeriodKey] || {};
try { window.adjustments = adjustments; } catch(_){ }
let allAdjHrs = JSON.parse(localStorage.getItem(LS_ADJ_HRS) || '{}');
let adjHrs = allAdjHrs[currentPeriodKey] || {};
let allBantay = JSON.parse(localStorage.getItem(LS_BANTAY) || '{}');
let bantay = allBantay[currentPeriodKey] || {};

function persistCurrentAdjustments(){
  if (!isPlainObject(allAdjustments)) allAdjustments = {};
  if (!isPlainObject(adjustments)) adjustments = {};
  allAdjustments[currentPeriodKey] = adjustments;
  updatePeriodLatest(allAdjustments, currentPeriodKey, adjustments);
  persistPeriodScopedMap(LS_ADJ, allAdjustments);
  try { window.adjustments = adjustments; } catch(_){ }
}

function persistCurrentAdjustmentHours(){
  if (!isPlainObject(allAdjHrs)) allAdjHrs = {};
  if (!isPlainObject(adjHrs)) adjHrs = {};
  allAdjHrs[currentPeriodKey] = adjHrs;
  updatePeriodLatest(allAdjHrs, currentPeriodKey, adjHrs);
  persistPeriodScopedMap(LS_ADJ_HRS, allAdjHrs);
}

function refreshPeriodScopedCachesFromStorage(){
  allLoanSSS = loadPeriodScopedMap(LS_LOAN_SSS);
  allLoanPI = loadPeriodScopedMap(LS_LOAN_PI);
  allVale = loadPeriodScopedMap(LS_VALE);
  allValeWed = loadPeriodScopedMap(LS_VALE_WED);
  loanSSS = ensurePeriodData(allLoanSSS, currentPeriodKey);
  loanPI = ensurePeriodData(allLoanPI, currentPeriodKey);
  vale = ensurePeriodData(allVale, currentPeriodKey);
  valeWed = ensurePeriodData(allValeWed, currentPeriodKey);
  allAdjustments = JSON.parse(localStorage.getItem(LS_ADJ) || '{}');
  adjustments = allAdjustments[currentPeriodKey] || {};
  allAdjHrs = JSON.parse(localStorage.getItem(LS_ADJ_HRS) || '{}');
  adjHrs = allAdjHrs[currentPeriodKey] || {};
  allBantay = JSON.parse(localStorage.getItem(LS_BANTAY) || '{}');
  bantay = allBantay[currentPeriodKey] || {};
  try {
    window.loanSSS = loanSSS;
    window.loanPI = loanPI;
    window.vale = vale;
    window.valeWed = valeWed;
    window.adjustments = adjustments;
  } catch(_){ }
}

try {
  if (typeof window !== 'undefined') {
    window.addEventListener('kv-hydrated', () => {
      periodPersistenceReady = true;
      refreshPeriodScopedCachesFromStorage();
      try {
        if (typeof renderAdjustmentsTable === 'function') renderAdjustmentsTable();
      } catch (_) {}
    });
  }
} catch(_){ }
if (periodPersistenceReady) {
  refreshPeriodScopedCachesFromStorage();
}
async function saveCurrentPeriodDeductions(){
  if (!currentPeriodKey) return;
  allLoanSSS[currentPeriodKey] = loanSSS || {};
  allLoanPI[currentPeriodKey] = loanPI || {};
  allVale[currentPeriodKey] = vale || {};
  allValeWed[currentPeriodKey] = valeWed || {};
  try {
    window.loanSSS = loanSSS;
    window.loanPI = loanPI;
    window.vale = vale;
    window.valeWed = valeWed;
  } catch(e){}
  if (!periodPersistenceReady) return;
  updatePeriodLatest(allLoanSSS, currentPeriodKey, loanSSS);
  updatePeriodLatest(allLoanPI, currentPeriodKey, loanPI);
  updatePeriodLatest(allVale, currentPeriodKey, vale);
  updatePeriodLatest(allValeWed, currentPeriodKey, valeWed);
  const tasks = [
    persistPeriodScopedMap(LS_LOAN_SSS, allLoanSSS),
    persistPeriodScopedMap(LS_LOAN_PI, allLoanPI),
    persistPeriodScopedMap(LS_VALE, allVale),
    persistPeriodScopedMap(LS_VALE_WED, allValeWed)
  ];
  try { await Promise.all(tasks); } catch(_){ }
}
saveCurrentPeriodDeductions();
function syncPeriodScopedData(){
  const pk = periodKey();
  if (pk === currentPeriodKey) return false;
  const prevKey = currentPeriodKey;
  saveCurrentPeriodDeductions();
  const direction = comparePeriodKeys(pk, prevKey);
  const carryForward = direction >= 0;
  const tplSSS = carryForward ? findCarryTemplate(allLoanSSS, pk, prevKey) : null;
  const tplPI = carryForward ? findCarryTemplate(allLoanPI, pk, prevKey) : null;
  const tplVale = carryForward ? findCarryTemplate(allVale, pk, prevKey) : null;
  const tplValeWed = carryForward ? findCarryTemplate(allValeWed, pk, prevKey) : null;
  loanSSS = ensurePeriodData(allLoanSSS, pk, tplSSS, { allowDefault: carryForward });
  loanPI = ensurePeriodData(allLoanPI, pk, tplPI, { allowDefault: carryForward });
  vale = ensurePeriodData(allVale, pk, tplVale, { allowDefault: carryForward });
  valeWed = ensurePeriodData(allValeWed, pk, tplValeWed, { allowDefault: carryForward });
  adjustments = allAdjustments[pk] || {};
  try { window.adjustments = adjustments; } catch(_){ }
  adjHrs = allAdjHrs[pk] || {};
  bantay = allBantay[pk] || {};
  currentPeriodKey = pk;
  try { refreshCurrentDeductionColumnInclusions(); } catch(_){ }
  try { applyDeductionColumnState(); } catch(_){ }
  saveCurrentPeriodDeductions();
  return true;
}
;(async function(){
  try{
    let v = await window.readKV(LS_BANTAY);
    if (!v) {
      try { v = JSON.parse(localStorage.getItem(LS_BANTAY) || '{}'); } catch(_){ }
    }
    if (v && typeof v === 'object') {
      allBantay = v;
      bantay = allBantay[currentPeriodKey] || {};
    }
    try { localStorage.setItem(LS_BANTAY, JSON.stringify(allBantay)); } catch(_){ }
    try{ if (typeof renderSssTable==='function') renderSssTable(); }catch(_){ }
    try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(_){ }
  }catch(e){}
})();
// Sync the Deductions tab divisor select with the stored divisor value and attach event listener
if (divisorDedsEl) {
  divisorDedsEl.value = String(divisor);
  divisorDedsEl.addEventListener('change', () => {
    divisor = parseInt(divisorDedsEl.value, 10) || 1;
    divisorEl.value = String(divisor);
    localStorage.setItem(LS_DIVISOR, String(divisor));
    calculateAll();
  });
}

otMultiplierEl.addEventListener('input', ()=>{ otMultiplier = parseFloat(otMultiplierEl.value)||0; localStorage.setItem(LS_OTMULT, otMultiplier); calculateAll(); });
weekStartEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKSTART, weekStartEl.value));
weekEndEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKEND, weekEndEl.value));
divisorEl.addEventListener('change', () => {
  divisor = parseInt(divisorEl.value, 10) || 1;
  localStorage.setItem(LS_DIVISOR, String(divisor));
  // Sync the Deductions tab divisor select if it exists
  if (typeof divisorDedsEl !== 'undefined' && divisorDedsEl) {
    divisorDedsEl.value = String(divisor);
  }
  calculateAll();
});
function loadEmployees() {
  const stored = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
  let list = Object.keys(stored).map(id=>({id, name: stored[id]?.name || ''}));
  if (list.length === 0) list = [{id:'001', name:'Sample Employee'}];
  list.sort((a,b)=> (a.name||'').localeCompare(b.name||''));
  return list;
}
const employeeList = loadEmployees();
function getSssTable(){
  let arr = [];
  try { arr = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]'); }
  catch(e){ arr = []; }
  if (!Array.isArray(arr)) arr = [];
  arr = arr.map(r=>{
    const min = Number(r && typeof r.min !== 'undefined' ? r.min : 0) || 0;
    const max = Number(r && typeof r.max !== 'undefined' ? r.max : 0) || 0;
    const employee = Number(r && typeof r.employee !== 'undefined' ? r.employee : 0) || 0;
    const employerRaw = Number(r && typeof r.employer !== 'undefined' ? r.employer : employee);
    const employer = Number.isFinite(employerRaw) ? employerRaw : employee;
    return {min, max, employee, employer};
  }).sort((a,b)=> a.min - b.min);
  return arr;
}
function setSssTable(rows){
  const clean = Array.isArray(rows) ? rows.map(r => {
    const min = Number(r && typeof r.min !== 'undefined' ? r.min : 0) || 0;
    const max = Number(r && typeof r.max !== 'undefined' ? r.max : 0) || 0;
    const employee = Number(r && typeof r.employee !== 'undefined' ? r.employee : 0) || 0;
    const employerRaw = Number(r && typeof r.employer !== 'undefined' ? r.employer : employee);
    const employer = Number.isFinite(employerRaw) ? employerRaw : employee;
    return { min, max, employee, employer };
  }) : [];
  localStorage.setItem(LS_SSS_TABLE, JSON.stringify(clean));
}

function formatDeductionDisplay(value){
  const num = Number(value);
  if (!Number.isFinite(num)) return '-';
  if (Math.abs(num) < 0.005) return '-';
  return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

function roundToCents(value){
  const num = Number(value);
  if (!Number.isFinite(num)) return 0;
  return Math.round(num * 100) / 100;
}

function formatDeductionInputValue(value){
  const num = Number(value);
  if (!Number.isFinite(num)) return '';
  const rounded = roundToCents(num);
  return Math.abs(rounded) < 0.005 ? '' : rounded.toFixed(2);
}

function splitAdjustmentValue(value){
  const rounded = roundToCents(value);
  const positive = rounded > 0 ? +rounded.toFixed(2) : 0;
  const deduction = rounded < 0 ? +(-rounded).toFixed(2) : 0;
  return { raw: rounded, positive, deduction };
}

const DEDUCTION_COLUMN_KEYS = ['pagibig','philhealth','sss','loanSSS','loanPI','vale','adjustments','valeWed','total'];
const DEDUCTION_EDITABLE_KEYS = new Set(['loanSSS','loanPI','vale','adjustments','valeWed']);
const DEDUCTION_DATASET_SUFFIX = {
  pagibig: 'Pagibig',
  philhealth: 'Philhealth',
  sss: 'Sss',
  loanSSS: 'LoanSss',
  loanPI: 'LoanPi',
  vale: 'Vale',
  adjustments: 'Adjustments',
  valeWed: 'ValeWed',
  total: 'Total'
};
const DEDUCTION_COLUMN_KEY_SET = new Set(DEDUCTION_COLUMN_KEYS);
const LS_DEDUCTION_COLUMN_VISIBILITY = 'deductionColumnVisibility';
const DEDUCTION_DEFAULT_PERIOD_KEY = '__default';
const DEDUCTION_INCLUDE_ALL_FLAG = '__includeAll';

function sanitizeDeductionVisibilityObject(obj){
  const clean = {};
  if (!obj || typeof obj !== 'object') return clean;
  const includeAllExplicit = obj && obj[DEDUCTION_INCLUDE_ALL_FLAG] === true;
  let hasExplicitFalse = false;
  DEDUCTION_COLUMN_KEYS.forEach(function(key){
    if (obj[key] === false) {
      clean[key] = false;
      hasExplicitFalse = true;
    }
  });
  if (!hasExplicitFalse && includeAllExplicit) {
    clean[DEDUCTION_INCLUDE_ALL_FLAG] = true;
  }
  return clean;
}

function normalizeDeductionPeriodKey(rawKey){
  if (typeof rawKey !== 'string') return DEDUCTION_DEFAULT_PERIOD_KEY;
  const trimmed = rawKey.trim();
  if (!trimmed || trimmed === '_') return DEDUCTION_DEFAULT_PERIOD_KEY;
  return trimmed;
}

function activeDeductionPeriodKey(){
  const raw = (typeof currentPeriodKey === 'string' && currentPeriodKey) ? currentPeriodKey : '';
  const fallback = (typeof periodKey === 'function') ? periodKey() : '';
  return normalizeDeductionPeriodKey(raw || fallback || '');
}

function getStoredDeductionInclusionsForPeriod(period){
  const key = normalizeDeductionPeriodKey(period);
  if (deductionColumnVisibilityByPeriod[key]) {
    return Object.assign({}, deductionColumnVisibilityByPeriod[key]);
  }
  if (key !== DEDUCTION_DEFAULT_PERIOD_KEY && deductionColumnVisibilityByPeriod[DEDUCTION_DEFAULT_PERIOD_KEY]){
    return Object.assign({}, deductionColumnVisibilityByPeriod[DEDUCTION_DEFAULT_PERIOD_KEY]);
  }
  return {};
}

let deductionColumnVisibilityByPeriod = {};
try {
  const stored = localStorage.getItem(LS_DEDUCTION_COLUMN_VISIBILITY);
  if (stored) {
    const parsed = JSON.parse(stored);
    if (parsed && typeof parsed === 'object') {
      const keys = Object.keys(parsed);
      const legacyFormat = keys.some(key => DEDUCTION_COLUMN_KEY_SET.has(key));
      if (legacyFormat) {
        const legacy = sanitizeDeductionVisibilityObject(parsed);
        if (Object.keys(legacy).length > 0) {
          deductionColumnVisibilityByPeriod[DEDUCTION_DEFAULT_PERIOD_KEY] = legacy;
        }
      } else {
        keys.forEach(function(key){
          const clean = sanitizeDeductionVisibilityObject(parsed[key]);
          if (Object.keys(clean).length > 0) {
            deductionColumnVisibilityByPeriod[normalizeDeductionPeriodKey(key)] = clean;
          }
        });
      }
    }
  }
} catch (err) { deductionColumnVisibilityByPeriod = {}; }

let deductionColumnInclusions = getStoredDeductionInclusionsForPeriod(activeDeductionPeriodKey());

function refreshCurrentDeductionColumnInclusions(){
  deductionColumnInclusions = getStoredDeductionInclusionsForPeriod(activeDeductionPeriodKey());
}

function isDeductionColumnIncluded(key){
  if (!key) return true;
  return !deductionColumnInclusions || deductionColumnInclusions[key] !== false;
}

function persistDeductionColumnInclusions(){
  try {
    const periodKeyForStore = activeDeductionPeriodKey();
    let cleanCurrent = sanitizeDeductionVisibilityObject(deductionColumnInclusions);
    const keys = Object.keys(cleanCurrent);
    const hasColumnOverrides = keys.some(function(key){ return key !== DEDUCTION_INCLUDE_ALL_FLAG; });

    if (!hasColumnOverrides && periodKeyForStore !== DEDUCTION_DEFAULT_PERIOD_KEY) {
      cleanCurrent = { [DEDUCTION_INCLUDE_ALL_FLAG]: true };
    }

    deductionColumnInclusions = Object.assign({}, cleanCurrent);

    if (Object.keys(cleanCurrent).length === 0) {
      delete deductionColumnVisibilityByPeriod[periodKeyForStore];
    } else {
      deductionColumnVisibilityByPeriod[periodKeyForStore] = Object.assign({}, cleanCurrent);
    }
    const payload = {};
    Object.keys(deductionColumnVisibilityByPeriod).forEach(function(key){
      const clean = sanitizeDeductionVisibilityObject(deductionColumnVisibilityByPeriod[key]);
      if (Object.keys(clean).length > 0) {
        payload[key] = clean;
      }
    });
    if (Object.keys(payload).length === 0) {
      localStorage.removeItem(LS_DEDUCTION_COLUMN_VISIBILITY);
    } else {
      localStorage.setItem(LS_DEDUCTION_COLUMN_VISIBILITY, JSON.stringify(payload));
    }
  } catch (err) {}
}

function computeEffectiveDeductionValues(rawValues){
  const effective = {};
  let runningTotal = 0;
  DEDUCTION_COLUMN_KEYS.forEach(function(key){
    if (key === 'total') return;
    const rawSource = rawValues && Object.prototype.hasOwnProperty.call(rawValues, key) ? Number(rawValues[key]) : 0;
    const raw = Number.isFinite(rawSource) ? roundToCents(rawSource) : 0;
    const include = isDeductionColumnIncluded(key);
    const value = include ? raw : 0;
    effective[key] = value;
    runningTotal += value;
  });
  const includeTotal = isDeductionColumnIncluded('total');
  effective.total = includeTotal ? roundToCents(runningTotal) : 0;
  return effective;
}

function deductionDatasetKey(key, type){
  if (!key || !DEDUCTION_DATASET_SUFFIX[key]) return null;
  const suffix = DEDUCTION_DATASET_SUFFIX[key];
  const normalized = (type === 'raw') ? 'Raw' : 'Effective';
  return `deduction${suffix}${normalized}`;
}

function setRowDeductionDataset(tr, key, rawVal, effectiveVal){
  if (!tr) return;
  const rawKey = deductionDatasetKey(key, 'raw');
  const effectiveKey = deductionDatasetKey(key, 'effective');
  if (!rawKey || !effectiveKey) return;
  try {
    tr.dataset[rawKey] = rawVal;
    tr.dataset[effectiveKey] = effectiveVal;
  } catch (_) {}
}

function readRowDeductionDataset(tr, key, type){
  if (!tr || !tr.dataset) return null;
  const dataKey = deductionDatasetKey(key, type);
  if (!dataKey) return null;
  const value = tr.dataset[dataKey];
  return value == null ? null : value;
}

function updateDeductionCellDisplay(cell, raw, effective, included){
  if (!cell) return;
  const cleanRaw = Number.isFinite(raw) ? roundToCents(raw) : 0;
  const cleanEffective = Number.isFinite(effective) ? roundToCents(effective) : 0;
  cell.setAttribute('data-raw', cleanRaw);
  cell.setAttribute('data-effective', cleanEffective);
  const input = cell.querySelector('input.deduction-input');
  if (!input) {
    if (cell.tagName === 'TD' || cell.tagName === 'TH') {
      cell.textContent = formatDeductionDisplay(cleanEffective);
    }
    if (!included && Math.abs(cleanRaw) > 0.004) {
      cell.classList.add('deduction-excluded');
      cell.setAttribute('title', `Excluded (was ${cleanRaw.toFixed(2)})`);
    } else {
      cell.classList.remove('deduction-excluded');
      cell.removeAttribute('title');
    }
    return;
  }
  try {
    input.dataset.effectiveValue = cleanEffective.toFixed(2);
    input.dataset.perPeriodValue = cleanRaw.toFixed(2);
  } catch (_) {}
  if (input) {
    if (!included) {
      try { input.disabled = true; } catch (_) {}
      input.setAttribute('aria-disabled', 'true');
      input.tabIndex = -1;
    } else {
      try { input.disabled = false; } catch (_) {}
      input.removeAttribute('aria-disabled');
      input.tabIndex = 0;
    }
  }

  if (!included && Math.abs(cleanRaw) > 0.004) {
    cell.classList.add('deduction-excluded');
    cell.setAttribute('title', `Excluded (was ${cleanRaw.toFixed(2)})`);
    input.classList.add('deduction-excluded');
    input.setAttribute('title', `Excluded (was ${cleanRaw.toFixed(2)})`);
  } else {
    cell.classList.remove('deduction-excluded');
    cell.removeAttribute('title');
    input.classList.remove('deduction-excluded');
    input.removeAttribute('title');
  }
}

function applyDeductionColumnState(){
  try { refreshCurrentDeductionColumnInclusions(); } catch(_){ }
  const toggles = document.querySelectorAll('#deductionColumnToggles input[data-col]');
  toggles.forEach(function(input){
    const col = input.getAttribute('data-col');
    if (!col) return;
    input.checked = isDeductionColumnIncluded(col);
  });

  const table = document.getElementById('deductionsTable');
  if (!table) return;

  const rows = table.querySelectorAll('tbody tr, tfoot tr');
  rows.forEach(function(tr){
    const rawValues = {};
    DEDUCTION_COLUMN_KEYS.forEach(function(key){
      if (key === 'total') return;
      const cell = tr.querySelector(`[data-col="${key}"]`);
      if (!cell) { rawValues[key] = 0; return; }
      let raw = Number(cell.getAttribute('data-raw'));
      if (!Number.isFinite(raw)) {
        raw = Number(cell.dataset.rawValue);
      }
      if (!Number.isFinite(raw)) {
        const parsed = parseFloat((cell.textContent || '').replace(/,/g,''));
        raw = Number.isFinite(parsed) ? parsed : 0;
      }
      rawValues[key] = roundToCents(raw);
    });
    const rawTotal = Object.keys(rawValues).reduce(function(sum, key){ return sum + (key === 'total' ? 0 : Number(rawValues[key]) || 0); }, 0);
    rawValues.total = roundToCents(rawTotal);
    const effectiveValues = computeEffectiveDeductionValues(rawValues);
    DEDUCTION_COLUMN_KEYS.forEach(function(key){
      const cell = tr.querySelector(`[data-col="${key}"]`);
      if (!cell) return;
      const raw = roundToCents(Number(rawValues[key]) || 0);
      const effective = roundToCents(Number(effectiveValues[key]) || 0);
      updateDeductionCellDisplay(cell, raw, effective, isDeductionColumnIncluded(key));
    });
  });
}

function renderDeductionsTable(){
  syncPeriodScopedData();
  const dtbody = document.querySelector('#deductionsTable tbody');
  if (!dtbody) return;
  dtbody.innerHTML = '';
  employeeList.forEach(emp => {
    const rH = Number(regHours[emp.id] ?? 0);
    const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
    payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
    const lSSS = roundToCents(loanSSS[emp.id] ?? 0);
    const lPI = roundToCents(loanPI[emp.id] ?? 0);
    const v = roundToCents(vale[emp.id] ?? 0);
    const vW = roundToCents(valeWed[emp.id] ?? 0);
    const rawAdjustment = roundToCents(adjustments[emp.id] ?? 0);
    const adjParts = splitAdjustmentValue(rawAdjustment);
    const adjDeduction = adjParts.deduction;
    const regPay = +(rH * rate).toFixed(2);
    // Use dynamic contribution tables for Pag-IBIG and PhilHealth.  Determine the
    // applicable rate based on monthly income and multiply by regular pay.
    const monthly = rate * 8 * 24;
    const piRate = pagibigRateByMonthly(monthly);
    const phRate = philhealthRateByMonthly(monthly);
    const flags = (typeof contribFlags !== 'undefined' && contribFlags[emp.id]) || {};
    const div = Number(divisor) || 1;
    const pagibig = (flags.pagibig === false) ? 0 : +((regPay * piRate).toFixed(2));
    const philhealth = (flags.philhealth === false) ? 0 : +((regPay * phRate).toFixed(2));
    const sssFull = (flags.sss === false) ? 0 : sssShareByMonthly(monthly);
    const sss = (flags.sss === false) ? 0 : +((sssFull / div).toFixed(2));
    const sssLoan = +(lSSS / div).toFixed(2);
    const piLoan = +(lPI / div).toFixed(2);
    const rowRaw = {
      pagibig,
      philhealth,
      sss,
      loanSSS: sssLoan,
      loanPI: piLoan,
      vale: v,
      adjustments: adjDeduction,
      valeWed: vW
    };
    rowRaw.total = roundToCents(pagibig + philhealth + sss + sssLoan + piLoan + v + vW + adjDeduction);
    const rowEffective = computeEffectiveDeductionValues(rowRaw);
    const editableRawValues = {
      loanSSS: lSSS,
      loanPI: lPI,
      vale: v,
      adjustments: adjDeduction,
      valeWed: vW
    };
    const tr = document.createElement('tr');
    const idCell = document.createElement('td');
    idCell.setAttribute('data-col', 'id');
    idCell.textContent = emp.id;
    tr.appendChild(idCell);
    const nameCell = document.createElement('td');
    nameCell.classList.add('wrap');
    nameCell.setAttribute('data-col', 'name');
    nameCell.textContent = emp.name;
    tr.appendChild(nameCell);
    DEDUCTION_COLUMN_KEYS.forEach(function(key){
      const td = document.createElement('td');
      td.classList.add('num');
      td.setAttribute('data-col', key);
      const raw = Object.prototype.hasOwnProperty.call(rowRaw, key) ? rowRaw[key] : 0;
      const effective = Object.prototype.hasOwnProperty.call(rowEffective, key) ? rowEffective[key] : 0;
      if (DEDUCTION_EDITABLE_KEYS.has(key)) {
        td.classList.add('editable-deduction');
        const input = document.createElement('input');
        input.type = 'number';
        input.step = '0.01';
        input.min = '0';
        input.classList.add('deduction-input');
        input.dataset.empId = emp.id;
        input.dataset.col = key;
        input.setAttribute('inputmode', 'decimal');
        let displayValue = Number(editableRawValues[key] || 0);
        if (!Number.isFinite(displayValue)) displayValue = 0;
        input.value = formatDeductionInputValue(displayValue);
        if (key === 'adjustments') {
          input.dataset.adjustmentRaw = rawAdjustment.toFixed(2);
          input.setAttribute('aria-label', `Adjustments deduction for ${emp.name}`);
        }
        td.appendChild(input);
        updateDeductionCellDisplay(td, raw, effective, isDeductionColumnIncluded(key));
      } else {
        updateDeductionCellDisplay(td, raw, effective, isDeductionColumnIncluded(key));
      }
      tr.appendChild(td);
    });
    dtbody.appendChild(tr);
  });
  applyDeductionColumnState();
}
document.addEventListener('DOMContentLoaded', function(){
  try {
    applyDeductionColumnState();
  } catch (err) {}
  try {
    const toggles = document.getElementById('deductionColumnToggles');
    if (toggles && !toggles.__boundColumnToggle){
      toggles.addEventListener('change', function(ev){
        const input = ev.target;
        if (!input || !input.matches('input[data-col]')) return;
        const col = input.getAttribute('data-col');
        if (!col || DEDUCTION_COLUMN_KEYS.indexOf(col) === -1) return;
        if (input.checked) {
          delete deductionColumnInclusions[col];
        } else {
          deductionColumnInclusions[col] = false;
        }
        persistDeductionColumnInclusions();
        applyDeductionColumnState();
        try {
          document.querySelectorAll('#payrollTable tbody tr').forEach(function(tr){
            try { calculateRow(tr); } catch (calcErr) {}
          });
        } catch (calcWrapErr) {}
        try {
          (window.scheduleTotals || function(){ try { updatePayrollGrandTotals(); updateDeductionsGrandTotals(); } catch (_) {} })();
        } catch (totErr) {
          try { updatePayrollGrandTotals(); } catch (innerErr) {}
          try { updateDeductionsGrandTotals(); } catch (innerErr2) {}
        }
      });
      toggles.__boundColumnToggle = true;
    }
  } catch (err) {}
});

function findPayrollRowById(empId){
  const rows = document.querySelectorAll('#payrollTable tbody tr');
  for (const tr of rows){
    const firstCell = tr.cells && tr.cells[0];
    if (firstCell && firstCell.textContent && firstCell.textContent.trim() === empId) {
      return tr;
    }
  }
  return null;
}

function syncPayrollRowFromDeduction(empId){
  const row = findPayrollRowById(empId);
  if (!row) { return; }
  const setValue = (selector, value) => {
    const el = row.querySelector(selector);
    if (el && typeof el.value !== 'undefined') {
      el.value = roundToCents(value || 0).toFixed(2);
    }
  };
  setValue('.loanSSS', loanSSS?.[empId] ?? 0);
  setValue('.loanPI', loanPI?.[empId] ?? 0);
  setValue('.vale', vale?.[empId] ?? 0);
  setValue('.valeWed', valeWed?.[empId] ?? 0);
  try { calculateRow(row); } catch (_) {}
}

function findDeductionRowById(empId){
  const table = document.getElementById('deductionsTable');
  if (!table) return null;
  const rows = table.querySelectorAll('tbody tr');
  for (const tr of rows) {
    const idCell = tr.querySelector('[data-col="id"]');
    if (idCell && idCell.textContent && idCell.textContent.trim() === empId) {
      return tr;
    }
  }
  return null;
}

function updateDeductionRowDisplay(empId){
  const tr = findDeductionRowById(empId);
  if (!tr) return;
  const emp = employeeList.find(e => e.id === empId) || { id: empId };
  const empKey = emp.id || empId;
  const stored = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};
  let rate = Number((stored[empKey]?.hourlyRate) ?? (payrollRates?.[empKey] ?? 0));
  if (!Number.isFinite(rate)) rate = 0;
  try { if (payrollRates && typeof payrollRates === 'object') payrollRates[empKey] = rate; } catch (_) {}
  const rH = Number(regHours?.[empKey] ?? 0);
  const lSSS = roundToCents(loanSSS?.[empKey] ?? 0);
  const lPI = roundToCents(loanPI?.[empKey] ?? 0);
  const v = roundToCents(vale?.[empKey] ?? 0);
  const vW = roundToCents(valeWed?.[empKey] ?? 0);
  const rawAdjustment = roundToCents(adjustments?.[empKey] ?? 0);
  const adjParts = splitAdjustmentValue(rawAdjustment);
  const adjDeduction = adjParts.deduction;
  const regPay = +(rH * rate).toFixed(2);
  const monthly = rate * 8 * 24;
  const piRate = pagibigRateByMonthly(monthly);
  const phRate = philhealthRateByMonthly(monthly);
  const flags = (typeof contribFlags !== 'undefined' && contribFlags && contribFlags[empKey]) || {};
  const div = Number(divisor) || 1;
  const pagibig = (flags.pagibig === false) ? 0 : +((regPay * piRate).toFixed(2));
  const philhealth = (flags.philhealth === false) ? 0 : +((regPay * phRate).toFixed(2));
  const sssFull = (flags.sss === false) ? 0 : sssShareByMonthly(monthly);
  const sss = (flags.sss === false) ? 0 : +((sssFull / div).toFixed(2));
  const sssLoan = +(lSSS / div).toFixed(2);
  const piLoan = +(lPI / div).toFixed(2);
  const rowRaw = {
    pagibig,
    philhealth,
    sss,
    loanSSS: sssLoan,
    loanPI: piLoan,
    vale: v,
    adjustments: adjDeduction,
    valeWed: vW
  };
  rowRaw.total = roundToCents(pagibig + philhealth + sss + sssLoan + piLoan + v + vW + adjDeduction);
  const rowEffective = computeEffectiveDeductionValues(rowRaw);
  const editableRawValues = {
    loanSSS: lSSS,
    loanPI: lPI,
    vale: v,
    adjustments: adjDeduction,
    valeWed: vW
  };
  DEDUCTION_COLUMN_KEYS.forEach(function(key){
    const cell = tr.querySelector(`[data-col="${key}"]`);
    if (!cell) return;
    const rawVal = Object.prototype.hasOwnProperty.call(rowRaw, key) ? rowRaw[key] : 0;
    const effectiveVal = Object.prototype.hasOwnProperty.call(rowEffective, key) ? rowEffective[key] : 0;
    if (DEDUCTION_EDITABLE_KEYS.has(key)) {
      const input = cell.querySelector('input.deduction-input');
      if (input) {
        let displayValue = Number(editableRawValues[key] || 0);
        if (!Number.isFinite(displayValue)) displayValue = 0;
        input.value = formatDeductionInputValue(displayValue);
        if (key === 'adjustments') {
          try { input.dataset.adjustmentRaw = rawAdjustment.toFixed(2); } catch (_) {}
        }
      }
    }
    updateDeductionCellDisplay(cell, rawVal, effectiveVal, isDeductionColumnIncluded(key));
    try {
      const cleanRaw = roundToCents(rawVal || 0).toFixed(2);
      const cleanEffective = roundToCents(effectiveVal || 0).toFixed(2);
      setRowDeductionDataset(tr, key, cleanRaw, cleanEffective);
    } catch (_) {}
  });
}

document.addEventListener('change', async (event) => {
  const input = event.target;
  if (!input || !input.matches('.deduction-input')) return;
  syncPeriodScopedData();
  const empId = input.dataset.empId;
  const key = input.dataset.col;
  if (!empId || !key) return;
  let value = parseFloat(input.value);
  if (!Number.isFinite(value) || value < 0) value = 0;
  value = roundToCents(value);
  input.value = formatDeductionInputValue(value);
  let needsSave = false;
  let adjustmentsChanged = false;
  switch (key) {
    case 'loanSSS':
      loanSSS[empId] = value;
      needsSave = true;
      break;
    case 'loanPI':
      loanPI[empId] = value;
      needsSave = true;
      break;
    case 'vale':
      vale[empId] = value;
      needsSave = true;
      break;
    case 'valeWed':
      valeWed[empId] = value;
      needsSave = true;
      break;
    case 'adjustments':
      if (value > 0) {
        adjustments[empId] = -value;
      } else {
        delete adjustments[empId];
      }
      adjustmentsChanged = true;
      persistCurrentAdjustments();
      break;
    default:
      break;
  }
  if (needsSave) {
    try { await saveCurrentPeriodDeductions(); } catch (err) { console.warn('Failed to save deductions', err); }
  }
  syncPayrollRowFromDeduction(empId);
  if (adjustmentsChanged) {
    if (typeof renderAdjustmentsTable === 'function') {
      try { renderAdjustmentsTable(); } catch (_) {}
    } else if (typeof renderAdjustmentsFoot === 'function') {
      try { renderAdjustmentsFoot(); } catch (_) {}
    }
  }
  try { updateDeductionRowDisplay(empId); } catch (err) { console.warn('Failed to update deduction row', err); }
  try { (typeof scheduleTotals === 'function' ? scheduleTotals : updateDeductionsGrandTotals)(); } catch (_) {}
});
function renderTable(){
  syncPeriodScopedData();
  // Batch DOM updates to avoid MutationObserver thrash
  window.__suspendTotals = true;
  try {
    const frag = document.createDocumentFragment();
    tbody.innerHTML = '';
    employeeList.forEach(emp=>{
      const tr = document.createElement('tr');
      const rH = Number(regHours[emp.id] ?? 0);
      const oH = Number(otHours[emp.id] ?? 0);
      // Adjustment hours for this employee (default to 0 if undefined)
      const aH = Number(adjHrs[emp.id] ?? 0);
      const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
      payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
      const lSSS = Number(loanSSS[emp.id] ?? 0);
      const lPI = Number(loanPI[emp.id] ?? 0);
      const v = Number(vale[emp.id] ?? 0);
      const vW = Number(valeWed[emp.id] ?? 0);
      // Load stored Bantay allowance for this employee or default to empty string
      const bVal = bantay[emp.id] ?? '';
      tr.innerHTML = `
        <td>${emp.id}</td>
        <td class="wrap">${emp.name}</td>
        
        <td><input class="cell rate" title="Non-editable in Payroll" type="number" step="0.01" value="${rate}" disabled></td>
        <td><input class="cell regHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${rH}" disabled></td>
        <td><input class="cell otHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${oH}" disabled></td>
        <td class="adjHrs num">${aH ? aH.toFixed(2) : '0.00'}</td><td class="totalHrs num">0.00</td><td class="regPay num">0.00</td>
        <td class="otPay num">0.00</td>
        <td class="adjAmt num">0.00</td>
        <td><input class="cell bantay" type="number" step="0.01" value="${bVal}"></td>
        <td class="grossPay num">0.00</td>
        <td class="pagibig num">0.00</td>
        <td class="philhealth num">0.00</td>
        <td class="sss num">0.00</td>
        <td><input class="cell loanSSS" type="number" step="0.01" value="${lSSS}"></td>
        <td><input class="cell loanPI" type="number" step="0.01" value="${lPI}"></td>
        <td><input class="cell vale" type="number" step="0.01" value="${v}"></td>
        <td><input class="cell valeWed" type="number" step="0.01" value="${vW}"></td>
        <td class="totalDed num">0.00</td>
        <td class="netPay num">0.00</td>
        <td><button type="button" class="payslipBtn">Payslip</button></td>`;
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
    attachRowEvents();
    // Compute all rows in one pass without updating totals each mutation
    calculateAll();
  } finally {
    // Resume totals and request one totals update after batch render
    window.__suspendTotals = false;
    try { (window.scheduleTotals || window.updatePayrollGrandTotals || function(){})(); } catch(e){}
    try { (window.scheduleTotals || window.updateDeductionsGrandTotals || function(){})(); } catch(e){}
  }
}



// Quick project picker for Bantay assignment (Supabase-backed) â€“ compact dropdown
// Shows only project names, auto-saves on selection, then closes.
function chooseBantayProject(empId, anchorEl){
  try{
    // Remove any existing picker first
    const old = document.getElementById('bantayProjPicker');
    if (old) old.remove();

    // Build overlay container
    const box = document.createElement('div');
    box.id = 'bantayProjPicker';
    box.style.position = 'absolute';
    box.style.zIndex = '99999';
    box.style.background = '#ffffff';
    box.style.border = '1px solid #e5e7eb';
    box.style.borderRadius = '8px';
    box.style.boxShadow = '0 8px 24px rgba(0,0,0,0.12)';
    box.style.padding = '6px';
    box.style.display = 'flex';
    box.style.gap = '6px';
    box.style.alignItems = 'center';

    // Position near the input
    const rect = (anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {left:100, top:100, width:0, height:0};
    const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
    const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
    box.style.left = (rect.left + scrollX) + 'px';
    box.style.top  = (rect.top  + scrollY + rect.height + 6) + 'px';

    // Build <select> with project options (compact)
    const sel = document.createElement('select');
    sel.style.minWidth = '160px';
    sel.style.padding = '4px';
    sel.style.border = '1px solid #d1d5db';
    sel.style.borderRadius = '6px';

    // Placeholder + clear option
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = 'Select project';
    sel.appendChild(opt0);
    const optClear = document.createElement('option');
    optClear.value = '__clear__';
    optClear.textContent = '— Clear assignment —';
    sel.appendChild(optClear);

    // storedProjects: { [pid]: {name, ...} }
    const entries = Object.entries(storedProjects || {}).sort((a,b)=>{
      const A = (a[1]?.name || a[0]).toUpperCase();
      const B = (b[1]?.name || b[0]).toUpperCase();
      return A.localeCompare(B);
    });
    entries.forEach(([pid, proj])=>{
      const o = document.createElement('option');
      o.value = pid;
      o.textContent = (proj?.name || pid);
      sel.appendChild(o);
    });

    // Set current value if any (default to project id key)
    try { sel.value = (bantayProj && bantayProj[empId]) || ''; } catch(e){}

    box.appendChild(sel);
    document.body.appendChild(box);

    const close = ()=>{ try{ box.remove(); }catch(e){} };

    // Auto-save on selection and close; refresh report if available
    sel.addEventListener('change', async ()=>{
      const v = sel.value;
      bantayProj = bantayProj || {};
      if (!v || v === '__clear__'){
        // Clear assignment
        try { delete bantayProj[empId]; } catch(e){}
        try { await window.writeKV(LS_BANTAY_PROJ, bantayProj); } catch(e){}
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
        close();
        return;
      }
      if (storedProjects && storedProjects[v]){
        bantayProj[empId] = v;
        try { await window.writeKV(LS_BANTAY_PROJ, bantayProj); } catch(e){}
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
      }
      close();
    });

    // Close on outside click
    setTimeout(()=>{
      const handler = (e)=>{
        if (!box.contains(e.target)) {
          document.removeEventListener('mousedown', handler, true);
          close();
        }
      };
      document.addEventListener('mousedown', handler, true);
    }, 0);

  }catch(e){
    console.warn('chooseBantayProject failed', e);
  }
}
function attachRowEvents(){
  tbody.querySelectorAll('tr').forEach(row=>{
    const id = row.cells[0].textContent.trim();
    const regI = row.querySelector('.regHrs');
    const otI = row.querySelector('.otHrs');
    const rateI = row.querySelector('.rate');
    const lSSSI = row.querySelector('.loanSSS');
    const lPII = row.querySelector('.loanPI');
    const vI = row.querySelector('.vale');
    const vWI = row.querySelector('.valeWed');
    const watchedInputs = [regI, otI, rateI, lSSSI, lPII, vI];
    if (vWI && typeof vWI.value !== 'undefined') watchedInputs.push(vWI);
    watchedInputs.forEach(inp=>{
      if (!inp || typeof inp.addEventListener !== 'function') return;
      inp.addEventListener('input', ()=>{
        regHours[id] = +(Number(regI.value)||0).toFixed(2);
        otHours[id] = +(Number(otI.value)||0).toFixed(2);
        payrollRates[id] = +(Number(rateI.value)||0).toFixed(2);
        loanSSS[id] = +(Number(lSSSI.value)||0).toFixed(2);
        loanPI[id] = +(Number(lPII.value)||0).toFixed(2);
        vale[id] = +(Number(vI.value)||0).toFixed(2);
        if (vWI && typeof vWI.value !== 'undefined') {
          valeWed[id] = +(Number(vWI.value)||0).toFixed(2);
        }
        localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
        localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
        localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
        saveCurrentPeriodDeductions();
        if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
        calculateRow(row);
      });
    });

    // Add event listener for Bantay allowance input. Store to cloud and recalc net pay.
    const bantayI = row.querySelector('.bantay');
      if (bantayI) {
        bantayI.addEventListener('input', async () => {
        bantay[id] = bantayI.value;
        allBantay[currentPeriodKey] = bantay;
        try { localStorage.setItem(LS_BANTAY, JSON.stringify(allBantay)); } catch(_){ }
        await window.writeKV(LS_BANTAY, allBantay);
        calculateRow(row);
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
        // Auto-open project picker when entering a positive amount and no assignment yet
        const val = parseFloat(bantayI.value) || 0;
        const hasPicker = !!document.getElementById('bantayProjPicker');
        if (val > 0 && !bantayProj[id] && !hasPicker) {
          chooseBantayProject(id, bantayI);
        }
        // Auto-clear assignment when reset to zero or blank
        if (!(val > 0) && bantayProj[id]) {
          try { delete bantayProj[id]; } catch(_){ }
          try { await window.writeKV(LS_BANTAY_PROJ, bantayProj); } catch(_){ }
          try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(_){ }
        }
      });
      // Also prompt on change if user typed and then blurs
      bantayI.addEventListener('change', () => {
        const val = parseFloat(bantayI.value) || 0;
        if (val > 0) chooseBantayProject(id, bantayI);
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
      });
      // Allow quick reassign on dblclick
      bantayI.title = 'Double-click to assign Bantay to a project';
      bantayI.addEventListener('dblclick', () => chooseBantayProject(id, bantayI));
    }
  });
}
function renderSssTable(){
  const tbodyS = document.querySelector('#sssTable tbody');
  tbodyS.innerHTML='';
  const rows = getSssTable();
  rows.forEach((r, i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell sssMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell sssMax" value="${r.max}"></td>
      <td><input type="number" step="0.01" class="cell sssEmp" value="${r.employee}"></td>
      <td><input type="number" step="0.01" class="cell sssEr" value="${r.employer}"></td>
      <td><button class="delRow">Delete</button></td>`;
    tbodyS.appendChild(tr);
    const minI = tr.querySelector('.sssMin');
    const maxI = tr.querySelector('.sssMax');
    const empI = tr.querySelector('.sssEmp');
    const erI = tr.querySelector('.sssEr');
    minI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI, erI); });
    maxI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI, erI); });
    empI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI, erI); });
    if (erI) erI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI, erI); });
    tr.querySelector('.delRow').addEventListener('click', ()=>{
      const cur = getSssTable();
      cur.splice(i,1);
      setSssTable(cur);
      renderSssTable();
      calculateAll();
    });
  });
}
function updateRow(i, minI, maxI, empI, erI){
  const cur = getSssTable();
  const minVal = Number(minI && typeof minI.value !== 'undefined' ? minI.value : 0) || 0;
  const maxVal = Number(maxI && typeof maxI.value !== 'undefined' ? maxI.value : 0) || 0;
  const employeeVal = Number(empI && typeof empI.value !== 'undefined' ? empI.value : 0) || 0;
  let employerVal = Number(erI && typeof erI.value !== 'undefined' ? erI.value : employeeVal);
  if (!Number.isFinite(employerVal)) employerVal = employeeVal;
  cur[i] = {min:minVal, max:maxVal, employee:employeeVal, employer:employerVal};
  setSssTable(cur);
  calculateAll();
}

document.getElementById('addSssRow').addEventListener('click', ()=>{
  const cur = getSssTable(); cur.push({min:0,max:0,employee:0, employer:0}); setSssTable(cur); renderSssTable();
});
document.getElementById('resetSss').addEventListener('click', ()=>{
  if(confirm('Reset SSS table to 2025 defaults?')){
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2], employer: (typeof r[3] !== 'undefined' ? r[3] : r[2])}));
    setSssTable(mapped);
    renderSssTable();
    calculateAll();
  }
});
document.getElementById('clearSss').addEventListener('click', ()=>{
  if(confirm('Clear all SSS ranges?')){ setSssTable([]); renderSssTable(); calculateAll(); }
});
document.getElementById('exportSss').addEventListener('click', ()=>{
  const rows = getSssTable();
  const csv = ['min,max,employeeShare,employerShare'].concat(rows.map(r=>[r.min,r.max,r.employee,r.employer].join(','))).join('\n');
  const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='sss_table.csv'; document.body.appendChild(a); a.click(); a.remove();
});
document.getElementById('importSss').addEventListener('change', ev=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = e=>{
    const text = e.target.result;
    const lines = text.split(/\r?\n/).filter(Boolean);
    const out=[];
    for(let i=0;i<lines.length;i++){ const line = lines[i].trim();
      if(i===0 && /min/i.test(line) && /max/i.test(line)) continue;
      const p = line.split(',');
      if(p.length>=3) {
        const min = Number(p[0])||0;
        const max = Number(p[1])||0;
        const employee = Number(p[2])||0;
        let employer = NaN;
        if (p.length >= 4) {
          const parsed = Number(p[3]);
          if (Number.isFinite(parsed)) employer = parsed;
        }
        if (!Number.isFinite(employer)) employer = employee;
        out.push({min, max, employee, employer});
      }
    }
    setSssTable(out); renderSssTable(); calculateAll();
  };
  reader.readAsText(f);
});

// === Begin Pagâ€‘IBIG and PhilHealth Table Management ===
// Pagâ€‘IBIG dynamic table helpers.  Defines helper functions for retrieving and
// setting the table in localStorage, rendering the table in the UI, and applying
// the employee share rate based on income ranges.
function getPagibigTable(){
  let arr = [];
  try {
    arr = JSON.parse(localStorage.getItem(LS_PAGIBIG_TABLE) || '[]');
  } catch(e) { arr = []; }
  if (!Array.isArray(arr)) arr = [];
  return arr.map(r => ({
    min: Number(r.min) || 0,
    max: Number(r.max) || 0,
    rate: Number(r.rate) || 0
  })).sort((a,b) => a.min - b.min);
}
function setPagibigTable(rows){
  localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(rows));
}
function renderPagibigTable(){
  const tbodyP = document.querySelector('#pagibigTable tbody');
  if(!tbodyP) return;
  tbodyP.innerHTML = '';
  const rows = getPagibigTable();
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell pagibigMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell pagibigMax" value="${r.max}"></td>
      <td><input type="number" step="0.0001" class="cell pagibigRate" value="${r.rate}"></td>
      <td><button class="delPagibigRow">Delete</button></td>`;
    tbodyP.appendChild(tr);
    const minI = tr.querySelector('.pagibigMin');
    const maxI = tr.querySelector('.pagibigMax');
    const rateI = tr.querySelector('.pagibigRate');
    function update(i){
      const cur = getPagibigTable();
      cur[i] = {min: Number(minI.value) || 0, max: Number(maxI.value) || 0, rate: Number(rateI.value) || 0};
      setPagibigTable(cur);
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
    minI.addEventListener('input', () => update(idx));
    maxI.addEventListener('input', () => update(idx));
    rateI.addEventListener('input', () => update(idx));
    tr.querySelector('.delPagibigRow').addEventListener('click', () => {
      const cur = getPagibigTable();
      cur.splice(idx, 1);
      setPagibigTable(cur);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    });
  });
}
function getPhilhealthTable(){
  let arr = [];
  try {
    arr = JSON.parse(localStorage.getItem(LS_PHILHEALTH_TABLE) || '[]');
  } catch(e) { arr = []; }
  if (!Array.isArray(arr)) arr = [];
  return arr.map(r => ({
    min: Number(r.min) || 0,
    max: Number(r.max) || 0,
    rate: Number(r.rate) || 0
  })).sort((a,b) => a.min - b.min);
}
function setPhilhealthTable(rows){
  localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(rows));
}
function renderPhilhealthTable(){
  const tbodyPh = document.querySelector('#philhealthTable tbody');
  if(!tbodyPh) return;
  tbodyPh.innerHTML = '';
  const rows = getPhilhealthTable();
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell philMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell philMax" value="${r.max}"></td>
      <td><input type="number" step="0.0001" class="cell philRate" value="${r.rate}"></td>
      <td><button class="delPhilRow">Delete</button></td>`;
    tbodyPh.appendChild(tr);
    const minI = tr.querySelector('.philMin');
    const maxI = tr.querySelector('.philMax');
    const rateI = tr.querySelector('.philRate');
    function update(i){
      const cur = getPhilhealthTable();
      cur[i] = {min: Number(minI.value) || 0, max: Number(maxI.value) || 0, rate: Number(rateI.value) || 0};
      setPhilhealthTable(cur);
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
    minI.addEventListener('input', () => update(idx));
    maxI.addEventListener('input', () => update(idx));
    rateI.addEventListener('input', () => update(idx));
    tr.querySelector('.delPhilRow').addEventListener('click', () => {
      const cur = getPhilhealthTable();
      cur.splice(idx, 1);
      setPhilhealthTable(cur);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    });
  });
}
// Click handler for adding, resetting and clearing rows in Pagâ€‘IBIG and PhilHealth tables.
document.addEventListener('click', (e) => {
  if (e.target && e.target.id === 'addPagibigRow') {
    const cur = getPagibigTable();
    cur.push({min: 0, max: 0, rate: 0});
    setPagibigTable(cur);
    renderPagibigTable();
    calculateAll();
    if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
  } else if (e.target && e.target.id === 'resetPagibig') {
    if (confirm('Reset Pag-IBIG table to defaults?')) {
      const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      setPagibigTable(mapped);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'clearPagibig') {
    if (confirm('Clear all Pag-IBIG ranges?')) {
      setPagibigTable([]);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'addPhilRow') {
    const cur = getPhilhealthTable();
    cur.push({min: 0, max: 0, rate: 0});
    setPhilhealthTable(cur);
    renderPhilhealthTable();
    calculateAll();
    if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
  } else if (e.target && e.target.id === 'resetPhil') {
    if (confirm('Reset PhilHealth table to defaults?')) {
      const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      setPhilhealthTable(mapped);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'clearPhil') {
    if (confirm('Clear all PhilHealth ranges?')) {
      setPhilhealthTable([]);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  }
});
// === End Pagâ€‘IBIG and PhilHealth Table Management ===
function sssShareByMonthly(monthly){
  const rows = getSssTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].employee)||0;
  for(const r of rows){ if(monthly >= r.min && monthly <= r.max) return Number(r.employee)||0; }
  return Number(rows[rows.length-1].employee)||0;
}

function sssEmployerShareByMonthly(monthly){
  const rows = getSssTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].employer ?? rows[0].employee) || 0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.employer ?? r.employee) || 0;
    }
  }
  const last = rows[rows.length-1];
  return Number(last.employer ?? last.employee) || 0;
}

// Determine Pagâ€‘IBIG contribution rate based on the monthly income.  Uses the
// editable Pagâ€‘IBIG table; returns a decimal rate (e.g. 0.02).  If no matching
// range is found, returns the last row's rate.
function pagibigRateByMonthly(monthly){
  const rows = getPagibigTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].rate)||0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.rate)||0;
    }
  }
  return Number(rows[rows.length-1].rate)||0;
}

// Determine PhilHealth contribution rate based on the monthly income.  Uses the
// editable PhilHealth table; returns a decimal rate.  If no matching range is found,
// returns the last row's rate.
function philhealthRateByMonthly(monthly){
  const rows = getPhilhealthTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].rate)||0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.rate)||0;
    }
  }
  return Number(rows[rows.length-1].rate)||0;
}

function calculateRow(tr){  const readNum = sel => { const el = tr.querySelector(sel); if (!el) return 0; const v = (typeof el.value !== 'undefined' ? el.value : el.textContent); const n = parseFloat(String(v).replace(/,/g,'')); return isNaN(n)?0:n; };
  const w = (sel, val) => { const el = tr.querySelector(sel); if (!el) return; el.textContent = (val===0 ? '-' : (+val).toFixed(2)); };


  const id = tr.cells[0].textContent.trim();
  const reg = Number(tr.querySelector('.regHrs').value)||0;
  const ot = Number(tr.querySelector('.otHrs').value)||0;
  // Adjustment hours from the adjHrs object (if any)
  const adjHours = Number(adjHrs[id] || 0);
  // Combined OT hours including adjustments
  const otTotal = ot + adjHours;
  const totalHrs = reg + ot + adjHours;
  const rate = Number(tr.querySelector('.rate').value)||0;
  const lSSS = Number(tr.querySelector('.loanSSS').value)||0;
  const lPI = Number(tr.querySelector('.loanPI').value)||0;
  const v = Number(tr.querySelector('.vale').value)||0;
  const vWEl = tr.querySelector('.valeWed');
  const vW = Number((vWEl && typeof vWEl.value !== 'undefined') ? vWEl.value : readNum('.valeWed'))||0;

  // Adjustment amount for this employee (may be positive or negative)
  const adjParts = splitAdjustmentValue(adjustments[id]);
  const adjRaw = adjParts.raw;
  const adjPositive = adjParts.positive;
  const adjDeduction = adjParts.deduction;
  // Bantay allowance (treated as positive allowance).  Parse numeric value from bantay input.
  const bVal = parseFloat((tr.querySelector('.bantay')?.value || '').trim()) || 0;

  const regPay = +(reg * rate).toFixed(2);
  tr.querySelector('.totalHrs').textContent = totalHrs.toFixed(2);
  const otPay = +(otTotal * rate * (Number(otMultiplier)||0)).toFixed(2);
  const gross = +(regPay + otPay + adjPositive + bVal).toFixed(2);
  // Compute contributions using dynamic tables (employee share).  Determine the
  // appropriate rate based on the monthly income and multiply by regular pay.
  const monthly = rate * 8 * 24;
  const piRate = pagibigRateByMonthly(monthly);
  const phRate = philhealthRateByMonthly(monthly);
  // Check per-employee contribution deduction flags; default to true if not set
  const flags = contribFlags[id] || {};
  const div = Number(divisor) || 1;
  const hasCompensation = (reg > 0) || (otTotal > 0) || (adjPositive > 0) || (bVal > 0);
  const pagibig = (hasCompensation && flags.pagibig !== false ? +((regPay * piRate)).toFixed(2) : 0);
  const philhealth = (hasCompensation && flags.philhealth !== false ? +((regPay * phRate)).toFixed(2) : 0);
  const sssFull = hasCompensation ? sssShareByMonthly(monthly) : 0;
  const sss = (hasCompensation && flags.sss !== false ? +(sssFull / div).toFixed(2) : 0);
  const sssLoan = +(lSSS / div).toFixed(2);
  const piLoan = +(lPI / div).toFixed(2);
  const valeAmt = v;
  const wedValeAmt = vW;

  const deductionRaw = {
    pagibig,
    philhealth,
    sss,
    loanSSS: sssLoan,
    loanPI: piLoan,
    vale: valeAmt,
    adjustments: adjDeduction,
    valeWed: wedValeAmt
  };
  deductionRaw.total = roundToCents(pagibig + philhealth + sss + sssLoan + piLoan + valeAmt + wedValeAmt + adjDeduction);
  const deductionEffective = computeEffectiveDeductionValues(deductionRaw);
  const total = deductionEffective.total;
  const net = gross - total;

  w('.regPay', regPay);
  w('.otPay', otPay);
  w('.grossPay', gross);
  const applyDeductionCell = (selector, key) => {
    const applied = roundToCents(deductionEffective[key] || 0);
    w(selector, applied);
    const cell = tr.querySelector(selector);
    if (!cell) return;
    const rawVal = roundToCents(deductionRaw[key] || 0);
    const rawStr = rawVal.toFixed(2);
    const appliedStr = applied.toFixed(2);
    try {
      cell.dataset.rawValue = rawStr;
      cell.dataset.effectiveValue = appliedStr;
    } catch (_) {}
    setRowDeductionDataset(tr, key, rawStr, appliedStr);
    const included = isDeductionColumnIncluded(key);
    if (!included && Math.abs(rawVal) > 0.004) {
      cell.classList.add('deduction-excluded');
      cell.setAttribute('title', `Excluded (was ${rawStr})`);
    } else {
      cell.classList.remove('deduction-excluded');
      cell.removeAttribute('title');
    }
  };
  const applyDeductionInput = (selector, key) => {
    const input = tr.querySelector(selector);
    if (!input) {
      const rawVal = roundToCents(deductionRaw[key] || 0).toFixed(2);
      const applied = roundToCents(deductionEffective[key] || 0).toFixed(2);
      setRowDeductionDataset(tr, key, rawVal, applied);
      return;
    }
    const rawVal = roundToCents(deductionRaw[key] || 0);
    const applied = roundToCents(deductionEffective[key] || 0);
    const rawStr = rawVal.toFixed(2);
    const appliedStr = applied.toFixed(2);
    try {
      input.dataset.rawValue = rawStr;
      input.dataset.effectiveValue = appliedStr;
    } catch (_) {}
    setRowDeductionDataset(tr, key, rawStr, appliedStr);
    const included = isDeductionColumnIncluded(key);
    if (!included && Math.abs(rawVal) > 0.004) {
      input.classList.add('deduction-excluded');
      input.setAttribute('title', `Excluded (was ${rawStr})`);
    } else {
      input.classList.remove('deduction-excluded');
      input.removeAttribute('title');
    }
  };
  applyDeductionCell('.pagibig', 'pagibig');
  applyDeductionCell('.philhealth', 'philhealth');
  applyDeductionCell('.sss', 'sss');
  applyDeductionCell('.totalDed', 'total');
  applyDeductionInput('.loanSSS', 'loanSSS');
  applyDeductionInput('.loanPI', 'loanPI');
  applyDeductionInput('.vale', 'vale');
  applyDeductionInput('.valeWed', 'valeWed');
  // Adjustments column is displayed as positive earnings; track deduction component separately.
  setRowDeductionDataset(
    tr,
    'adjustments',
    roundToCents(deductionRaw.adjustments || 0).toFixed(2),
    roundToCents(deductionEffective.adjustments || 0).toFixed(2)
  );
  // Populate adjustment cell (if exists) and net pay
  if (tr.querySelector('.adjAmt')) {
    w('.adjAmt', adjPositive);
  }
  try {
    tr.dataset.adjustmentRaw = adjRaw ? adjRaw.toFixed(2) : '0.00';
    tr.dataset.adjustmentPositive = adjPositive ? adjPositive.toFixed(2) : '0.00';
    tr.dataset.adjustmentDeduction = adjDeduction ? adjDeduction.toFixed(2) : '0.00';
  } catch (_) {}
  // Update the displayed adjustment hours cell if present
  const adjHrsCell = tr.querySelector('.adjHrs'); if (adjHrsCell) { adjHrsCell.textContent = (adjHours===0 ? '-' : adjHours.toFixed(2)); }
  w('.netPay', net);
}

function calculateAll(){
  syncPeriodScopedData();
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=> calculateRow(tr));
  renderDeductionsTable();
}

let adjustmentsRenderPending = false;
let adjustmentsFocusCount = 0;
const isAdjustmentInputFocused = () => adjustmentsFocusCount > 0;
const queueAdjustmentsRerender = () => {
  if (isAdjustmentInputFocused()) {
    adjustmentsRenderPending = true;
    return;
  }
  adjustmentsRenderPending = false;
  try { renderAdjustmentsTable(); } catch (_) {}
};
const adjustmentRefresh = (() => {
  let timer = null;
  const statusEl = () => document.getElementById('adjustmentSaveStatus');
  const run = () => {
    timer = null;
    try { renderAdjustmentsFoot(); } catch (_) {}
    calculateAll();
    const el = statusEl();
    if (el) {
      el.textContent = 'Saved locally';
      el.classList.remove('error');
      el.classList.add('saved');
    }
  };
  return {
    schedule(){
      try {
        const el = statusEl();
        if (el) {
          el.textContent = 'Updating…';
          el.classList.remove('error');
          el.classList.remove('saved');
        }
      } catch (_) {}
      if (timer) window.clearTimeout(timer);
      timer = window.setTimeout(run, 400);
    },
    flush(){
      if (timer) {
        window.clearTimeout(timer);
        run();
      } else {
        run();
      }
    }
  };
})();

function createDebouncedPersistence(persistFn, delay = 150) {
  let timer = null;
  const flush = () => {
    if (timer) {
      window.clearTimeout(timer);
      timer = null;
    }
    try { persistFn(); } catch (_) {}
  };
  return {
    schedule() {
      if (timer) window.clearTimeout(timer);
      timer = window.setTimeout(() => { timer = null; try { persistFn(); } catch (_) {} }, delay);
    },
    flush
  };
}
const adjustmentPersist = createDebouncedPersistence(persistCurrentAdjustments);
const adjustmentHoursPersist = createDebouncedPersistence(persistCurrentAdjustmentHours);

// === Adjustments Tab ===
// Render the adjustments table listing all employees with an input field for manual adjustment amounts.
function renderAdjustmentsTable() {
  if (isAdjustmentInputFocused()) {
    adjustmentsRenderPending = true;
    return;
  }
  adjustmentsRenderPending = false;
  syncPeriodScopedData();
  const atbody = document.querySelector('#adjustmentsTable tbody');
  if (!atbody) return;
  atbody.innerHTML = '';
  employeeList.forEach(emp => {
    const id = emp.id;
    const name = emp.name;
    // Use existing adjustment amount (monetary) or empty string for display
    const val = adjustments[id] !== undefined ? adjustments[id] : '';
    // Use existing adjustment hours or empty string for display
    const hrs = adjHrs[id] !== undefined ? adjHrs[id] : '';
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${id}</td>
      <td class="wrap">${name}</td>
      <td><input type="number" step="0.01" class="adjInput" data-id="${id}" value="${val}" /></td>
      <td><input type="number" step="0.01" class="adjHrsInput" data-id="${id}" value="${hrs}" /></td>
    `;
    atbody.appendChild(tr);
  });
  // Attach input event listeners to persist changes and recalculate payroll
  // Monetary adjustments
  const formatAdjustmentInput = (input) => {
    const empId = input.getAttribute('data-id');
    if (!empId) return;
    const stored = adjustments[empId];
    const num = Number(stored);
    if (Number.isFinite(num)) {
      const rounded = roundToCents(num);
      if (rounded !== 0) {
        input.value = rounded.toFixed(2);
        return;
      }
      if (num === 0) {
        input.value = '0.00';
        return;
      }
    }
    input.value = '';
  };
  const stageAdjustmentInput = (input) => {
    const empId = input.getAttribute('data-id');
    if (!empId) return;
    const raw = parseFloat(input.value);
    if (Number.isFinite(raw)) {
      const rounded = roundToCents(raw);
      if (rounded !== 0) {
        adjustments[empId] = rounded;
      } else {
        delete adjustments[empId];
      }
    } else {
      delete adjustments[empId];
    }
  };
  const commitAdjustmentInput = (input) => {
    const empId = input.getAttribute('data-id');
    if (!empId) return;
    const raw = parseFloat(input.value);
    if (Number.isFinite(raw)) {
      const rounded = roundToCents(raw);
      if (rounded !== 0) {
        adjustments[empId] = rounded;
      } else {
        delete adjustments[empId];
      }
    } else {
      delete adjustments[empId];
    }
    adjustmentPersist.flush();
    adjustmentRefresh.flush();
  };
  atbody.querySelectorAll('.adjInput').forEach(inp => {
    inp.addEventListener('focus', () => { adjustmentsFocusCount += 1; });
    inp.addEventListener('blur', () => {
      adjustmentsFocusCount = Math.max(0, adjustmentsFocusCount - 1);
      commitAdjustmentInput(inp);
      formatAdjustmentInput(inp);
      adjustmentRefresh.flush();
      setTimeout(() => {
        if (adjustmentsFocusCount === 0 && adjustmentsRenderPending) queueAdjustmentsRerender();
      }, 0);
    });
    inp.addEventListener('input', () => {
      stageAdjustmentInput(inp);
      adjustmentPersist.schedule();
      adjustmentRefresh.schedule();
    });
    inp.addEventListener('change', () => { commitAdjustmentInput(inp); formatAdjustmentInput(inp); });
    formatAdjustmentInput(inp);
  });
  // Adjustment hours
  const formatAdjustmentHoursInput = (input) => {
    const empId = input.getAttribute('data-id');
    if (!empId) return;
    const stored = adjHrs[empId];
    const num = Number(stored);
    if (Number.isFinite(num)) {
      const rounded = roundToCents(num);
      if (rounded !== 0) {
        input.value = rounded.toFixed(2);
        return;
      }
      if (num === 0) {
        input.value = '0.00';
        return;
      }
    }
    input.value = '';
  };
  const stageAdjustmentHoursInput = (input) => {
    const empId = input.getAttribute('data-id');
    if (!empId) return;
    const raw = parseFloat(input.value);
    if (Number.isFinite(raw)) {
      const rounded = roundToCents(raw);
      if (rounded !== 0) {
        adjHrs[empId] = rounded;
      } else {
        delete adjHrs[empId];
      }
    } else {
      delete adjHrs[empId];
    }
  };
  const commitAdjustmentHoursInput = (input) => {
    const empId = input.getAttribute('data-id');
    if (!empId) return;
    const raw = parseFloat(input.value);
    if (Number.isFinite(raw)) {
      const rounded = roundToCents(raw);
      if (rounded !== 0) {
        adjHrs[empId] = rounded;
      } else {
        delete adjHrs[empId];
      }
    } else {
      delete adjHrs[empId];
    }
    adjustmentHoursPersist.flush();
    adjustmentRefresh.flush();
  };
  atbody.querySelectorAll('.adjHrsInput').forEach(inp => {
    inp.addEventListener('focus', () => { adjustmentsFocusCount += 1; });
    inp.addEventListener('blur', () => {
      adjustmentsFocusCount = Math.max(0, adjustmentsFocusCount - 1);
      commitAdjustmentHoursInput(inp);
      formatAdjustmentHoursInput(inp);
      adjustmentRefresh.flush();
      setTimeout(() => {
        if (adjustmentsFocusCount === 0 && adjustmentsRenderPending) queueAdjustmentsRerender();
      }, 0);
    });
    inp.addEventListener('input', () => {
      stageAdjustmentHoursInput(inp);
      adjustmentHoursPersist.schedule();
      adjustmentRefresh.schedule();
    });
    inp.addEventListener('change', () => { commitAdjustmentHoursInput(inp); formatAdjustmentHoursInput(inp); });
    formatAdjustmentHoursInput(inp);
  });
  // Initialize totals for adjustments (amount and hours)
  adjustmentRefresh.flush();
}

// Compute and display the total of all adjustment amounts in the adjustments table footer.
function renderAdjustmentsFoot() {
  const amtCell = document.querySelector('#adjustmentsTableFoot [data-col="adjAmt"]');
  const hrsCell = document.querySelector('#adjustmentsTableFoot [data-col="adjHrs"]');
  if (!amtCell) return;
  // Sum monetary adjustments
  let totAmt = 0;
  Object.keys(adjustments || {}).forEach(k => {
    const v = Number(adjustments[k]) || 0;
    totAmt += v;
  });
  amtCell.textContent = totAmt.toFixed(2);
  // Sum adjustment hours
  if (hrsCell) {
    let totHrs = 0;
    Object.keys(adjHrs || {}).forEach(k => {
      const v = Number(adjHrs[k]) || 0;
      totHrs += v;
    });
    hrsCell.textContent = totHrs.toFixed(2);
  }
}

function adjustmentsBackupPayload(){
  return {
    adjustments: isPlainObject(allAdjustments) ? allAdjustments : {},
    adjustmentHours: isPlainObject(allAdjHrs) ? allAdjHrs : {},
    currentPeriod: currentPeriodKey
  };
}

async function copyAdjustmentsToClipboard(){
  const payload = JSON.stringify(adjustmentsBackupPayload());
  try {
    await navigator.clipboard.writeText(payload);
    const el = document.getElementById('adjustmentSaveStatus');
    if (el) {
      el.textContent = 'Copied to clipboard';
      el.classList.remove('error');
      el.classList.add('saved');
    }
  } catch (e) {
    const el = document.getElementById('adjustmentSaveStatus');
    if (el) {
      el.textContent = 'Clipboard copy failed';
      el.classList.remove('saved');
      el.classList.add('error');
    }
  }
}

async function restoreAdjustmentsFromPrompt(){
  const text = window.prompt('Paste the adjustments backup JSON to restore it');
  if (!text) return;
  try {
    const parsed = JSON.parse(text);
    if (isPlainObject(parsed.adjustments)) allAdjustments = parsed.adjustments;
    if (isPlainObject(parsed.adjustmentHours)) allAdjHrs = parsed.adjustmentHours;
    adjustments = allAdjustments[currentPeriodKey] || {};
    adjHrs = allAdjHrs[currentPeriodKey] || {};
    persistCurrentAdjustments();
    persistCurrentAdjustmentHours();
    renderAdjustmentsTable();
    calculateAll();
    const el = document.getElementById('adjustmentSaveStatus');
    if (el) {
      el.textContent = 'Adjustments restored';
      el.classList.remove('error');
      el.classList.add('saved');
    }
  } catch (e) {
    const el = document.getElementById('adjustmentSaveStatus');
    if (el) {
      el.textContent = 'Restore failed: invalid data';
      el.classList.remove('saved');
      el.classList.add('error');
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const copyBtn = document.getElementById('copyAdjustmentsBtn');
  if (copyBtn) copyBtn.addEventListener('click', copyAdjustmentsToClipboard);
  const restoreBtn = document.getElementById('restoreAdjustmentsBtn');
  if (restoreBtn) restoreBtn.addEventListener('click', restoreAdjustmentsFromPrompt);
});

// Initialize the dynamic Pagâ€‘IBIG and PhilHealth rate input fields.  This function
// sets their values from the current global variables and attaches input
// listeners to persist changes to localStorage and recalculate payroll.
function initializeContributionRates() {
  const pagibigInput = document.getElementById('pagibigRateInput');
  if (pagibigInput) {
    // Set current value; show as decimal with 3 decimals
    pagibigInput.value = typeof pagibigRate === 'number' ? pagibigRate.toFixed(3) : '';
    pagibigInput.addEventListener('change', function() {
      let val = parseFloat(pagibigInput.value);
      if (!isNaN(val)) {
        // If user enters percent (e.g. 2), convert to decimal
        if (val > 1) val = val / 100;
        // Bound to 0â€“1
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        pagibigRate = val;
        localStorage.setItem(LS_PAGIBIG_RATE, String(val));
        calculateAll();
        updateContributionNote();
      }
    });
  }
  const philInput = document.getElementById('philhealthRateInput');
  if (philInput) {
    philInput.value = typeof philhealthRate === 'number' ? philhealthRate.toFixed(3) : '';
    philInput.addEventListener('change', function() {
      let val = parseFloat(philInput.value);
      if (!isNaN(val)) {
        if (val > 1) val = val / 100;
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        philhealthRate = val;
        localStorage.setItem(LS_PHILHEALTH_RATE, String(val));
        calculateAll();
        updateContributionNote();
      }
    });
  }
}

// Update the contribution note in the payroll tab to reflect current rates.  It
// calculates percentages and updates the HTML of the element with id
// 'contribNote'.  Called after rate changes and on initial load.
function updateContributionNote() {
  const noteEl = document.getElementById('contribNote');
  if (!noteEl) return;
  const piPct = (pagibigRate * 100).toFixed(2);
  const phPct = (philhealthRate * 100).toFixed(2);
  noteEl.innerHTML = 'Pag-IBIG = Regular Pay &times; ' + piPct + '% (not divided), ' +
    'PhilHealth = Regular Pay &times; ' + phPct + '% (not divided), ' +
    'SSS = (Employee Share by Monthly Income) &divide; Divisor. SSS Loan and Pag-IBIG Loan are divided by the Divisor. Vales are manual (not divided).';
}
  document.getElementById('downloadPayrollCSV').addEventListener('click', ()=>{
  // Include Adjustments column before Bantay in payroll CSV export
  const header = ['Week Start','Week End','OT Multiplier','Divisor','ID','Name','Regular Hours','OT Hours','Hourly Rate','Regular Pay','OT Pay','Adjustments','Bantay','Gross Pay','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Account','Wed Vale','Total Deductions','Net Pay'];
  const rows=[header];
  const ws = weekStartEl.value||''; const we = weekEndEl.value||''; const otm = String(otMultiplierEl.value||''); const div = String(divisorEl.value||'1');
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
    const tds = tr.querySelectorAll('td');
    const id = tds[0].textContent.trim(); const name = tds[1].textContent.trim();
    const regI = tr.querySelector('.regHrs'); const otI = tr.querySelector('.otHrs'); const rateI = tr.querySelector('.rate');
    const regPay = tr.querySelector('.regPay').textContent.trim();
    const otPay = tr.querySelector('.otPay').textContent.trim();
    const adj   = tr.querySelector('.adjAmt') ? tr.querySelector('.adjAmt').textContent.trim() : '';
    const bantayVal = tr.querySelector('.bantay').value;
    const grossPay = tr.querySelector('.grossPay').textContent.trim();
    const pagibig = tr.querySelector('.pagibig').textContent.trim();
    const philhealth = tr.querySelector('.philhealth').textContent.trim();
    const sss = tr.querySelector('.sss').textContent.trim();
    const lSSS = tr.querySelector('.loanSSS').value; const lPI = tr.querySelector('.loanPI').value;
    const v = tr.querySelector('.vale').value; const vW = tr.querySelector('.valeWed').value;
    const total = tr.querySelector('.totalDed').textContent.trim();
    const net   = tr.querySelector('.netPay').textContent.trim();
    rows.push([ws,we,otm,div,id,name,regI.value,otI.value,rateI.value,regPay,otPay,adj,bantayVal,grossPay,pagibig,philhealth,sss,lSSS,lPI,v,vW,total,net]);
  });
  const csv = rows.map(r=>r.map(s=>{
    s = String(s ?? '');
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='payroll.csv'; document.body.appendChild(a); a.click(); a.remove();
});
renderTable();
renderSssTable();
renderAdjustmentsTable();
// Render new contribution tables and update the note
renderPagibigTable();
renderPhilhealthTable();
updateContributionNote();
    
  // Wire Project Totals CSV download button (global)
  if (document.getElementById('downloadProjectTotalsCSV')) {
    document.getElementById('downloadProjectTotalsCSV').addEventListener('click', exportProjectTotalsCSV);
  }
</script>

<!-- Modal report functionality for project totals -->
<script>
// Display a modal dialog with a detailed breakdown of a single project's totals.
// Takes a row object (result of computeProjectTotals) and builds a table of
// per-day hours per employee along with grand totals for regular hours, OT,
// total hours and gross pay. Uses the global weekStart/weekEnd inputs to
// construct the day labels. The modal is hidden by default and can be
// dismissed by clicking on the close button or outside the modal.
function showProjectReport(row) {
  if (!row || !row.breakdown || !row.breakdown.length) return;
  const modal = document.getElementById('projectReportModal');
  const content = document.getElementById('projectReportContent');
  if (!modal || !content) return;
  const wsEl = document.getElementById('weekStart');
  const weEl = document.getElementById('weekEnd');
  const startDate = wsEl && wsEl.value ? wsEl.value : '';
  const endDate = weEl && weEl.value ? weEl.value : '';
  // Helper to build a list of dates between start and end inclusive
  function dateRangeList(s, e) {
    const out = [];
    if (!s || !e) return out;
    const sd = new Date(s);
    const ed = new Date(e);
    for (let d = new Date(sd); d <= ed; d.setDate(d.getDate() + 1)) {
      out.push(new Date(d));
    }
    return out;
  }
  const days = dateRangeList(startDate, endDate);
  let html = '';
  html += '<h3 style="margin-top:0;">' + (row.project || 'Project') + ' (' + (startDate || '') + ' to ' + (endDate || '') + ')</h3>';
  html += '<div style="overflow-x:auto;">';
  html += '<table style="width:100%;border-collapse:collapse;margin-bottom:12px;">';
  html += '<thead><tr>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">ID</th>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">Name</th>';
  days.forEach(function(dt) {
    const label = (dt.getMonth() + 1) + '/' + dt.getDate();
    html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + label + '</th>';
  });
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Hrs</th>';
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Amount</th>';
  html += '</tr></thead><tbody>';
  row.breakdown.forEach(function(emp) {
    html += '<tr>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.id || '') + '</td>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.name || '') + '</td>';
    days.forEach(function(dt) {
      const key = dt.toISOString().slice(0, 10);
      const val = parseFloat((emp.perDay && emp.perDay[key]) || 0).toFixed(2);
      html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + val + '</td>';
    });
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.total || 0).toFixed(2)) + '</td>';
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.gross || 0).toFixed(2)) + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  html += '</div>';
  // Grand totals section
  html += '<div style="font-weight:600;">Grand Totals:</div>';
  html += '<table style="border-collapse:collapse;margin-top:4px;">';
  html += '<tr><td style="padding:4px;">Regular Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.reg || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">OT Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.ot || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Total Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.total || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Gross Amount:</td><td style="padding:4px;text-align:right;">' + ((row.gross != null) ? Number(row.gross).toFixed(2) : '0.00') + '</td></tr>';
  html += '</table>';
  content.innerHTML = html;
  modal.style.display = 'flex';
}
// Attach close handlers once DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('projectReportModal');
  const closeBtn = document.getElementById('closeProjectReport');
  if (closeBtn) closeBtn.addEventListener('click', function() { if (modal) modal.style.display = 'none'; });
  if (modal) modal.addEventListener('click', function(e) { if (e.target === modal) modal.style.display = 'none'; });
});
</script>

<!--
  Dashboard functionality
  This script defines utilities for managing payroll history snapshots. It is intentionally
  separated from the existing payroll logic to avoid altering core calculations.
  The dashboard allows users to select a date range, generate a snapshot of the current payroll table,
  lock it to prevent further edits, view past snapshots, and download CSV versions.
-->
<script>
// Shared helpers for formatting dashboard dates in MM-DD-YYYY layout.
function formatDisplayDate(value) {
  if (!value) return '';
  const str = String(value).trim();
  if (!str) return '';
  const isoMatch = str.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (isoMatch) {
    const [, year, month, day] = isoMatch;
    return `${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}-${year}`;
  }
  const dt = new Date(str);
  if (!isNaN(dt.getTime())) {
    const month = String(dt.getMonth() + 1).padStart(2, '0');
    const day = String(dt.getDate()).padStart(2, '0');
    const year = dt.getFullYear();
    return `${month}-${day}-${year}`;
  }
  return str;
}
function formatDateRange(start, end) {
  const startText = formatDisplayDate(start);
  const endText = formatDisplayDate(end);
  if (startText && endText) return `${startText} - ${endText}`;
  return startText || endText || '';
}
window.formatDisplayDate = formatDisplayDate;
window.formatDateRange = formatDateRange;

// Print Payroll Report: generate a print-friendly view of the payroll table and open
// a new window for printing. Inputs are converted to plain text and the final
// payslip column is removed to preserve confidentiality.
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('printPayrollBtn');
  if (btn) btn.addEventListener('click', function(){
    const srcTable = document.getElementById('payrollTable');
    if (!srcTable) {
      alert('Payroll table is missing or empty.');
      return;
    }
    // Clone table so we can modify it without affecting the live DOM
    const clone = srcTable.cloneNode(true);
    // Remove the last column (Payslip) from thead, tbody and tfoot
    const removeLastCell = row => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
    clone.querySelectorAll('thead tr').forEach(removeLastCell);
    clone.querySelectorAll('tbody tr').forEach(removeLastCell);
    clone.querySelectorAll('tfoot tr').forEach(removeLastCell);
    // Convert input fields to plain text within the cloned table
    // For loan inputs, show per-period share (divided by the divisor)
    const divisorKey = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
    const divisorVal = (typeof window !== 'undefined' && typeof window.divisor !== 'undefined' && Number(window.divisor)) || parseInt((localStorage && localStorage.getItem(divisorKey)) || '1', 10) || 1;
    const safeDivide = (raw) => {
      const base = Number(divisorVal) || 1;
      const amt = parseFloat((raw || '').toString().replace(/,/g, '')) || 0;
      return (amt / base).toFixed(2);
    };
    const formatEffectiveValue = (value) => {
      if (value == null) return '';
      const num = parseFloat(value);
      if (!Number.isNaN(num)) return num.toFixed(2);
      return String(value);
    };
    const readDeductionEffective = (el) => {
      if (!el || !el.dataset) return null;
      if (Object.prototype.hasOwnProperty.call(el.dataset, 'effectiveValue')) {
        return el.dataset.effectiveValue;
      }
      if (Object.prototype.hasOwnProperty.call(el.dataset, 'effective')) {
        return el.dataset.effective;
      }
      return null;
    };
    clone.querySelectorAll('input').forEach(inp => {
      const td = inp.parentElement;
      const cls = inp.classList || { contains: () => false };
      const effective = readDeductionEffective(inp);
      const isLoan = cls.contains('loanSSS') || cls.contains('loanPI');
      const isDeductionInput = isLoan || cls.contains('vale') || cls.contains('valeWed');
      if (isDeductionInput && effective != null) {
        td.textContent = formatEffectiveValue(effective);
      } else if (isLoan) {
        td.textContent = formatEffectiveValue(safeDivide(inp.value || '0'));
      } else {
        const val = (inp.value || inp.textContent || '').toString();
        td.textContent = val;
      }
    });
    // Locked payroll snapshots render loan cells as plain text (no inputs). Ensure
    // they reflect the per-period share by applying the same divisor used above.
    clone.querySelectorAll('td.loanSSS, td.loanPI').forEach(td => {
      if (!td) return;
      if (td.querySelector('input')) return;
      const effective = readDeductionEffective(td);
      if (effective != null) {
        td.textContent = formatEffectiveValue(effective);
        return;
      }
      const divided = safeDivide(td.textContent || '0');
      td.textContent = formatEffectiveValue(divided);
    });
    // Insert a column showing adjustment deductions (negative adjustments)
    (function(){
      const norm = (s) => String(s || '').replace(/\s+/g, ' ').trim().toLowerCase();
      const headerRow = clone.querySelector('thead tr');
      if (!headerRow) return;
      const accountIndex = Array.from(headerRow.cells || []).findIndex(cell => norm(cell.textContent) === 'account');
      if (accountIndex < 0) return;
      const insertIndex = accountIndex + 1;
      let totalAdjDeduction = 0;

      const insertCellAt = (tr, cell, columnIndex) => {
        if (!tr || !cell) return;
        let col = 0;
        const cells = Array.from(tr.children);
        for (const existing of cells) {
          const span = parseInt(existing.getAttribute('colspan'), 10) || 1;
          if (col >= columnIndex || (col + span) > columnIndex) {
            tr.insertBefore(cell, existing);
            return;
          }
          col += span;
        }
        tr.appendChild(cell);
      };

      clone.querySelectorAll('thead tr').forEach(tr => {
        const th = document.createElement('th');
        th.textContent = 'Adj Deduction';
        th.style.textAlign = 'right';
        insertCellAt(tr, th, insertIndex);
      });

      clone.querySelectorAll('tbody tr').forEach(tr => {
        const td = document.createElement('td');
        td.classList.add('num');
        let raw = 0;
        try {
          raw = parseFloat(tr.dataset && tr.dataset.adjustmentDeduction ? tr.dataset.adjustmentDeduction : '0');
        } catch (err) { raw = 0; }
        if (!Number.isFinite(raw)) raw = 0;
        if (raw < 0) raw = Math.abs(raw);
        totalAdjDeduction += raw;
        td.textContent = raw > 0 ? raw.toFixed(2) : '0.00';
        insertCellAt(tr, td, insertIndex);
      });

      const totalText = totalAdjDeduction > 0 ? totalAdjDeduction.toFixed(2) : '0.00';
      clone.querySelectorAll('tfoot tr').forEach(tr => {
        const td = document.createElement('td');
        td.classList.add('num');
        td.textContent = totalText;
        insertCellAt(tr, td, insertIndex);
      });
    })();

    // Replace numeric zeros with dashes in clone
    clone.querySelectorAll('td').forEach(function(td){
      if (td.querySelector('input')) return;
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (!raw) return;
      var num = parseFloat(raw);
      if (!isNaN(num) && num === 0) td.textContent = '-';
    });
    // Rename selected header labels for print-only
    (function(){
      function norm(s){ return String(s||'').replace(/\s+/g,' ').trim().toLowerCase(); }
      var map = new Map([
        ['regular hours','REG HRS'],
        ['ot hours','OT HRS'],
        ['adjustment hrs','ADJ HRS'],
        ['adjustments','ADJ'],
        ['adj deduction','ADJ DED'],
        ['total deductions','TOTAL DEDUC.']
      ]);
      clone.querySelectorAll('thead th').forEach(function(th){
        var key = norm(th.textContent);
        if (map.has(key)) th.textContent = map.get(key);
      });
    })();
    // Build a new window for printing
    const w = window.open('', '', 'width=900,height=700');
    if (!w) return;
    w.document.write('<html><head><meta charset="utf-8"><title>Payroll Report</title>');
    // Basic styles: borders and alignment
    w.document.write('<style>@page{size:letter landscape;margin:10mm} html,body{-webkit-print-color-adjust:exact;print-color-adjust:exact;width:11in;height:8.5in;margin:0} body{font-family:Arial,Helvetica,sans-serif;margin:0;} h2{margin:0 0 6px;font-size:16px} table{border-collapse:collapse;width:100%;table-layout:fixed} thead{display:table-header-group} tfoot{display:table-footer-group} th,td{border:1pt solid #000!important;border-style:solid!important;padding:4px;font-size:11px} table,th,td{border-color:#000!important;border-style:solid!important} th{background:#f1f5f9} td.num{text-align:right} th:nth-child(1),td:nth-child(1),th:nth-child(2),td:nth-child(2){text-align:left} tfoot td{font-weight:700;background:#fff7ed;border-top:2pt solid #000!important} #payrollTable{page-break-inside:auto} #payrollTable tr{page-break-inside:avoid;break-inside:avoid-page} #payrollTable th, #payrollTable td { white-space: nowrap !important; page-break-inside: avoid; } #payrollTable th:nth-child(1), #payrollTable td:nth-child(1) { width:30px; min-width:30px; } #payrollTable th:nth-child(2), #payrollTable td:nth-child(2) { width:150px; min-width:150px; } #payrollTable th:nth-child(3), #payrollTable td:nth-child(3) { width:60px; min-width:60px; } #payrollTable th:nth-child(4), #payrollTable td:nth-child(4) { width:60px; min-width:60px; } #payrollTable th:nth-child(5), #payrollTable td:nth-child(5) { width:60px; min-width:60px; } #payrollTable th:nth-child(6), #payrollTable td:nth-child(6) { width:60px; min-width:60px; } #payrollTable th:nth-child(7), #payrollTable td:nth-child(7) { width:60px; min-width:60px; } #payrollTable th:nth-child(8), #payrollTable td:nth-child(8) { width:60px; min-width:60px; } #payrollTable th:nth-child(9), #payrollTable td:nth-child(9) { width:60px; min-width:60px; } #payrollTable th:nth-child(10), #payrollTable td:nth-child(10) { width:60px; min-width:60px; } #payrollTable th:nth-child(11), #payrollTable td:nth-child(11) { width:60px; min-width:60px; } #payrollTable th:nth-child(12), #payrollTable td:nth-child(12) { width:60px; min-width:60px; } #payrollTable th:nth-child(13), #payrollTable td:nth-child(13) { width:60px; min-width:60px; } #payrollTable th:nth-child(14), #payrollTable td:nth-child(14) { width:60px; min-width:60px; } #payrollTable th:nth-child(15), #payrollTable td:nth-child(15) { width:60px; min-width:60px; } #payrollTable th:nth-child(16), #payrollTable td:nth-child(16) { width:60px; min-width:60px; } #payrollTable th:nth-child(17), #payrollTable td:nth-child(17) { width:60px; min-width:60px; } #payrollTable th:nth-child(18), #payrollTable td:nth-child(18) { width:60px; min-width:60px; } #payrollTable th:nth-child(19), #payrollTable td:nth-child(19) { width:60px; min-width:60px; } #payrollTable th:nth-child(20), #payrollTable td:nth-child(20) { width:60px; min-width:60px; } #payrollTable th:nth-child(21), #payrollTable td:nth-child(21) { width:50px; min-width:50px; } #payrollTable th:nth-child(22), #payrollTable td:nth-child(22) { width:75px; min-width:75px; }</style>');
    w.document.write('</head><body>');
    // Header with date range if available
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const startDate = ws && ws.value ? ws.value : '';
    const endDate = we && we.value ? we.value : '';
    if (startDate && endDate) {
      w.document.write('<div id="printWrap"><h2>Payroll Report (' + startDate + ' to ' + endDate + ')</h2>');
    } else {
      w.document.write('<div id="printWrap"><h2>Payroll Report</h2>');
    }
    w.document.write(clone.outerHTML);
    w.document.write('</div></body></html>');
    w.document.close();
    // Print without auto-scaling
    try {
      w.addEventListener('load', function(){
        try { safePrint(w); } catch(e){}
      }, { once: true });
    } catch(e) { try { safePrint(w); } catch(_){} }
    // Optionally close after printing (comment out if you don't want auto-close)
    // w.close();
  });
});

// Export Payroll Report Excel: mirrors the Print Report table structure but writes to XLSX.
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('printPayrollExcelBtn');
  if (!btn) return;
  btn.addEventListener('click', function(){
    if (typeof XLSX === 'undefined' || !XLSX || !XLSX.utils) {
      alert('Excel library not available');
      return;
    }
    const srcTable = document.getElementById('payrollTable');
    if (!srcTable) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const clone = srcTable.cloneNode(true);
    const removeLastCell = row => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
    clone.querySelectorAll('thead tr').forEach(removeLastCell);
    clone.querySelectorAll('tbody tr').forEach(removeLastCell);
    clone.querySelectorAll('tfoot tr').forEach(removeLastCell);

    const divisorKey = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
    const divisorVal = (typeof window !== 'undefined' && typeof window.divisor !== 'undefined' && Number(window.divisor)) || parseInt((localStorage && localStorage.getItem(divisorKey)) || '1', 10) || 1;
    const safeDivide = (raw) => {
      const base = Number(divisorVal) || 1;
      const amt = parseFloat((raw || '').toString().replace(/,/g, '')) || 0;
      return (amt / base).toFixed(2);
    };

    const formatEffectiveValue = (value) => {
      if (value == null) return '';
      const num = parseFloat(value);
      if (!Number.isNaN(num)) return num.toFixed(2);
      return String(value);
    };
    const readDeductionEffective = (el) => {
      if (!el || !el.dataset) return null;
      if (Object.prototype.hasOwnProperty.call(el.dataset, 'effectiveValue')) {
        return el.dataset.effectiveValue;
      }
      if (Object.prototype.hasOwnProperty.call(el.dataset, 'effective')) {
        return el.dataset.effective;
      }
      return null;
    };
    clone.querySelectorAll('input').forEach(inp => {
      const td = inp.parentElement;
      const cls = inp.classList || { contains: () => false };
      const effective = readDeductionEffective(inp);
      const isLoan = cls.contains('loanSSS') || cls.contains('loanPI');
      const isDeductionInput = isLoan || cls.contains('vale') || cls.contains('valeWed');
      if (isDeductionInput && effective != null) {
        td.textContent = formatEffectiveValue(effective);
      } else if (isLoan) {
        td.textContent = formatEffectiveValue(safeDivide(inp.value || '0'));
      } else {
        const val = (inp.value || inp.textContent || '').toString();
        td.textContent = val;
      }
    });

    clone.querySelectorAll('td.loanSSS, td.loanPI').forEach(td => {
      if (!td) return;
      if (td.querySelector('input')) return;
      const effective = readDeductionEffective(td);
      if (effective != null) {
        td.textContent = formatEffectiveValue(effective);
        return;
      }
      const divided = safeDivide(td.textContent || '0');
      td.textContent = formatEffectiveValue(divided);
    });

    clone.querySelectorAll('td').forEach(function(td){
      if (td.querySelector('input')) return;
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (!raw) return;
      var num = parseFloat(raw);
      if (!isNaN(num) && num === 0) td.textContent = '-';
    });

    (function(){
      function norm(s){ return String(s||'').replace(/\s+/g,' ').trim().toLowerCase(); }
      var map = new Map([
        ['regular hours','REG HRS'],
        ['ot hours','OT HRS'],
        ['adjustment hrs','ADJ HRS'],
        ['adjustments','ADJ'],
        ['total deductions','TOTAL DEDUC.']
      ]);
      clone.querySelectorAll('thead th').forEach(function(th){
        var key = norm(th.textContent);
        if (map.has(key)) th.textContent = map.get(key);
      });
    })();

    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const startDate = ws && ws.value ? ws.value : '';
    const endDate = we && we.value ? we.value : '';
    const title = (startDate && endDate) ? `Payroll Report (${startDate} to ${endDate})` : 'Payroll Report';

    const rows = [];
    rows.push([title]);
    rows.push([]);

    const asSheetValue = (text) => {
      const trimmed = (text || '').trim();
      if (!trimmed || trimmed === '-') return trimmed;
      const normalized = trimmed.replace(/,/g, '');
      if (/^-?\d+(\.\d+)?$/.test(normalized)) {
        const num = Number(normalized);
        if (!Number.isNaN(num)) return num;
      }
      return trimmed;
    };

    ['thead','tbody','tfoot'].forEach(section => {
      clone.querySelectorAll(section + ' tr').forEach(tr => {
        const cells = [];
        Array.from(tr.children).forEach(cell => {
          const text = (cell.textContent || '').trim();
          const span = parseInt(cell.getAttribute('colspan'), 10) || 1;
          cells.push(asSheetValue(text));
          for (let i = 1; i < span; i += 1) {
            cells.push('');
          }
        });
        rows.push(cells);
      });
    });

    const wb = XLSX.utils.book_new();
    const sheet = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, sheet, 'Payroll Report');

    const rangeLabel = (startDate && endDate) ? `${startDate}_to_${endDate}` : '';
    const safeLabel = rangeLabel.replace(/[^0-9A-Za-z_-]/g, '');
    const filename = safeLabel ? `Payroll_Report_${safeLabel}.xlsx` : 'Payroll_Report.xlsx';
    XLSX.writeFile(wb, filename);
  });
});
document.addEventListener('DOMContentLoaded', () => {
  // Key used to persist payroll history snapshots in localStorage
  const PAYROLL_HIST_KEY = 'payroll_hist';
  // Load existing history from localStorage or default to an empty array
  let payrollHistory;
  try {
    payrollHistory = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
    if (!Array.isArray(payrollHistory)) payrollHistory = [];
  } catch (err) {
    payrollHistory = [];
  }
  // Expose payrollHistory on the window so other scripts (like the Active Payroll dropdown) can
  // append to it directly. Without this, new snapshots added via custom UI would only update
  // localStorage and would not appear in the current session until a full page reload.
  window.payrollHistory = payrollHistory;
  // Grab references to dashboard elements
  // Use the global weekStart/weekEnd inputs instead of the removed dashStartDate/dashEndDate fields.
  const dashStart = document.getElementById('weekStart');
  const dashEnd = document.getElementById('weekEnd');
  const dashGenerateBtn = document.getElementById('dashGenerate');
  const dashLockButton = document.getElementById('lockSnapshotBtn');
  const dashUnlockButton = document.getElementById('unlockPeriodBtn');
  const dashLockStatus = document.getElementById('dashLockStatus');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const snapshotView = document.getElementById('snapshotView');
  // Reference to the Active Payrolls table body
  const activeTableBody = document.querySelector('#activePayrollTable tbody');

  const PAYROLL_LOCKS_KEY = 'payroll_lock_state';

  function loadLockMap() {
    try {
      const raw = localStorage.getItem(PAYROLL_LOCKS_KEY);
      if (!raw) return { __meta: { lastUpdatedAt: Date.now() } };
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return { __meta: { lastUpdatedAt: Date.now() } };
      if (!parsed.__meta) parsed.__meta = {};
      return parsed;
    } catch (err) {
      return { __meta: {} };
    }
  }

  let payrollLocks = loadLockMap();
  try { window.payrollLocks = payrollLocks; } catch (err) {}

  function persistLocks() {
    try {
      if (!payrollLocks || typeof payrollLocks !== 'object') payrollLocks = { __meta: {} };
      if (!payrollLocks.__meta) payrollLocks.__meta = {};
      payrollLocks.__meta.lastUpdatedAt = Date.now();
      localStorage.setItem(PAYROLL_LOCKS_KEY, JSON.stringify(payrollLocks));
    } catch (err) {
      console.warn('Unable to persist payroll lock state', err);
    }
  }

  function periodKey(start, end) {
    return `${start || ''}__${end || ''}`;
  }

  function getCurrentPeriodRange() {
    return {
      start: dashStart && dashStart.value ? dashStart.value : '',
      end: dashEnd && dashEnd.value ? dashEnd.value : ''
    };
  }

  function getLockEntry(start, end) {
    if (!start || !end) return null;
    const entry = payrollLocks && payrollLocks[periodKey(start, end)];
    return entry && typeof entry === 'object' ? entry : null;
  }

  function captureGrandTotals() {
    const foot = document.getElementById('payrollTotalsFoot');
    if (!foot) return null;
    const totals = {};
    foot.querySelectorAll('[data-col]').forEach(td => {
      const col = td.dataset.col;
      if (!col) return;
      totals[col] = (td.textContent || '').trim();
    });
    return totals;
  }

  function findHistorySnapshot(start, end) {
    if (!start || !end || !Array.isArray(payrollHistory)) return null;
    return payrollHistory.find(entry => entry && entry.startDate === start && entry.endDate === end) || null;
  }

  function setSnapshotOverride(snapshot) {
    if (!snapshot) return;
    const payload = {
      rows: Array.isArray(snapshot.rows) ? snapshot.rows : [],
      totals: snapshot.totals || {},
      divisor: snapshot.divisor
    };
    try { window.__snapshotPayrollOverride = payload; }
    catch (err) { window.__snapshotPayrollOverride = payload; }
  }

  function clearSnapshotOverride() {
    try { delete window.__snapshotPayrollOverride; }
    catch (err) { window.__snapshotPayrollOverride = undefined; }
  }

  function formatSnapshotNumber(value, options = {}) {
    const num = Number(value);
    if (!Number.isFinite(num)) {
      if (value === '' || value == null) return options.emptyAsDash ? '-' : '0.00';
      return String(value);
    }
    if (options.keepZero) {
      return num.toFixed(options.decimals ?? 2);
    }
    if (Math.abs(num) < 0.0005) return '-';
    return num.toFixed(options.decimals ?? 2);
  }

  function formatFootTotal(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) {
      if (value == null) return '0.00';
      return String(value);
    }
    try {
      return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    } catch (err) {
      return num.toFixed(2);
    }
  }

  function applySnapshotToPayrollTable(snapshot) {
    if (!snapshot || !Array.isArray(snapshot.rows)) return false;
    const table = document.getElementById('payrollTable');
    if (!table) return false;
    const bodyRows = table.querySelectorAll('tbody tr');
    if (!bodyRows || !bodyRows.length) return false;
    const byId = new Map();
    snapshot.rows.forEach(row => {
      if (!row) return;
      const key = row.id != null ? String(row.id).trim() : '';
      if (key) byId.set(key, row);
    });

    bodyRows.forEach(tr => {
      const idCell = tr.cells && tr.cells[0];
      if (!idCell) return;
      const empId = (idCell.textContent || '').trim();
      if (!empId) return;
      const data = byId.get(empId);
      if (!data) return;

      const applyInput = (selector, value, decimals = 2) => {
        const el = tr.querySelector(selector);
        if (!el) return;
        if (typeof el.value !== 'undefined') {
          const num = Number(value);
          if (!Number.isFinite(num)) {
            el.value = value == null ? '' : String(value);
          } else if (decimals == null) {
            el.value = String(num);
          } else {
            el.value = num.toFixed(decimals);
          }
        } else {
          el.textContent = formatSnapshotNumber(value, { decimals });
        }
      };

      const applyText = (selector, value, options) => {
        const el = tr.querySelector(selector);
        if (!el) return;
        el.textContent = formatSnapshotNumber(value, options || {});
      };

      applyInput('.rate', data.rate);
      applyInput('.regHrs', data.regHrs);
      applyInput('.otHrs', data.otHrs);

      const adjHrsCell = tr.querySelector('.adjHrs');
      if (adjHrsCell) {
        const adjHoursNum = Number(data.adjHrs);
        if (!Number.isFinite(adjHoursNum)) {
          adjHrsCell.textContent = '-';
        } else if (Math.abs(adjHoursNum) < 0.0005) {
          adjHrsCell.textContent = '-';
        } else {
          adjHrsCell.textContent = adjHoursNum.toFixed(2);
        }
      }

      applyText('.totalHrs', data.totalHrs, { decimals: 2, keepZero: true });
      applyText('.regPay', data.regPay);
      applyText('.otPay', data.otPay);
      applyText('.adjAmt', data.adjAmt);
      applyInput('.bantay', data.bantay);
      applyText('.grossPay', data.grossPay);
      applyText('.pagibig', data.pagibig);
      applyText('.philhealth', data.philhealth);
      applyText('.sss', data.sss);
      applyInput('.loanSSS', data.loanSSS);
      applyInput('.loanPI', data.loanPI);
      applyInput('.vale', data.vale);
      applyInput('.valeWed', data.valeWed);
      applyText('.totalDed', data.totalDed);
      applyText('.netPay', data.netPay);

      const adjPositive = Number(data.adjAmt) || 0;
      const adjDeduction = Number(data.adjustmentDeduction) || 0;
      const adjRaw = adjPositive - adjDeduction;
      try {
        tr.dataset.adjustmentRaw = adjRaw.toFixed(2);
        tr.dataset.adjustmentPositive = adjPositive.toFixed(2);
        tr.dataset.adjustmentDeduction = adjDeduction.toFixed(2);
      } catch (err) {}

      if (typeof payrollRates === 'object' && payrollRates) payrollRates[empId] = Number(data.rate) || 0;
      if (typeof regHours === 'object' && regHours) regHours[empId] = Number(data.regHrs) || 0;
      if (typeof otHours === 'object' && otHours) otHours[empId] = Number(data.otHrs) || 0;
      if (typeof adjHrs === 'object' && adjHrs) adjHrs[empId] = Number(data.adjHrs) || 0;
      if (typeof bantay === 'object' && bantay) bantay[empId] = Number(data.bantay) || 0;
      if (typeof loanSSS === 'object' && loanSSS) loanSSS[empId] = Number(data.loanSSS) || 0;
      if (typeof loanPI === 'object' && loanPI) loanPI[empId] = Number(data.loanPI) || 0;
      if (typeof vale === 'object' && vale) vale[empId] = Number(data.vale) || 0;
      if (typeof valeWed === 'object' && valeWed) valeWed[empId] = Number(data.valeWed) || 0;
      if (typeof adjustments === 'object' && adjustments) adjustments[empId] = adjRaw;
    });

    persistCurrentAdjustments();
    persistCurrentAdjustmentHours();

    const foot = document.getElementById('payrollTotalsFoot');
    if (foot && snapshot.totals && typeof snapshot.totals === 'object') {
      foot.querySelectorAll('[data-col]').forEach(td => {
        const key = td.dataset.col;
        if (!key) return;
        td.textContent = formatFootTotal(snapshot.totals[key]);
      });
    }

    try { if (typeof renderDeductionsTable === 'function') renderDeductionsTable(); } catch (err) {}
    try { if (typeof updatePayrollGrandTotals === 'function') updatePayrollGrandTotals(); } catch (err) {}
    return true;
  }

  function syncHistoryLockState(start, end, locked, meta) {
    if (!Array.isArray(payrollHistory) || !start || !end) return;
    let snap = payrollHistory.find(entry => entry && entry.startDate === start && entry.endDate === end);
    if (!snap && locked) {
      snap = { startDate: start, endDate: end };
      payrollHistory.push(snap);
    }
    if (!snap) return;
    snap.locked = locked;
    snap.lockedAt = locked ? (meta && meta.lockedAt ? meta.lockedAt : new Date().toISOString()) : '';
    if (locked) {
      const snapMeta = meta && meta.snapshot && typeof meta.snapshot === 'object' ? meta.snapshot : null;
      if (snapMeta) {
        if (Array.isArray(snapMeta.rows)) snap.rows = snapMeta.rows;
        if (snapMeta.totals && typeof snapMeta.totals === 'object') snap.totals = snapMeta.totals;
        if (typeof snapMeta.divisor !== 'undefined') snap.divisor = snapMeta.divisor;
        if (snapMeta.hash) snap.hash = snapMeta.hash;
      } else if (meta && meta.totals) {
        snap.totals = meta.totals;
      }
      if (meta && meta.hash) snap.hash = meta.hash;
    } else {
      snap.totals = {};
      if (typeof snap.hash !== 'undefined') snap.hash = '';
    }
    if (typeof saveHistory === 'function') saveHistory();
    if (typeof renderHistory === 'function') renderHistory();
    if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
  }

  function setPeriodLocked(start, end, locked, meta = {}) {
    if (!start || !end) return;
    if (!payrollLocks || typeof payrollLocks !== 'object') payrollLocks = { __meta: {} };
    const key = periodKey(start, end);
    if (locked) {
      payrollLocks[key] = {
        locked: true,
        lockedAt: meta.lockedAt || new Date().toISOString(),
        totals: meta.totals || null
      };
    } else {
      delete payrollLocks[key];
    }
    persistLocks();
    syncHistoryLockState(start, end, locked, meta);
    try { window.payrollLocks = payrollLocks; } catch (err) {}
  }

  function updateLockStatusDisplay(entry) {
    if (!dashLockStatus) return;
    if (!entry || !entry.locked) {
      dashLockStatus.style.display = 'none';
      dashLockStatus.textContent = '';
      return;
    }
    const parts = ['Locked'];
    if (entry.lockedAt) {
      try {
        parts.push(new Date(entry.lockedAt).toLocaleString());
      } catch (err) {}
    }
    if (entry.totals && entry.totals.netPay) {
      parts.push(`Net ${entry.totals.netPay}`);
    }
    dashLockStatus.textContent = parts.join(' · ');
    dashLockStatus.style.display = 'inline';
  }

  function applyLockUI() {
    const { start, end } = getCurrentPeriodRange();
    const hasRange = !!(start && end);
    if (!hasRange) {
      enablePayrollInputs();
      updateLockStatusDisplay(null);
      clearSnapshotOverride();
      if (dashLockButton) dashLockButton.disabled = true;
      if (dashUnlockButton) dashUnlockButton.disabled = true;
      return false;
    }
    const entry = getLockEntry(start, end);
    const locked = !!(entry && entry.locked);
    if (locked) {
      disablePayrollInputs();
      updateLockStatusDisplay(entry);
      const snap = findHistorySnapshot(start, end);
      if (snap) {
        setSnapshotOverride(snap);
        applySnapshotToPayrollTable(snap);
      } else {
        clearSnapshotOverride();
      }
      if (dashLockButton) dashLockButton.disabled = true;
      if (dashUnlockButton) dashUnlockButton.disabled = false;
    } else {
      enablePayrollInputs();
      updateLockStatusDisplay(null);
      clearSnapshotOverride();
      if (dashLockButton) dashLockButton.disabled = false;
      if (dashUnlockButton) dashUnlockButton.disabled = true;
    }
    return locked;
  }

  async function lockCurrentPeriod() {
    const { start, end } = getCurrentPeriodRange();
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    if (getLockEntry(start, end)?.locked) {
      applyLockUI();
      return;
    }
    try {
      if (typeof calculateAll === 'function') {
        await Promise.resolve(calculateAll());
      }
    } catch (err) {}
    try {
      if (typeof updatePayrollGrandTotals === 'function') {
        updatePayrollGrandTotals();
      }
    } catch (err) {}
    const snapshot = await buildSnapshot(start, end);
    if (!snapshot || !Array.isArray(snapshot.rows) || !snapshot.rows.length) {
      alert('Payroll table is missing or empty.');
      return;
    }
    let hashHex = '';
    try {
      const payload = JSON.stringify({
        startDate: start,
        endDate: end,
        rows: snapshot.rows,
        totals: snapshot.totals,
        divisor: snapshot.divisor
      });
      const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(payload));
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    } catch (err) {
      hashHex = '';
    }
    const lockedAt = new Date().toISOString();
    let existing = findHistorySnapshot(start, end);
    if (!existing) {
      existing = { startDate: start, endDate: end };
      payrollHistory.push(existing);
    }
    existing.startDate = start;
    existing.endDate = end;
    existing.rows = snapshot.rows;
    existing.totals = snapshot.totals;
    existing.divisor = snapshot.divisor;
    existing.hash = hashHex;
    existing.locked = true;
    existing.lockedAt = lockedAt;
    saveHistory();
    if (typeof renderHistory === 'function') renderHistory();
    if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
    disablePayrollInputs();
    setSnapshotOverride(existing);
    setPeriodLocked(start, end, true, {
      lockedAt,
      totals: snapshot.totals,
      hash: hashHex,
      snapshot: {
        rows: snapshot.rows,
        totals: snapshot.totals,
        divisor: snapshot.divisor,
        hash: hashHex
      }
    });
    applySnapshotToPayrollTable(existing);
    applyLockUI();
  }

  async function unlockCurrentPeriod() {
    const { start, end } = getCurrentPeriodRange();
    if (!start || !end) {
      applyLockUI();
      return;
    }
    if (!getLockEntry(start, end)) {
      applyLockUI();
      return;
    }
    setPeriodLocked(start, end, false);
    enablePayrollInputs();
    applyLockUI();
    try {
      if (typeof calculateAll === 'function') {
        await Promise.resolve(calculateAll());
      }
    } catch (err) {}
    try {
      if (typeof updatePayrollGrandTotals === 'function') {
        updatePayrollGrandTotals();
      }
    } catch (err) {}
  }

  if (dashStart) {
    dashStart.addEventListener('change', () => { checkAndToggleEditState(); });
  }
  if (dashEnd) {
    dashEnd.addEventListener('change', () => { checkAndToggleEditState(); });
  }
  checkAndToggleEditState();
  try {
    window.getPayrollLockEntry = getLockEntry;
    window.setPayrollLock = setPeriodLocked;
    window.applyPayrollLockUI = applyLockUI;
    window.lockCurrentPeriod = lockCurrentPeriod;
    window.unlockCurrentPeriod = unlockCurrentPeriod;
  } catch (err) {}

  /**
   * Render the active payrolls table.
   * Lists snapshots that are not yet locked with Edit and Delete actions.
   */
  window.renderActivePayrolls = function renderActivePayrolls() {
    if (!activeTableBody) return;
    activeTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      if (snap.locked) return;
      const tr = document.createElement('tr');
      const startText = formatDisplayDate(snap.startDate);
      const endText = formatDisplayDate(snap.endDate);
      // Build the Active Payroll row. Include Edit and Delete actions. Deleting
      // prompts confirmation and removes the snapshot from payrollHistory.
      tr.innerHTML = `
        <td>${startText}</td>
        <td>${endText}</td>
        <td>
          <button type="button" class="editActive" data-index="${index}">Edit</button>
          <button type="button" class="deleteActive" data-index="${index}">Delete</button>
        </td>
      `;
      activeTableBody.appendChild(tr);
    });
  };

  // Delegate edit/delete actions on the Active Payrolls table
  activeTableBody && activeTableBody.addEventListener('click', async (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('editActive')) {
      // Set the global date range to the snapshot dates and switch to Payroll tab
      const wsEl = document.getElementById('weekStart');
      const weEl = document.getElementById('weekEnd');
      if (wsEl) wsEl.value = snap.startDate || '';
      if (weEl) weEl.value = snap.endDate || '';
      try {
        if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
        else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
      } catch (err) {}
      // Show the payroll panel
      try { showTab('payroll'); } catch (err) {}
    } else if (target.classList.contains('deleteActive')) {
      // Delete active (unlocked) snapshot after confirmation
      if (!snap) return;
      const ok = confirm('Are you sure you want to delete this payroll snapshot? This action cannot be undone.');
      if (!ok) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
  });

  /**
   * Render the payroll history table.
   * Each snapshot row contains start/end dates, lock timestamp, truncated hash,
   * and action buttons for opening and downloading the snapshot.
   */
  window.renderHistory = function renderHistory() {
    if (!historyTableBody) return;
    historyTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      const tr = document.createElement('tr');
      tr.dataset.index = index;
      tr.tabIndex = 0;
      const startText = formatDisplayDate(snap.startDate);
      const endText = formatDisplayDate(snap.endDate);
      const lockEntry = getLockEntry(snap.startDate, snap.endDate);
      const netSource = (lockEntry && lockEntry.totals && lockEntry.totals.netPay) || (snap.totals && snap.totals.netPay) || '';
      const netText = (() => {
        if (!netSource && netSource !== 0) return '';
        const numeric = Number(String(netSource).replace(/,/g, ''));
        if (!Number.isNaN(numeric) && Number.isFinite(numeric)) {
          return numeric.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        return String(netSource);
      })();
      // Build row HTML; note small hash display for brevity
      // Build the actions column depending on lock status.
      const actions = [];
      if (snap.locked) {
        // For locked snapshots, show a disabled delete button to indicate it cannot be removed
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}" disabled>Delete</button>`);
      } else {
        // For unlocked snapshots, allow deletion
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}">Delete</button>`);
      }
      tr.innerHTML = `
        <td>${startText}</td>
        <td>${endText}</td>
        <td>${snap.lockedAt ? new Date(snap.lockedAt).toLocaleString() : ''}</td>
        <td>${netText}</td>
        <td>${actions.join(' ')}</td>
      `;
      historyTableBody.appendChild(tr);
    });
  };

  // Post-lock automation: print DTR, download Employees CSV, print Payroll, export Reports Excel
  window.runPostLockOutputs = function runPostLockOutputs(){
    // Only export one Excel workbook with all tabs (no prints or CSVs)
    try {
      if (typeof window.rebuildReports === 'function') window.rebuildReports();
      setTimeout(function(){
        try {
          if (typeof window.exportExcelAllTabs === 'function') {
            Promise.resolve(window.exportExcelAllTabs()).catch(()=>{});
          }
        } catch(e){}
      }, 600);
    } catch(e){}
  };

  /**
   * Build a snapshot from the current payroll table. This captures all row values
   * and totals in a structured JSON object for persistence.
   */
  async function buildSnapshot(startDate, endDate) {
    const table = document.getElementById('payrollTable');
    if (!table) return null;
    const rows = [];
    table.querySelectorAll('tbody tr').forEach(row => {
      const data = {};
      data.id = (row.cells[0]?.textContent || '').trim();
      data.name = (row.cells[1]?.textContent || '').trim();
      // Helper to read numeric input or fallback text
      function readNum(sel, cellIndex) {
        const el = row.querySelector(sel);
        if (el) {
          // Prefer form control .value when available, else textContent
          const v = (typeof el.value !== 'undefined' && el.matches('input,select,textarea')) ? el.value : el.textContent;
          const num = parseFloat(String(v).replace(/,/g,''));
          if (!isNaN(num)) return num;
        }
        // Fallback to cell index text if selector not found or not numeric
        const cellVal = row.cells[cellIndex] && row.cells[cellIndex].textContent;
        const num2 = parseFloat(String(cellVal).replace(/,/g,''));
        return isNaN(num2) ? 0 : num2;
    }
      // Column index fallbacks aligned with current payrollTable structure
      // 0:ID, 1:Name, 2:Rate, 3:RegHrs, 4:OTHrs, 5:AdjHrs, 6:TotalHrs, 7:RegPay, 8:OTPay, 9:Adjustments,
      // 10:Bantay, 11:Gross, 12:Pag-IBIG, 13:PhilHealth, 14:SSS, 15:SSS Loan, 16:Pag-IBIG Loan,
      // 17:Vale, 18:Wed Vale, 19:Total Ded, 20:Net Pay, 21:Payslip
      data.rate = readNum('.rate', 2);
      data.regHrs = readNum('.regHrs', 3);
      data.otHrs = readNum('.otHrs', 4);
      data.adjHrs = readNum('.adjHrs', 5);
      data.totalHrs = readNum('.totalHrs', 6);
      data.regPay = readNum('.regPay', 7);
      data.otPay = readNum('.otPay', 8);
      data.adjAmt = readNum('.adjAmt', 9);
      data.bantay = readNum('.bantay', 10);
      data.grossPay = readNum('.grossPay', 11);
      data.pagibig = readNum('.pagibig', 12);
      data.philhealth = readNum('.philhealth', 13);
      data.sss = readNum('.sss', 14);
      data.loanSSS = readNum('.loanSSS', 15);
      data.loanPI = readNum('.loanPI', 16);
      data.vale = readNum('.vale', 17);
      data.valeWed = readNum('.valeWed', 18);
      data.totalDed = readNum('.totalDed', 19);
      data.netPay = readNum('.netPay', 20);
      try {
        const rawDed = row && row.dataset ? row.dataset.adjustmentDeduction : null;
        if (rawDed != null && rawDed !== '') {
          const parsed = parseFloat(String(rawDed).replace(/,/g,''));
          if (!isNaN(parsed)) {
            data.adjustmentDeduction = parsed;
          }
        }
        if (typeof data.adjustmentDeduction === 'undefined') {
          const val = adjustments && data.id ? Number(adjustments[data.id] ?? 0) : 0;
          data.adjustmentDeduction = splitAdjustmentValue(val).deduction;
        }
      } catch (e) {
        const val = adjustments && data.id ? Number(adjustments[data.id] ?? 0) : 0;
        data.adjustmentDeduction = splitAdjustmentValue(val).deduction;
      }
      // Capture DTR records for this employee within the selected date range. Stores an array of {date, times}
      try {
        /*
         * Use the inâ€‘memory storedRecords array (populated from Supabase) to
         * derive attendance for payroll exports.  Avoid reading from
         * localStorage so that stale browser caches do not leak into
         * crossâ€‘device exports.  The records array is filtered by the
         * current employee and date range, grouped by date, and then
         * converted into { date, times } objects for export.
         */
        const recs = Array.isArray(storedRecords) ? storedRecords : [];
        const start = startDate || '';
        const end = endDate || '';
        const empRecs = recs.filter(r => r && String(r.empId) === String(data.id) && (!start || r.date >= start) && (!end || r.date <= end));
        const grouped = {};
        empRecs.forEach(r => {
          if (!r || !r.date) return;
          const d = r.date;
          if (!grouped[d]) grouped[d] = [];
          if (r.time && !grouped[d].includes(r.time)) grouped[d].push(r.time);
        });
        const arr = [];
        Object.keys(grouped).sort().forEach(dateKey => {
          const times = grouped[dateKey].sort();
          arr.push({ date: dateKey, times });
        });
        data.dtrs = arr;
      } catch (e) {
        // ignore parse errors
      }
      rows.push(data);
    });
    // Read totals from footer
    const totals = {};
    const footRow = document.querySelector('#payrollTable tfoot tr');
    if (footRow) {
      footRow.querySelectorAll('[data-col]').forEach(td => {
        const key = td.dataset.col;
        const raw = (td.textContent || '').trim();
        const normalized = raw.replace(/,/g, '');
        const num = Number(normalized);
        totals[key] = Number.isFinite(num) ? num : 0;
      });
    }

    let divisorValue = 1;
    try {
      const input = document.getElementById('deductionDivisor');
      const maybeInput = input ? parseInt(input.value, 10) : NaN;
      if (!isNaN(maybeInput) && isFinite(maybeInput) && maybeInput > 0) {
        divisorValue = maybeInput;
      } else if (typeof window !== 'undefined' && typeof window.divisor !== 'undefined') {
        const winDiv = Number(window.divisor);
        if (!isNaN(winDiv) && isFinite(winDiv) && winDiv > 0) {
          divisorValue = winDiv;
        } else if (typeof localStorage !== 'undefined') {
          const key = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
          const stored = parseInt((localStorage && localStorage.getItem(key)) || '1', 10);
          if (!isNaN(stored) && isFinite(stored) && stored > 0) divisorValue = stored;
        }
      } else if (typeof localStorage !== 'undefined') {
        const key = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
        const stored = parseInt((localStorage && localStorage.getItem(key)) || '1', 10);
        if (!isNaN(stored) && isFinite(stored) && stored > 0) divisorValue = stored;
      }
    } catch (e) {}
    if (!divisorValue || !isFinite(divisorValue) || divisorValue <= 0) divisorValue = 1;

    return { startDate, endDate, rows, totals, divisor: divisorValue };
  }
  // Expose buildSnapshot globally so it can be called from other scripts
  window.buildSnapshot = buildSnapshot;

  /**
   * Disable payroll and DTR editing across the application. Once a payroll
   * period is locked, users should not be able to adjust hours, rates, or
   * manually enter or delete DTR entries for that period. This helper
   * centralizes the logic so both global and per-row lock actions can reuse
   * it. Date range controls and Generate/Lock buttons are also disabled.
   */
  function disablePayrollInputs() {
    // Disable all editable fields in the payroll table
    document.querySelectorAll('#payrollTable input').forEach(inp => {
      inp.disabled = true;
    });
    // Disable DTR inputs, buttons and selects (manual DTR, delete buttons, filters, etc.)
    document.querySelectorAll('#panelMain input, #panelMain button, #panelMain select').forEach(el => {
      el.disabled = true;
    });
    // Additionally disable key DTR controls explicitly by ID. While the generic selector above
    // should catch most elements, some dynamically inserted controls (or those outside
    // #panelMain) may escape. Explicitly disabling them ensures search fields, date filters,
    // project dropdowns and import/export buttons cannot be used once locked. These IDs
    // correspond to the manual DTR workflow and DTR filtering controls.
    ['dtrSearchName','dtrDateFrom','dtrDateTo','dtrDateClear','filterProject','fileInput','manualDtrBtn','printDtrBtn','dtrDateRangeFrom','dtrDateRangeTo'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = true;
    });
    // Disable all select elements within the results table (project and schedule selectors)
    document.querySelectorAll('#resultsTable select').forEach(sel => {
      sel.disabled = true;
    });
    // Disable any DTR delete buttons that may have been added
    document.querySelectorAll('.dtr-del-btn').forEach(btn => {
      btn.disabled = true;
    });

    // Add a locked class to the DTR panel to disable pointer events. This is a
    // visual and functional safeguard for cases where individual inputs might
    // get re-enabled by other scripts. The CSS defined above ensures
    // #panelMain.locked blocks all interaction with its contents.
    const pm = document.getElementById('panelMain');
    if (pm) pm.classList.add('locked');
    // Also disable inputs and buttons within the manual DTR modal if it exists. The modal is not
    // nested under #panelMain, so we need to explicitly target it. Without this, users could
    // potentially enter a manual record even after locking by using the modal fields directly.
    document.querySelectorAll('#manualDtrModal input, #manualDtrModal button, #manualDtrModal select').forEach(el => {
      el.disabled = true;
    });
    // Disable dashboard date range inputs and action buttons
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const genBtn = document.getElementById('dashGenerate');
    if (ws) ws.disabled = true;
    if (we) we.disabled = true;
    if (genBtn) genBtn.disabled = true;
    // Ensure the payroll tab reflects the locked state as well
    try { setPayrollLockedUI(true); } catch (err) { /* no-op if helper is unavailable */ }
  }
  // Expose helper globally so other scripts can disable editing
  window.disablePayrollInputs = disablePayrollInputs;

  /**
   * Re-enable payroll and DTR editing across the application. This should be
   * called when the user changes the date range after locking, or when a
   * snapshot is unlocked. It resets disabled fields and action buttons.
   */
  function enablePayrollInputs() {
    // Re-enable payroll table inputs
    document.querySelectorAll('#payrollTable input').forEach(inp => {
      inp.disabled = false;
    });
    // Re-enable DTR inputs, buttons and selects
    document.querySelectorAll('#panelMain input, #panelMain button, #panelMain select').forEach(el => {
      el.disabled = false;
    });
    // Re-enable specific DTR controls by ID that were explicitly disabled in
    // disablePayrollInputs(). This ensures search, date filters, project filter,
    // and import/export controls become usable again when the payroll is unlocked
    // or the date range is changed.
    ['dtrSearchName','dtrDateFrom','dtrDateTo','dtrDateClear','filterProject','fileInput','manualDtrBtn','printDtrBtn','dtrDateRangeFrom','dtrDateRangeTo'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = false;
    });
    // Re-enable selects in the results table (project and schedule selectors)
    document.querySelectorAll('#resultsTable select').forEach(sel => {
      sel.disabled = false;
    });
    // Re-enable any DTR delete buttons
    document.querySelectorAll('.dtr-del-btn').forEach(btn => {
      btn.disabled = false;
    });

    // Remove the locked class from the DTR panel so pointer events and
    // interaction are restored. When the user switches to an unlocked period or
    // explicitly unlocks a snapshot, this class must be removed.
    const pm = document.getElementById('panelMain');
    if (pm) pm.classList.remove('locked');
    // Re-enable manual DTR modal fields and buttons. When a payroll is unlocked or the date
    // range changes, users should be able to enter manual DTR entries again. This undoes the
    // disablement applied in disablePayrollInputs().
    document.querySelectorAll('#manualDtrModal input, #manualDtrModal button, #manualDtrModal select').forEach(el => {
      el.disabled = false;
    });
    // Re-enable dashboard date range and action buttons
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const genBtn = document.getElementById('dashGenerate');
    if (ws) ws.disabled = false;
    if (we) we.disabled = false;
    if (genBtn) genBtn.disabled = false;
    // Restore interactivity for the payroll tab when unlocked
    try { setPayrollLockedUI(false); } catch (err) { /* no-op if helper is unavailable */ }
  }
  // Expose helper globally so other scripts can enable editing
  window.enablePayrollInputs = enablePayrollInputs;

  /**
   * Determine whether the currently selected payroll period is locked by
   * consulting the persisted lock map. Returns true when the range has an
   * active lock entry.
   */
  function isSelectedPeriodLocked() {
    const range = getCurrentPeriodRange();
    if (!range.start || !range.end) return false;
    const entry = getLockEntry(range.start, range.end);
    return !!(entry && entry.locked);
  }
  window.isSelectedPeriodLocked = isSelectedPeriodLocked;

  /**
   * Check the current payroll period and toggle editing state accordingly. If the
   * selected period is locked, all payroll/DTR inputs are disabled and the
   * date inputs are marked as forced. If the period is not locked, editing is
   * enabled and the forced flags are removed. This helper centralizes the
   * logic of determining lock status and applying the appropriate UI state.
  */
  function checkAndToggleEditState() {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (!wsEl || !weEl) return;
    const locked = applyLockUI();
    if (locked) {
      wsEl.dataset.forced = 'true';
      weEl.dataset.forced = 'true';
    } else {
      if (wsEl.dataset) delete wsEl.dataset.forced;
      if (weEl.dataset) delete weEl.dataset.forced;
    }
  }
  window.checkAndToggleEditState = checkAndToggleEditState;

  // Persist payrollHistory to localStorage
  function saveHistory() {
    localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(payrollHistory));
  }
  // Expose saveHistory globally so it can be called from other scripts
  window.saveHistory = saveHistory;

  // Handler for Generate button: build and save a snapshot without locking
  dashGenerateBtn && dashGenerateBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    // Prevent duplicate snapshots for the same date range. If any snapshot (locked or active)
    // already exists with this start/end, alert the user and skip creation. This avoids
    // doubleâ€‘entry payroll for the same period.
    const exists = Array.isArray(payrollHistory) && payrollHistory.some(snap =>
      snap && snap.startDate === start && snap.endDate === end);
    if (exists) {
      alert('A payroll snapshot for this date range already exists. Please choose a different range or delete the existing entry.');
      return;
    }
    // Ensure all payroll values are recalculated before taking a snapshot for generation
    try {
      if (typeof calculateAll === 'function') {
        calculateAll();
      }
    } catch (e) {
      // Suppress errors from calculateAll; snapshot will reflect current cell values
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false });
    saveHistory();
    // Update both history and active payroll tables after creating a new snapshot
    renderHistory();
    if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
  });

  dashLockButton && dashLockButton.addEventListener('click', async () => {
    try {
      await Promise.resolve(lockCurrentPeriod());
    } catch (err) {
      console.warn('Lock & Snapshot failed', err);
    }
  });

  dashUnlockButton && dashUnlockButton.addEventListener('click', async () => {
    try {
      await Promise.resolve(unlockCurrentPeriod());
    } catch (err) {
      console.warn('Unlock period failed', err);
    }
  });

  // Helper: build snapshot storage key matching lockPeriod persistence
  function composeSnapshotStorageKey(segment, startDate, endDate) {
    try {
      const startPart = normalizeSnapshotKeyPart(startDate);
      const endPart = normalizeSnapshotKeyPart(endDate);
      return `snap:${segment}:p:${startPart}:${endPart}`;
    } catch (err) {
      console.warn('Failed to compose snapshot key', err);
      return '';
    }
  }

  async function readSnapshotSegment(segment, startDate, endDate) {
    const key = composeSnapshotStorageKey(segment, startDate, endDate);
    if (!key) return null;
    if (typeof window.readKV === 'function') {
      try {
        const remote = await window.readKV(key, null);
        if (remote != null) return remote;
      } catch (err) {
        console.warn('KV read failed for', key, err);
      }
    }
    try {
      const raw = localStorage.getItem(key);
      if (raw != null) return JSON.parse(raw);
    } catch (err) {
      console.warn('Local snapshot read failed for', key, err);
    }
    return null;
  }

  const HTML_ESCAPE = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
  function escapeHtml(value) {
    return String(value ?? '').replace(/[&<>"']/g, (ch) => HTML_ESCAPE[ch] || ch);
  }

  function normalizeRowLength(row, length) {
    const out = Array.isArray(row) ? row.slice(0, length) : [];
    while (out.length < length) out.push('');
    return out;
  }

  function buildTableHtml(headers, rows, options = {}) {
    const cols = Array.isArray(headers) ? headers.slice() : [];
    const bodyRows = Array.isArray(rows) ? rows : [];
    const numericCols = new Set(options.numericCols || []);
    const classes = options.columnClasses || {};
    const thead = cols.map((text, idx) => {
      const cls = classes[idx] ? ` class="${classes[idx]}"` : '';
      return `<th${cls}>${escapeHtml(text)}</th>`;
    }).join('');
    const tbody = bodyRows.length ? bodyRows.map((row) => {
      const cells = normalizeRowLength(row, cols.length).map((cell, idx) => {
        const raw = cell == null ? '' : cell;
        const numeric = numericCols.has(idx) || (/^-?\d+(?:\.\d+)?$/.test(String(raw).replace(/,/g, '')));
        const cls = numeric ? ' class="num"' : '';
        return `<td${cls}>${escapeHtml(raw)}</td>`;
      }).join('');
      return `<tr>${cells}</tr>`;
    }).join('') : `<tr><td class="muted" colspan="${Math.max(cols.length, 1)}">No data</td></tr>`;
    let foot = '';
    if (Array.isArray(options.footerRow)) {
      const footerCells = normalizeRowLength(options.footerRow, cols.length).map((cell, idx) => {
        const raw = cell == null ? '' : cell;
        const numeric = numericCols.has(idx) || (/^-?\d+(?:\.\d+)?$/.test(String(raw).replace(/,/g, '')));
        const cls = numeric ? ' class="num"' : '';
        return `<td${cls}>${escapeHtml(raw)}</td>`;
      }).join('');
      foot = `<tfoot><tr>${footerCells}</tr></tfoot>`;
    }
    return `<table class="report-table"><thead><tr>${thead}</tr></thead><tbody>${tbody}</tbody>${foot}</table>`;
  }

  function dropColumns(headers, rows, predicate) {
    const cols = Array.isArray(headers) ? headers.slice() : [];
    const drop = [];
    cols.forEach((h, idx) => {
      if (predicate(h, idx)) drop.push(idx);
    });
    if (!drop.length) return { headers: cols, rows };
    const filteredHeaders = cols.filter((_, idx) => !drop.includes(idx));
    const filteredRows = (rows || []).map((row) => {
      const arr = Array.isArray(row) ? row : [];
      return arr.filter((_, idx) => !drop.includes(idx));
    });
    return { headers: filteredHeaders, rows: filteredRows };
  }

  function formatDateRangeInline(start, end) {
    try {
      if (typeof formatDateRange === 'function') return formatDateRange(start, end);
    } catch (err) {}
    if (start && end) return `${start} - ${end}`;
    return start || end || '';
  }

  function formatNumber(val) {
    const num = Number(val);
    if (!isFinite(num)) return '';
    return num.toFixed(2);
  }

  function buildPayrollSectionFromSnapshot(snap) {
    const headers = ['ID','Name','Hourly Rate','Regular Hours','OT Hours','Adjustment Hrs','Total Hours','Regular Pay','OT Pay','Adjustments','Bantay','Gross Pay','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Account','Wed Vale','Total Deductions','Net Pay','Adj Deduction'];
    const numericCols = headers.map((_, idx) => idx).filter(idx => idx > 1);
    const rows = Array.isArray(snap?.rows) ? snap.rows.map((row) => {
      return [
        row.id || '',
        row.name || '',
        formatNumber(row.rate),
        formatNumber(row.regHrs),
        formatNumber(row.otHrs),
        formatNumber(row.adjHrs),
        formatNumber(row.totalHrs),
        formatNumber(row.regPay),
        formatNumber(row.otPay),
        formatNumber(row.adjAmt),
        formatNumber(row.bantay),
        formatNumber(row.grossPay),
        formatNumber(row.pagibig),
        formatNumber(row.philhealth),
        formatNumber(row.sss),
        formatNumber(row.loanSSS),
        formatNumber(row.loanPI),
        formatNumber(row.vale),
        formatNumber(row.valeWed),
        formatNumber(row.totalDed),
        formatNumber(row.netPay),
        formatNumber(row.adjustmentDeduction)
      ];
    }) : [];
    const totals = snap?.totals || {};
    const footer = headers.map((label, idx) => {
      if (idx === 0) return 'Totals';
      if (idx === 1) return '';
      const keyMap = ['rate','regHrs','otHrs','adjHrs','totalHrs','regPay','otPay','adjAmt','bantay','grossPay','pagibig','philhealth','sss','loanSSS','loanPI','vale','valeWed','totalDed','netPay','adjustmentDeduction'];
      const key = keyMap[idx - 2];
      const val = key ? totals[key] : null;
      return formatNumber(val);
    });
    const range = formatDateRangeInline(snap?.startDate, snap?.endDate);
    const subtitle = range ? `<div class="report-subtitle">${escapeHtml(range)}</div>` : '';
    const table = buildTableHtml(headers, rows, { numericCols, footerRow: footer });
    return `<section class="report-block"><h2>Payroll Report</h2>${subtitle}${table}</section>`;
  }

  function buildDtrSectionFromSnapshot(data, startDate, endDate) {
    if (!data) return '';
    const filtered = dropColumns(data.headers || [], data.rows || [], (header) => {
      const norm = String(header || '').trim().toLowerCase();
      return norm === 'actions' || norm === 'split' || norm === 'editor';
    });
    const range = formatDateRangeInline(startDate, endDate);
    const subtitle = range ? `<div class="report-subtitle">${escapeHtml(range)}</div>` : '';
    const table = buildTableHtml(filtered.headers, filtered.rows, { numericCols: [] });
    return `<section class="report-block"><h2>Daily Time Records</h2>${subtitle}${table}</section>`;
  }

  function buildDetailedSectionFromSnapshot(data) {
    if (!data) return '';
    const headers = Array.isArray(data.headers) ? data.headers : [];
    const rows = Array.isArray(data.rows) ? data.rows : [];
    const table = buildTableHtml(headers, rows, {});
    return `<section class="report-block"><h2>Detailed Report</h2>${table}</section>`;
  }

  function buildMasterSectionFromSnapshot(master, startDate, endDate) {
    const range = formatDateRangeInline(startDate, endDate);
    const subtitle = range ? `<div class="report-subtitle">${escapeHtml(range)}</div>` : '';
    const inner = master && typeof master.html === 'string' && master.html.trim() ? master.html : '<p class="muted">No master report data available.</p>';
    return `<section class="report-block"><h2>Master Report</h2>${subtitle}<div class="master-wrapper">${inner}</div></section>`;
  }

  async function exportCombinedPdfForSnapshot(snap) {
    if (!snap) return;
    const w = window.open('', '_blank', 'width=1024,height=768');
    if (!w) {
      alert('Popup blocked. Please allow popups to generate the PDF.');
      return;
    }

    try {
      w.document.write('<!doctype html><html><head><title>Preparing PDF…</title><style>body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:24px;color:#0f172a;}p{margin:0;font-size:14px;}</style></head><body><p>Preparing PDF…</p></body></html>');
      w.document.close();
    } catch (err) {
      console.warn('Unable to seed PDF window', err);
    }

    const startDate = snap.startDate || '';
    const endDate = snap.endDate || '';
    let dtr, reports, master;
    try {
      [dtr, reports, master] = await Promise.all([
        readSnapshotSegment('dtr', startDate, endDate),
        readSnapshotSegment('reports', startDate, endDate),
        readSnapshotSegment('master', startDate, endDate)
      ]);
    } catch (err) {
      console.warn('Failed to read snapshot segments', err);
      try { w.document.body.innerHTML = '<p style="color:#dc2626;">Unable to load snapshot data for PDF export.</p>'; } catch {}
      return;
    }

    const sections = [];
    sections.push(buildDtrSectionFromSnapshot(dtr, startDate, endDate));
    sections.push(buildPayrollSectionFromSnapshot({
      rows: snap.rows || [],
      totals: snap.totals || {},
      startDate,
      endDate
    }));
    sections.push(buildDetailedSectionFromSnapshot(reports));
    sections.push(buildMasterSectionFromSnapshot(master, startDate, endDate));

    const filteredSections = sections.filter(Boolean).join('');
    if (!filteredSections) {
      alert('No report data is available for this snapshot.');
      try { w.close(); } catch {}
      return;
    }

    const doc = `<!doctype html><html><head><meta charset="utf-8"><title>Payroll Reports PDF</title><style>
      @page { margin: 12mm; }
      html,body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:0;color:#0f172a;}
      body{padding:16px;background:#fff;}
      h2{margin:0 0 6px 0;font-size:20px;}
      .report-subtitle{font-size:12px;color:#475569;margin-bottom:10px;}
      .report-block{margin-bottom:32px;page-break-inside:avoid;}
      .report-block:last-of-type{margin-bottom:0;}
      table{width:100%;border-collapse:collapse;font-size:11px;margin-top:8px;}
      th,td{border:0.6pt solid #1e293b;padding:4px 6px;vertical-align:middle;}
      th{background:#e2e8f0;text-align:left;}
      td.num{text-align:right;font-variant-numeric:tabular-nums;white-space:nowrap;}
      thead{display:table-header-group;}
      tfoot td{font-weight:600;background:#f8fafc;}
      .muted{color:#94a3b8;text-align:center;}
      .master-wrapper table{border-color:#1e293b;}
    </style></head><body>${filteredSections}</body></html>`;

    w.document.open();
    w.document.write(doc);
    w.document.close();
    setTimeout(() => {
      try { safePrint(w); }
      catch (err) { try { w.print(); } catch (_) {} }
    }, 100);
  }

  // Delegate open/download actions on history table
  function normalizeSnapshotKeyPart(value) {
    if (!value) return '';
    if (value instanceof Date && !isNaN(value.getTime())) {
      return String(value.getFullYear()) + String(value.getMonth() + 1).padStart(2, '0') + String(value.getDate()).padStart(2, '0');
    }
    const str = String(value);
    const iso = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (iso) return iso[1] + iso[2] + iso[3];
    const parsed = new Date(str);
    if (!isNaN(parsed)) {
      return String(parsed.getFullYear()) + String(parsed.getMonth() + 1).padStart(2, '0') + String(parsed.getDate()).padStart(2, '0');
    }
    return str.replace(/[^0-9]/g, '');
  }

  function buildSnapshotStorageKeys(startDate, endDate) {
    const pid = `p:${normalizeSnapshotKeyPart(startDate)}:${normalizeSnapshotKeyPart(endDate)}`;
    return [
      `snap:dtr:${pid}`,
      `snap:payroll:${pid}`,
      `snap:reports:${pid}`,
      `snap:deductions:${pid}`
    ];
  }

  async function purgeStoredSnapshot(startDate, endDate) {
    const keys = buildSnapshotStorageKeys(startDate, endDate);
    if (typeof localStorage !== 'undefined') {
      keys.forEach((key) => {
        try { localStorage.removeItem(key); }
        catch (err) { console.warn('localStorage remove failed', err); }
      });
    }
    try {
      if (window.supabase && window.SUPABASE_TABLE && typeof window.supabase.from === 'function') {
        const { error } = await window.supabase
          .from(window.SUPABASE_TABLE)
          .delete()
          .in('key', keys);
        if (error) console.warn('Supabase delete error', error);
      }
    } catch (err) {
      console.warn('Supabase purge failed', err);
    }
  }

  historyTableBody && historyTableBody.addEventListener('click', async (e) => {
    const target = e.target;
    if (!target) return;
    const actionBtn = target.closest('button');
    if (!actionBtn) {
      const row = target.closest('tr');
      if (!row || !historyTableBody.contains(row)) return;
      try { if (typeof row.focus === 'function') row.focus({ preventScroll: true }); } catch {}
      return;
    }
    const idxStr = actionBtn.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (actionBtn.classList.contains('exportAllTabs')) {
      // Export the All Tabs Excel for this snapshot's date range
      try {
        if (typeof window.exportExcelAllTabsForRange === 'function') {
          window.exportExcelAllTabsForRange(snap.startDate, snap.endDate, {
            divisorOverride: snap.divisor,
            snapshot: { rows: snap.rows, totals: snap.totals, divisor: snap.divisor }
          });
        } else if (typeof window.exportExcelAllTabs === 'function') {
          // Fallback: set range, rebuild, then export
          const ws = document.getElementById('weekStart');
          const we = document.getElementById('weekEnd');
          const prevS = ws && ws.value; const prevE = we && we.value;
          if (ws) ws.value = snap.startDate || prevS; if (we) we.value = snap.endDate || prevE;
          try{ if (typeof calculatePayrollFromResultsTable==='function') calculatePayrollFromResultsTable(); else if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); }catch(e){}
          try{ if (typeof window.rebuildReports === 'function') window.rebuildReports(); }catch(e){}
          const overrideVal = Number(snap.divisor);
          const hasOverride = !isNaN(overrideVal) && isFinite(overrideVal) && overrideVal > 0;
          setTimeout(function(){
            let appliedOverride = false;
            try{
              if (hasOverride && typeof window !== 'undefined') {
                window.__snapshotDivisorOverride = overrideVal;
                appliedOverride = true;
              }
              window.exportExcelAllTabs();
            }catch(e){}
            // Restore previous range and rebuild
            setTimeout(function(){
              try{ if (ws) ws.value = prevS; if (we) we.value = prevE; if (typeof window.rebuildReports==='function') window.rebuildReports(); }catch(e){}
              if (appliedOverride && typeof window !== 'undefined') {
                try { delete window.__snapshotDivisorOverride; }
                catch(err){ window.__snapshotDivisorOverride = undefined; }
              }
            }, 0);
          }, 300);
        }
      } catch(e){}
      return;
    }
    if (actionBtn.classList.contains('exportAllPdf')) {
      try {
        if (typeof exportCombinedPdfForSnapshot === 'function') {
          await exportCombinedPdfForSnapshot(snap);
        }
      } catch (err) {
        console.warn('Combined PDF export failed', err);
        alert('Unable to build the combined PDF for this snapshot.');
      }
      return;
    }
    if (actionBtn.classList.contains('deleteSnapshot')) {
      // Delete a snapshot from history if it is not locked
      if (snap.locked) return; // Skip deletion for locked snapshots
      const confirmDel = confirm('Are you sure you want to delete this payroll record? This cannot be undone.');
      if (!confirmDel) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      return;
    }
  });


  // Initial render on page load
  renderHistory();
  if (typeof renderActivePayrolls === 'function') renderActivePayrolls();


});
</script>
   </div>
  </section>
  <section class="panel" id="panelProjectTotals">
  <style>
    #panelProjectTotals .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:18px;box-shadow:0 4px 18px rgba(0,0,0,.06)}
    #panelProjectTotals .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
    #panelProjectTotals table{border-collapse:collapse;width:100%}
    #panelProjectTotals th,#panelProjectTotals td{border:1px solid #dbe3ef;padding:6px 8px;font-size:12px;text-align:center;white-space:nowrap}
    #panelProjectTotals thead th{background:#eef4fb;font-weight:700}
    #panelProjectTotals tr.proj-break td{background:#b9f2ff;font-weight:700;text-align:left}
    #panelProjectTotals .totals{background:#fff7ed;font-weight:700}
    #panelProjectTotals .left{text-align:left}
    #panelProjectTotals .num{text-align:right}
    /* Match Payroll sub-tab look-and-feel for any Reports subtabs */
    #panelProjectTotals, #panelReports { --border:#e2e8f0; --accent:#FFD700 }
    #panelProjectTotals .subtab-nav, #panelReports .subtab-nav { display:flex; gap:6px; flex-wrap:wrap; margin-bottom:10px }
    #panelProjectTotals .tab-btn, #panelProjectTotals .subtab-btn,
    #panelReports .tab-btn, #panelReports .subtab-btn { padding:8px 12px; border:1px solid var(--border); background:#fff; border-radius:8px; cursor:pointer }
    #panelProjectTotals .tab-btn.active, #panelProjectTotals .subtab-btn.active,
    #panelReports .tab-btn.active, #panelReports .subtab-btn.active { background:var(--accent); color:#fff; border-color:var(--accent) }
    #panelProjectTotals .subtab-panel{ display:none }
    #panelProjectTotals .subtab-panel.active{ display:block }
    /* Master Report table styling */
    #panelProjectTotals .mr h2{ text-align:center; margin:8px 0 14px 0; font-size:20px }
    #panelProjectTotals .mr-period{ text-align:center; margin:0 0 18px 0; font-size:13px; color:#475569 }
    #panelProjectTotals .mr-period span{ font-weight:600 }
    #panelProjectTotals .mr-period .mr-period-missing{ font-weight:400; color:#94a3b8; font-style:italic }
    #panelProjectTotals .mr h4{ margin:10px 0 6px 0 }
    #panelProjectTotals .mr .mr-project-title{ text-align:center }
    #panelProjectTotals .mr-table{ width:100%; border-collapse:collapse; font-size:12px }
    #panelProjectTotals .mr-table th, #panelProjectTotals .mr-table td{ border:1px solid #dbe3ef; padding:6px 8px; text-align:left }
    #panelProjectTotals .mr-table .mr-num{ text-align:right; font-variant-numeric:tabular-nums; white-space:nowrap }
    #panelProjectTotals .mr-contrib-table th, #panelProjectTotals .mr-contrib-table td{ text-align:center }
    #panelProjectTotals .mr-table.mr-site-payroll .mr-site-label{ text-align:left }
    #panelProjectTotals .mr-table.mr-site-payroll thead th.mr-site-label{ text-align:left }
    #panelProjectTotals .mr-table.mr-site-payroll tfoot th,
    #panelProjectTotals .mr-table.mr-site-payroll tfoot td{ font-weight:600; background:#f8fafc }
    #panelProjectTotals .mr-table th.left, #panelProjectTotals .mr-table td.left{ text-align:left }
    #panelProjectTotals .mr-table tfoot td{ font-weight:700; background:#fff7ed }
    #panelProjectTotals .mr-table tr.mr-company th{ text-align:center; background:#eef4fb; font-size:13px }
    /* Print: one sheet per project, repeat header; hide grand total (redundant) */
    @media print{
      header,.header,.controls{display:none!important}
      .card{box-shadow:none;border:0;padding:0}
      #r_table thead{display:table-header-group}
      #r_table tfoot{display:none!important}
      #r_table tbody.proj-page{display:table-row-group;break-inside:avoid;page-break-inside:avoid}
      #r_table tbody.proj-page{break-before:page;page-break-before:always}
      #r_table tbody.proj-page:first-of-type{break-before:auto;page-break-before:auto}
      /* Master report print tweaks */
      #masterReportContainer .mr-table thead{display:table-header-group}
    }
  </style>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Reports</h3>
    <div class="subtab-nav">
      <button class="tab-btn subtab-btn active" data-subtab="reportsDetailedTab" id="btnReportsDetailed">Detailed</button>
      <button class="tab-btn subtab-btn" data-subtab="masterReportTab" id="btnMasterReport">Master Report</button>
    </div>

    <!-- Detailed (existing) reports view -->
    <div id="reportsDetailedTab" class="subtab-panel active">
      <div class="controls">
        <button id="r_print">Print</button>
        <button id="r_csv">CSV (All)</button>
        <span id="r_range_hint" style="font-size:12px;color:#64748b;margin-left:auto;"></span>
      </div>
      <div id="r_msg" style="font-size:13px;color:#64748b;display:none;"></div>
      <table id="r_table" aria-live="polite"></table>
    </div>

    <!-- New Master Report view -->
    <div id="masterReportTab" class="subtab-panel">
      <div class="controls">
        <button id="mr_print">Print</button>
      </div>
      <div id="masterReportContainer" class="mr"></div>
    </div>
  </div>

  <script>
  (function(){
    let __report = null;

    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    const toNum = v => { const n = parseFloat(String(v||'').replace(/,/g,'')); return isNaN(n)?0:n; };
    const f2  = n => { const x = Number(n)||0; return x===0 ? '-' : x.toLocaleString('en-US',{minimumFractionDigits:2, maximumFractionDigits:2}); };
    const showMsg = (t)=>{ const m=$('#r_msg'); if(m){ m.textContent=t; m.style.display=t?'block':'none'; } };

    const isRealProject = (p)=>{
      if (!p) return false;
      const s = String(p).trim().toLowerCase();
      return s && !['(none)','none','-','null','undefined',''].includes(s);
    };

    function cssEscape(val){ return String(val).replace(/["\\\\]/g, '\\\\$&'); }

    function getPayrollRange(){
      try{
        const ws = document.getElementById('weekStart')?.value;
        const we = document.getElementById('weekEnd')?.value;
        if (ws && we) return [ws,we];
      }catch(e){}
      try{
        const ls_ws = localStorage.getItem('payroll_week_start');
        const ls_we = localStorage.getItem('payroll_week_end');
        if (ls_ws && ls_we) return [String(ls_ws).replace(/\"/g,''), String(ls_we).replace(/\"/g,'')];
      }catch(e){}
      try{
        const sel = document.getElementById('activePayrollSelect');
        const txt = sel && sel.options && sel.selectedIndex>=0 ? sel.options[sel.selectedIndex].textContent : '';
        const m = txt && txt.match(/(\d{4}-\d{2}-\d{2}).*?(\d{4}-\d{2}-\d{2})/);
        if (m) return [m[1], m[2]];
      }catch(e){}
      const trs = $$('#resultsTable tbody tr');
      let minD=1e20, maxD=-1e20;
      trs.forEach(tr=>{
        const d = tr.cells[4]?.textContent?.trim();
        if(!d) return;
        const t = new Date(d).setHours(0,0,0,0);
        if (!isNaN(t)){ minD = Math.min(minD,t); maxD = Math.max(maxD,t); }
      });
      if (maxD < minD) {
        const today = new Date().toISOString().slice(0,10);
        return [today,today];
      }
      return [new Date(minD).toISOString().slice(0,10), new Date(maxD).toISOString().slice(0,10)];
    }

    function eachDate(fromMS,toMS){
      const out=[]; let t=fromMS;
      while(t<=toMS){ out.push(new Date(t)); t += 86400000; }
      return out;
    }

    // --- Robust rate lookup ---
    function getRateById(id){
      try{
        const se = (window.storedEmployees||{})[id];
        if (se){
          const r = toNum(se.hourlyRate ?? se.rate ?? se.hourly_rate ?? se.payRate ?? se.wage);
          if (r) return r;
        }
      }catch(e){}
      try{
        const pr = (window.payrollRates||{})[id];
        if (pr) return toNum(pr);
      }catch(e){}
      const inp = document.querySelector(`.emp-rate-input[data-id="${cssEscape(id)}"]`);
      if (inp) return toNum(inp.value || inp.textContent);
      return 0;
    }
    function getRateByName(name){
      if (!name) return 0;
      const target = String(name).toUpperCase();
      try{
        const se = window.storedEmployees||{};
        for (const [id, e] of Object.entries(se)){
          if ((e?.name||'').toUpperCase() === target){
            const r = toNum(e.hourlyRate ?? e.rate ?? e.hourly_rate ?? e.payRate ?? e.wage);
            if (r) return r;
          }
        }
      }catch(e){}
      const rows = $$('#employeesTable tbody tr');
      for (const tr of rows){
        const nm = (tr.querySelector('.emp-name-input')?.value || tr.cells[1]?.textContent || '').trim().toUpperCase();
        if (nm === target){
          const inp = tr.querySelector('.emp-rate-input');
          if (inp) return toNum(inp.value || inp.textContent);
        }
      }
      return 0;
    }
    function getRate(id, name){ return getRateById(id) || getRateByName(name); }

    function readProjectFromRow(tr){
      const sel = tr.cells[2]?.querySelector('select');
      if (sel){
        const opt = sel.options[sel.selectedIndex];
        const txt = (opt && (opt.textContent||opt.label)) || sel.value;
        return (txt||'').trim();
      }
      const dp = tr.cells[2]?.dataset?.project;
      if (dp) return String(dp).trim();
      return (tr.cells[2]?.textContent||'').trim();
    }

    function collect(fromStr, toStr){
      const M = {};
      const trs = $$('#resultsTable tbody tr');
      trs.forEach(tr=>{
        const id   = (tr.cells[0]?.textContent||'').trim();
        const name = (tr.cells[1]?.textContent||'').trim();
        const proj = readProjectFromRow(tr);
        const date = (tr.cells[4]?.textContent||'').trim();
        const rwh = toNum(tr.cells[11]?.textContent) || toNum(tr.querySelector('.regHrs')?.value);
        const oth = toNum(tr.cells[12]?.textContent) || toNum(tr.querySelector('.otHrs')?.value);
        if(!id || !date) return;
        if(!isRealProject(proj)) return;

        const d = new Date(date).setHours(0,0,0,0);
        if(fromStr){ const f = new Date(fromStr).setHours(0,0,0,0); if(d < f) return; }
        if(toStr){ const t = new Date(toStr).setHours(0,0,0,0); if(d > t) return; }

        (M[proj] = M[proj]||{});
        (M[proj][id] = M[proj][id]||{ name, days:{} });
        const slot = M[proj][id].days[d] || { rwh:0, oth:0 };
        slot.rwh += rwh; slot.oth += oth;
        M[proj][id].days[d] = slot;
      });
      return M;
    }

    function buildTable(){
      const dtrRows = $$('#resultsTable tbody tr');
      const table = $('#r_table'); if(!table) return;
      if (dtrRows.length === 0){
        showMsg('No DTR rows found. Import DTR or open a period first.');
        table.innerHTML='';
        __report = null;
        return;
      }
      showMsg('');

      const [from, to] = getPayrollRange();
      const dates = eachDate(new Date(from).setHours(0,0,0,0), new Date(to).setHours(0,0,0,0));
      const data = collect(from, to) || {};
      // Ensure projects that only have Bantay allowance (no DTR rows) appear as their own blocks
      try {
        const bp = (typeof bantayProj !== 'undefined' && bantayProj) || {};
        const b  = (typeof bantay !== 'undefined' && bantay) || {};
        const sp = (typeof storedProjects !== 'undefined' && storedProjects) || {};
        const allowByProjName = {};
        Object.keys(b).forEach(empId => {
          const amt = parseFloat((b[empId]) || 0) || 0;
          if (amt <= 0) return;
          const assigned = bp[empId];
          if (!assigned) return;
          const projName = (sp[assigned] && sp[assigned].name) ? sp[assigned].name : assigned;
          if (!isRealProject(projName)) return;
          allowByProjName[projName] = (allowByProjName[projName] || 0) + amt;
        });
        Object.keys(allowByProjName).forEach(pn => { if (!data[pn]) data[pn] = {}; });
      } catch (e) { /* ignore */ }
      __report = { data, from, to, dates };

      const totalCols = 2 + (dates.length*2) + 4;
      const hint = $('#r_range_hint');
      if (hint) hint.textContent = `Range: ${from} - ${to}`;

      // THEAD
      let thead1 = `<tr><th class="left" rowspan="2">PERSONNEL</th><th rowspan="2">RATE</th>`;
      dates.forEach(d=>{
        const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
        thead1 += `<th colspan="2">${lbl}</th>`;
      });
      thead1 += `<th rowspan="2">TOTAL REG HRS</th><th rowspan="2">TOTAL OT HRS</th><th rowspan="2">GRAND TOTAL HOURS</th><th rowspan="2">GROSS</th></tr>`;
      let thead2 = `<tr>${dates.map(()=>`<th>RWH</th><th>OTH</th>`).join('')}</tr>`;

      // Per-project TBODY blocks
      const tbodies = [];
      let gReg=0,gOT=0,gGross=0;
      const gDayTotals = dates.map(() => ({ rwh: 0, oth: 0 }));
      const projects = Object.keys(data).sort();

      projects.forEach(proj=>{
        const empMap = data[proj];
        let pReg=0,pOT=0,pGross=0;
        const dayTotals = dates.map(() => ({ rwh: 0, oth: 0 }));
        let rows='';

        rows += `<tr class="proj-break"><td colspan="${totalCols}">${proj}</td></tr>`;

        Object.keys(empMap).sort((a,b)=>{
          const A = (empMap[a].name||a).toUpperCase();
          const B = (empMap[b].name||b).toUpperCase();
          return A.localeCompare(B);
        }).forEach(empId=>{
          const rec = empMap[empId];
          const display = rec.name || empId;
          const rate = getRate(empId, display);
          let rReg=0,rOT=0;

          const cells = dates.map((d,i)=>{
            const key = d.setHours(0,0,0,0);
            const v = rec.days[key] || { rwh:0, oth:0 };
            rReg += v.rwh; rOT += v.oth;
            dayTotals[i].rwh += v.rwh; dayTotals[i].oth += v.oth;
            return `<td class="num">${f2(v.rwh)}</td><td class="num">${f2(v.oth)}</td>`;
          }).join('');

          const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
          const gross = (rReg * rate) + (rOT * rate * otMult);
          pReg += rReg; pOT += rOT; pGross += gross;

          rows += `<tr>
            <td class="left">${display}</td>
            <td class="num">${f2(rate)}</td>
            ${cells}
            <td class="num">${f2(rReg)}</td>
            <td class="num">${f2(rOT)}</td>
            <td class="num">${f2(rReg + rOT)}</td>
            <td class="num">${f2(gross)}</td>
          </tr>`;
        });

// Compute per-project Bantay allowance (Supabase-backed)
const allow = Object.keys(bantay || {}).reduce((sum, empId) => {
  const assigned = (bantayProj || {})[empId];
  if (!assigned) return sum;
  const matchesById   = (assigned === proj);
  const matchesByName = ((storedProjects && storedProjects[assigned]?.name) === proj);
  return (matchesById || matchesByName) ? sum + (parseFloat(bantay[empId]) || 0) : sum;
}, 0);

// Render Allowance row (amount in Gross column)
rows += `<tr class="allowance">
  <td class="left">Allowance</td>
  <td class="num">-</td>
  ${dates.map(()=>`<td class="num">-</td><td class="num">-</td>`).join('')}
  <td class="num">-</td>
  <td class="num">-</td>
  <td class="num">-</td>
  <td class="num">${f2(allow)}</td>
</tr>`;

  // Include allowance in project gross
  pGross += allow;

  rows += `<tr class="totals">
            <td class="left">Project Total</td>
            <td class="num">-</td>
            ${dayTotals.map(dt => `<td class="num">${f2(dt.rwh)}</td><td class="num">${f2(dt.oth)}</td>`).join('')}
            <td class="num">${f2(pReg)}</td>
            <td class="num">${f2(pOT)}</td>
            <td class="num">${f2(pReg + pOT)}</td>
            <td class="num">${f2(pGross)}</td>
          </tr>`;

          gReg += pReg; gOT += pOT; gGross += pGross;
          dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });

          tbodies.push(`<tbody class="proj-page">${rows}</tbody>`);
        });

        const foot = `<tr class="totals">
          <td class="left">Grand Total</td>
          <td class="num">-</td>
          ${gDayTotals.map(dt => `<td class="num">${f2(dt.rwh)}</td><td class="num">${f2(dt.oth)}</td>`).join('')}
          <td class="num">${f2(gReg)}</td>
          <td class="num">${f2(gOT)}</td>
          <td class="num">${f2(gReg + gOT)}</td>
          <td class="num">${f2(gGross)}</td>
        </tr>`;

      $('#r_table').innerHTML = `<thead>${thead1}${thead2}</thead>${tbodies.join('')}<tfoot>${foot}</tfoot>`;

      // Commas for numeric cells
      (function applyCommas(){
        const fmt = (v)=>{
          const n = parseFloat(String(v||'').replace(/,/g,''));
          if (isNaN(n)) return v;
          return n.toLocaleString('en-US',{minimumFractionDigits:2, maximumFractionDigits:2});
        };
        const cells = Array.from(document.querySelectorAll('#r_table td.num, #r_table tfoot td.num'));
        cells.forEach(td=>{ td.textContent = fmt(td.textContent); });
      })();
    }

    function csvEscape(s){
      if (s == null) return '';
      s = String(s);
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    }
    function to2(n){ n = parseFloat(String(n).replace(/,/g,'')); if (isNaN(n)) n = 0; return (Math.round(n*100)/100).toFixed(2); }

    function buildDetailedReportRows(){
      if (!__report) return null;
      const { data, dates, from, to } = __report;

      const dayHeader = dates.map(d=>{
        const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
        return [`RWH ${lbl}`, `OTH ${lbl}`];
      }).flat();

      const header = ['PROJECT','PERSONNEL','RATE']
        .concat(dayHeader)
        .concat(['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);
      const rows = [header];

      const projects = Object.keys(data).sort();
      let gReg=0,gOT=0,gGross=0;
      const gDayTotals = dates.map(() => ({ rwh:0, oth:0 }));

      projects.forEach(proj=>{
        const empMap = data[proj];
        let pReg=0,pOT=0,pGross=0;
        const dayTotals = dates.map(() => ({ rwh:0, oth:0 }));

        Object.keys(empMap).sort((a,b)=>{
          const A = (empMap[a].name||a).toUpperCase();
          const B = (empMap[b].name||b).toUpperCase();
          return A.localeCompare(B);
        }).forEach(empId=>{
          const rec = empMap[empId];
          const display = rec.name || empId;

          const rate = getRate(empId, display);

          let rReg=0,rOT=0;
          const dayCells = [];
          dates.forEach((d,i)=>{
            const key = d.setHours(0,0,0,0);
            const v = rec.days[key] || { rwh:0, oth:0 };
            rReg += v.rwh; rOT += v.oth;
            dayTotals[i].rwh += v.rwh; dayTotals[i].oth += v.oth;
            dayCells.push(to2(v.rwh), to2(v.oth));
          });

          const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
          const gross = (rReg * rate) + (rOT * rate * otMult);
          pReg += rReg; pOT += rOT; pGross += gross;

          rows.push([proj, display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg + rOT), to2(gross)]));
        });

        // Add per-project Allowance row (amount placed in GROSS column)
        try {
          const allow = Object.keys(bantay || {}).reduce((sum, empId) => {
            const assigned = (bantayProj || {})[empId];
            if (!assigned) return sum;
            const matchesById   = (assigned === proj);
            const matchesByName = ((typeof storedProjects !== 'undefined' && storedProjects && storedProjects[assigned]?.name) === proj);
            const amt = parseFloat((bantay && bantay[empId]) || 0) || 0;
            return (matchesById || matchesByName) ? (sum + amt) : sum;
          }, 0);
          // Push a CSV row for Allowance with zero hours and gross = allowance
          const zeroCells = new Array(dates.length*2).fill('0.00');
          rows.push([proj, 'Allowance', ''].concat(zeroCells, ['0.00','0.00','0.00', to2(allow)]));
          // Include allowance in project gross before rolling into grand totals
          pGross += allow;
        } catch (e) { /* no-op if allowance data missing */ }

        gReg += pReg; gOT += pOT; gGross += pGross;
        dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });
        const dayTotalsCells = dayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
        rows.push([proj, 'Project Total', ''].concat(
          dayTotalsCells,
          [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]
        ));
      });

      const gDayTotalsCells = gDayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
      rows.push(['', 'Grand Total', ''].concat(
        gDayTotalsCells,
        [to2(gReg), to2(gOT), to2(gReg+gOT), to2(gGross)]
      ));

      return { rows, from, to };
    }

    // Some report rebuilds rely on async data fetches. Wait briefly for the
    // detailed rows to populate so Excel exports capture the final dataset.
    async function waitForDetailedReportBundle(maxWaitMs = 8000, pollMs = 200){
      const started = Date.now();
      const hasDataRows = (bundle) => {
        if (!bundle || !Array.isArray(bundle.rows)) return false;
        if (bundle.rows.length > 2) return true;
        return bundle.rows.some((row, idx) => {
          if (!row || idx === 0) return false;
          return row.some(cell => String(cell ?? '').trim() !== '');
        });
      };
      while ((Date.now() - started) < maxWaitMs){
        if (!__report && typeof window.rebuildReports === 'function'){
          try { window.rebuildReports(); } catch(e){}
        }
        const bundle = buildDetailedReportRows();
        if (hasDataRows(bundle)){
          return bundle;
        }
        const renderedRows = (() => {
          try {
            return document.querySelectorAll('#r_table tbody tr').length;
          } catch(_){ return 0; }
        })();
        if (renderedRows > 0){
          const refreshed = buildDetailedReportRows();
          if (hasDataRows(refreshed)){
            return refreshed;
          }
        }
        await new Promise(resolve => setTimeout(resolve, pollMs));
      }
      if (!__report && typeof window.rebuildReports === 'function'){
        try { window.rebuildReports(); } catch(e){}
      }
      return buildDetailedReportRows();
    }

    function exportCSVAll(){
      const bundle = buildDetailedReportRows();
      if (!bundle){ alert('No report to export yet.'); return; }
      const { rows, from, to } = bundle;
      const csv = rows.map(r=>r.map(csvEscape).join(',')).join('\n');
      const a=document.createElement('a');
      a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
      a.download=`reports_all_${from}_to_${to}.csv`;
      a.click(); URL.revokeObjectURL(a.href);
    }

    function tableToAoA(tbl){
      const rows = [];
      if (!tbl) return rows;
      const pushRow = (tr) => {
        if (!tr || !tr.cells) return;
        const arr = [];
        for (let i = 0; i < tr.cells.length; i++){
          const cell = tr.cells[i];
          arr.push((cell.textContent || '').trim());
        }
        rows.push(arr);
      };
      if (tbl.tHead){ Array.from(tbl.tHead.rows || []).forEach(pushRow); }
      Array.from(tbl.tBodies || []).forEach(tb => { Array.from(tb.rows || []).forEach(pushRow); });
      if (tbl.tFoot){ Array.from(tbl.tFoot.rows || []).forEach(pushRow); }
      return rows;
    }

    function buildDtrAoA(){
      const table = document.getElementById('resultsTable');
      if (!table) return null;

      const selectedTexts = [];
      table.querySelectorAll('select').forEach(sel => {
        let txt = '';
        try {
          const idx = sel.selectedIndex;
          if (idx >= 0 && sel.options && sel.options[idx]){
            const opt = sel.options[idx];
            txt = (opt.textContent || opt.innerText || opt.value || '');
          }
        } catch(e){}
        selectedTexts.push((txt || '').trim());
      });

      const clone = table.cloneNode(true);
      clone.querySelectorAll('select').forEach((sel, idx) => {
        const td = sel.closest('td');
        if (td){ td.textContent = selectedTexts[idx] || ''; }
      });
      clone.querySelectorAll('button').forEach(btn => btn.remove());

      const dropIdx = [];
      if (clone.tHead && clone.tHead.rows && clone.tHead.rows[0]){
        const headerRow = clone.tHead.rows[0];
        for (let i = 0; i < headerRow.cells.length; i++){
          const txt = (headerRow.cells[i].textContent || '').trim().toLowerCase();
          if (txt === 'split' || txt === 'actions' || txt === 'editor'){ dropIdx.push(i); }
        }
      }
      if (dropIdx.length){
        const unique = Array.from(new Set(dropIdx)).sort((a,b)=> b - a);
        const removeCols = (tr) => {
          if (!tr || !tr.cells) return;
          unique.forEach(idx => {
            try { if (idx >=0 && idx < tr.cells.length) tr.deleteCell(idx); } catch(e){}
          });
        };
        if (clone.tHead){ Array.from(clone.tHead.rows || []).forEach(removeCols); }
        Array.from(clone.tBodies || []).forEach(tb => { Array.from(tb.rows || []).forEach(removeCols); });
        if (clone.tFoot){ Array.from(clone.tFoot.rows || []).forEach(removeCols); }
      }

      const aoa = tableToAoA(clone);
      return (aoa && aoa.length) ? aoa : null;
    }

    async function buildPayrollAoA(){
      const src = document.getElementById('payrollTable');
      if (!src) return null;

      const startDate = document.getElementById('weekStart')?.value || '';
      const endDate = document.getElementById('weekEnd')?.value || '';
      const title = (startDate && endDate) ? `Payroll Report (${startDate} to ${endDate})` : 'Payroll Report';
      const header = [
        'ID','Name','Hourly Rate','Regular Hours','OT Hours','Adjustment Hrs','Total Hours',
        'Regular Pay','OT Pay','Adjustments','Bantay','Gross Pay',
        'Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Account','Wed Vale',
        'Total Deductions','Net Pay'
      ];

      let snapshotOverride = null;
      try {
        if (typeof window !== 'undefined' && window.__snapshotPayrollOverride && typeof window.__snapshotPayrollOverride === 'object') {
          snapshotOverride = window.__snapshotPayrollOverride;
        }
      } catch (e) {}

      const key = (typeof LS_DIVISOR !== 'undefined') ? LS_DIVISOR : 'payroll_deduction_divisor';
      let divisorOverride = null;
      try {
        if (typeof window !== 'undefined' && typeof window.__snapshotDivisorOverride !== 'undefined') {
          const maybe = Number(window.__snapshotDivisorOverride);
          if (!isNaN(maybe) && isFinite(maybe) && maybe > 0) divisorOverride = maybe;
        }
      } catch (e) {}
      let divisor = divisorOverride || 1;
      if (!divisorOverride) {
        try {
          if (typeof window !== 'undefined' && typeof window.divisor !== 'undefined') {
            const winDiv = Number(window.divisor);
            if (!isNaN(winDiv) && isFinite(winDiv) && winDiv > 0) divisor = winDiv;
          }
          if ((!divisor || !isFinite(divisor) || divisor <= 0) && typeof localStorage !== 'undefined') {
            const stored = Number(localStorage.getItem(key));
            if (!isNaN(stored) && isFinite(stored) && stored > 0) divisor = stored;
          }
        } catch (e) {}
      }
      if (!divisor || !isFinite(divisor) || divisor <= 0) divisor = 1;

      const toNum = (value, opts = {}) => {
        if (value == null || value === '') return 0;
        let n = value;
        if (typeof n === 'string') {
          n = parseFloat(n.replace(/,/g,''));
        } else if (typeof n !== 'number') {
          n = Number(n);
        }
        if (!isFinite(n) || isNaN(n)) n = 0;
        if (opts.divideLoan) n = n / divisor;
        return n;
      };
      const fmt = (value, opts = {}) => {
        const decimals = (typeof opts.decimals === 'number') ? opts.decimals : 2;
        return toNum(value, opts).toFixed(decimals);
      };

      async function buildFromSnapshot(){
        let snap = null;
        try {
          if (snapshotOverride) {
            snap = snapshotOverride;
          } else {
            if (typeof buildSnapshot !== 'function') return null;
            snap = await buildSnapshot(startDate, endDate);
          }
          if (!snap || !Array.isArray(snap.rows) || !snap.rows.length) return null;
          if (!divisorOverride) {
            const snapDiv = Number(snap.divisor);
            if (!isNaN(snapDiv) && isFinite(snapDiv) && snapDiv > 0) divisor = snapDiv;
          }

          const aoa = [[title], [''], header.slice()];
          const totals = {
            regHrs:0, otHrs:0, adjHrs:0, totalHrs:0,
            regPay:0, otPay:0, adjAmt:0, bantay:0, grossPay:0,
            pagibig:0, philhealth:0, sss:0,
            loanSSS:0, loanPI:0, vale:0, valeWed:0,
            totalDed:0, netPay:0
          };

          const rows = Array.isArray(snap.rows) ? snap.rows : [];
          rows.forEach(row => {
            const regHrsNum = toNum(row.regHrs);
            const otHrsNum = toNum(row.otHrs);
            const adjHrsNum = toNum(row.adjHrs);
            const totalHrsNum = toNum(row.totalHrs);
            const regPayNum = toNum(row.regPay);
            const otPayNum = toNum(row.otPay);
            const adjAmtNum = toNum(row.adjAmt);
            const bantayNum = toNum(row.bantay);
            const grossNum = toNum(row.grossPay);
            const pagibigNum = toNum(row.pagibig);
            const philhealthNum = toNum(row.philhealth);
            const sssNum = toNum(row.sss);
            const loanSSSNum = toNum(row.loanSSS, { divideLoan: true });
            const loanPINum = toNum(row.loanPI, { divideLoan: true });
            const valeNum = toNum(row.vale);
            const valeWedNum = toNum(row.valeWed);
            const totalDedNum = toNum(row.totalDed);
            const netPayNum = toNum(row.netPay);

            totals.regHrs += regHrsNum;
            totals.otHrs += otHrsNum;
            totals.adjHrs += adjHrsNum;
            totals.totalHrs += totalHrsNum;
            totals.regPay += regPayNum;
            totals.otPay += otPayNum;
            totals.adjAmt += adjAmtNum;
            totals.bantay += bantayNum;
            totals.grossPay += grossNum;
            totals.pagibig += pagibigNum;
            totals.philhealth += philhealthNum;
            totals.sss += sssNum;
            totals.loanSSS += loanSSSNum;
            totals.loanPI += loanPINum;
            totals.vale += valeNum;
            totals.valeWed += valeWedNum;
            totals.totalDed += totalDedNum;
            totals.netPay += netPayNum;

            aoa.push([
              row.id || '',
              row.name || '',
              fmt(row.rate),
              fmt(regHrsNum),
              fmt(otHrsNum),
              fmt(adjHrsNum),
              fmt(totalHrsNum),
              fmt(regPayNum),
              fmt(otPayNum),
              fmt(adjAmtNum),
              fmt(bantayNum),
              fmt(grossNum),
              fmt(pagibigNum),
              fmt(philhealthNum),
              fmt(sssNum),
              fmt(row.loanSSS, { divideLoan: true }),
              fmt(row.loanPI, { divideLoan: true }),
              fmt(valeNum),
              fmt(valeWedNum),
              fmt(totalDedNum),
              fmt(netPayNum)
            ]);
          });

          const storedTotals = (snap && snap.totals && typeof snap.totals === 'object') ? snap.totals : null;
          if (storedTotals) {
            const keyMap = {
              regHrs: 'regHrs',
              otHrs: 'otHrs',
              adjHrs: 'adjHrs',
              totalHrs: 'totalHrs',
              regPay: 'regPay',
              otPay: 'otPay',
              adjAmt: 'adjAmt',
              bantay: 'bantay',
              grossPay: 'grossPay',
              pagibig: 'pagibig',
              philhealth: 'philhealth',
              sss: 'sss',
              loanSSS: 'loanSSS',
              loanPI: 'loanPI',
              vale: 'vale',
              valeWed: 'valeWed',
              totalDed: 'totalDed',
              netPay: 'netPay'
            };
            Object.keys(keyMap).forEach(destKey => {
              const sourceKey = keyMap[destKey];
              if (Object.prototype.hasOwnProperty.call(storedTotals, sourceKey)) {
                const maybeNum = Number(storedTotals[sourceKey]);
                if (!isNaN(maybeNum) && isFinite(maybeNum)) {
                  totals[destKey] = maybeNum;
                }
              }
            });
          }

          if (aoa.length > 3) {
            aoa.push([
              'Grand Total','',
              '',
              fmt(totals.regHrs),
              fmt(totals.otHrs),
              fmt(totals.adjHrs),
              fmt(totals.totalHrs),
              fmt(totals.regPay),
              fmt(totals.otPay),
              fmt(totals.adjAmt),
              fmt(totals.bantay),
              fmt(totals.grossPay),
              fmt(totals.pagibig),
              fmt(totals.philhealth),
              fmt(totals.sss),
              fmt(totals.loanSSS),
              fmt(totals.loanPI),
              fmt(totals.vale),
              fmt(totals.valeWed),
              fmt(totals.totalDed),
              fmt(totals.netPay)
            ]);
          }

          return aoa;
        } catch (e) {
          console.warn('buildPayrollAoA snapshot build failed', e);
          return null;
        }
      }

      function buildDomFallback(){
        const clone = src.cloneNode(true);
        const removeLastCell = (row) => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
        if (clone.tHead){ Array.from(clone.tHead.rows || []).forEach(removeLastCell); }
        Array.from(clone.tBodies || []).forEach(tb => { Array.from(tb.rows || []).forEach(removeLastCell); });
        if (clone.tFoot){ Array.from(clone.tFoot.rows || []).forEach(removeLastCell); }

        clone.querySelectorAll('input').forEach(inp => {
          const td = inp.parentElement;
          if (!td) return;
          const cls = inp.classList || { contains: () => false };
          if (cls.contains('loanSSS') || cls.contains('loanPI')){
            const raw = parseFloat((inp.value || '').toString().replace(/,/g,'')) || 0;
            td.textContent = (raw / divisor).toFixed(2);
          } else {
            const val = (inp.value || inp.textContent || '').toString();
            td.textContent = val;
          }
        });

        clone.querySelectorAll('td').forEach(td => {
          if (td.querySelector('input')) return;
          const raw = (td.textContent || '').replace(/,/g,'').trim();
          if (!raw) return;
          const num = parseFloat(raw);
          if (!isNaN(num) && num === 0){ td.textContent = '-'; }
        });

        const aoa = [[title], ['']];
        tableToAoA(clone).forEach(row => aoa.push(row));
        return (aoa && aoa.length > 2) ? aoa : null;
      }

      const snapshotAoA = await buildFromSnapshot();
      if (snapshotAoA && snapshotAoA.length > 2) return snapshotAoA;
      return buildDomFallback();
    }

    function buildMasterReportAoA(){
      try { if (typeof window.renderMasterReport === 'function') window.renderMasterReport(); } catch(e){}
      const container = document.getElementById('masterReportContainer');
      if (!container) return null;
      const aoa = [];
      const pushRow = (cells) => {
        if (!cells) return;
        aoa.push(cells.map(val => {
          if (val == null) return '';
          return String(val).trim();
        }));
      };

      const title = container.querySelector('h2');
      if (title) pushRow([title.textContent.trim()]);
      const period = container.querySelector('.mr-period');
      if (period) pushRow([period.textContent.trim()]);

      let firstSection = true;
      container.querySelectorAll('.mr-section').forEach(section => {
        const heading = section.querySelector('h4');
        const tables = Array.from(section.querySelectorAll('table'));
        if (!heading && !tables.length) return;
        if (!firstSection) pushRow(['']);
        firstSection = false;
        if (heading) pushRow([heading.textContent.trim()]);
        tables.forEach((table, idx) => {
          const before = aoa.length;
          tableToAoA(table).forEach(row => pushRow(row));
          if (idx !== tables.length - 1 && aoa.length > before) pushRow(['']);
        });
      });

      while (aoa.length && aoa[aoa.length-1].every(cell => !String(cell || '').trim())) aoa.pop();
      return (aoa && aoa.length) ? aoa : null;
    }

    // Export an Excel workbook with one sheet per project
    function exportExcelAllSheets(){
      try{
        if (typeof XLSX === 'undefined' || !XLSX || !XLSX.utils) { alert('Excel library not available'); return; }
        if (!__report) { if (typeof window.rebuildReports==='function') window.rebuildReports(); }
        if (!__report) { alert('No report to export yet.'); return; }
        const { data, dates, from, to } = __report;
        const wb = XLSX.utils.book_new();
        // Helper: build headers
        const dayHeader = dates.map(d=>{
          const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
          return [`RWH ${lbl}`, `OTH ${lbl}`];
        }).flat();
        const header = ['PERSONNEL','RATE'].concat(dayHeader, ['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);
        // Build one sheet per project
        const projects = Object.keys(data).sort();
        let gReg=0,gOT=0,gGross=0;
        const gDayTotals = dates.map(()=>({ rwh:0, oth:0 }));
        const summaryRows = [['PROJECT'].concat(header)];
        projects.forEach(proj=>{
          const empMap = data[proj];
          const rows = [header.slice()];
          let pReg=0,pOT=0,pGross=0;
          const dayTotals = dates.map(()=>({ rwh:0, oth:0 }));
          Object.keys(empMap).sort((a,b)=>{
            const A = (empMap[a].name||a).toUpperCase();
            const B = (empMap[b].name||b).toUpperCase();
            return A.localeCompare(B);
          }).forEach(empId=>{
            const rec = empMap[empId];
            const display = rec.name || empId;
            const rate = getRate(empId, display);
            let rReg=0,rOT=0;
            const dayCells = [];
            dates.forEach((d,i)=>{
              const key = d.setHours(0,0,0,0);
              const v = rec.days[key] || { rwh:0, oth:0 };
              rReg += v.rwh; rOT += v.oth;
              dayTotals[i].rwh += v.rwh; dayTotals[i].oth += v.oth;
              dayCells.push(to2(v.rwh), to2(v.oth));
            });
            const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
            const gross = (rReg * rate) + (rOT * rate * otMult);
            pReg += rReg; pOT += rOT; pGross += gross;
            rows.push([display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg+rOT), to2(gross)]));
            summaryRows.push([proj, display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg+rOT), to2(gross)]));
          });
          // Allowance-only row from on-screen report logic
          try{
            const allow = Object.keys(bantay || {}).reduce((sum, empId) => {
              const assigned = (bantayProj || {})[empId];
              if (!assigned) return sum;
              const matchesById   = (assigned === proj);
              const matchesByName = ((typeof storedProjects !== 'undefined' && storedProjects && storedProjects[assigned]?.name) === proj);
              const amt = parseFloat((bantay && bantay[empId]) || 0) || 0;
              return (matchesById || matchesByName) ? (sum + amt) : sum;
            }, 0);
            if (allow && allow > 0){
              const zeros = new Array(dates.length*2).fill('0.00');
              rows.push(['Allowance',''].concat(zeros, ['0.00','0.00','0.00', to2(allow)]));
              summaryRows.push([proj, 'Allowance',''].concat(zeros, ['0.00','0.00','0.00', to2(allow)]));
              pGross += allow;
            }
          }catch(e){}
          gReg += pReg; gOT += pOT; gGross += pGross;
          dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });
          const dayTotalsCells = dayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
          rows.push(['Project Total',''].concat(dayTotalsCells, [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]));
          summaryRows.push([proj,'Project Total',''].concat(dayTotalsCells,[to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]));
          const ws = XLSX.utils.aoa_to_sheet(rows);
          XLSX.utils.book_append_sheet(wb, ws, (proj || 'Project').toString().substring(0,31));
        });
        // Summary sheet with grand totals
        const gDayTotalsCells = gDayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
        summaryRows.push(['','Grand Total',''].concat(gDayTotalsCells, [to2(gReg), to2(gOT), to2(gReg+gOT), to2(gGross)]));
        const wsSummary = XLSX.utils.aoa_to_sheet(summaryRows);
        XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
        const fname = `reports_all_${from}_to_${to}.xlsx`;
        XLSX.writeFile(wb, fname);
      }catch(e){ console.warn('Excel export failed', e); alert('Excel export failed.'); }
    }

    // Expose for external triggers (lock automation)
    try { window.exportExcelAllSheets = exportExcelAllSheets; } catch(e){}

    // Export a single workbook that includes sheets for DTR, Payroll, and the Master Report
    async function exportExcelAllTabs(){
      try{
        if (typeof XLSX === 'undefined' || !XLSX || !XLSX.utils) { alert('Excel library not available'); return; }
        if (typeof window.rebuildReports === 'function') window.rebuildReports();
        const detailBundle = await waitForDetailedReportBundle();
        if (!detailBundle){ alert('No report to export yet.'); return; }
        const { from, to } = detailBundle;
        const wb = XLSX.utils.book_new();

        try {
          const dtrAoA = buildDtrAoA();
          if (dtrAoA && dtrAoA.length){
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(dtrAoA), 'DTR');
          }
        } catch(e){ console.warn('Failed to build DTR sheet', e); }

        try {
          const payrollAoA = await buildPayrollAoA();
          if (payrollAoA && payrollAoA.length){
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(payrollAoA), 'Payroll');
          }
        } catch(e){ console.warn('Failed to build Payroll sheet', e); }

        try {
          const masterAoA = buildMasterReportAoA();
          if (masterAoA && masterAoA.length){
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(masterAoA), 'Master Report');
          }
        } catch(e){ console.warn('Failed to build Master Report sheet', e); }

        if (!wb.SheetNames.length){
          alert('Nothing to export.');
          return;
        }

        const safeFrom = (from && String(from).trim()) || 'start';
        const safeTo = (to && String(to).trim()) || 'end';
        const fname = (from || to) ? `all_tabs_${safeFrom}_to_${safeTo}.xlsx` : 'all_tabs.xlsx';
        XLSX.writeFile(wb, fname);
      }catch(e){ console.warn('Excel export failed', e); alert('Excel export failed'); }
    }

    try { window.exportExcelAllTabs = exportExcelAllTabs; } catch(e){}
    // Bind UI button for Excel (All Tabs)
    try {
      var xBtn = document.getElementById('r_xlsx');
      if (xBtn && !xBtn.__xlsxBound){ xBtn.addEventListener('click', async function(ev){ ev.preventDefault(); try { await exportExcelAllTabs(); } catch(e){ console.warn('Excel (All Tabs) export failed', e); } }); xBtn.__xlsxBound = true; }
    } catch(e){}

    // Export for a specific date range (used by Payroll History actions)
    async function exportExcelAllTabsForRange(from, to, opts = {}){
      try{
        const ws = document.getElementById('weekStart');
        const we = document.getElementById('weekEnd');
        const prevS = ws && ws.value;
        const prevE = we && we.value;
        const targetS = from || prevS;
        const targetE = to || prevE;
        const changed = (targetS !== prevS) || (targetE !== prevE);
        const options = (opts && typeof opts === 'object') ? opts : {};
        const snapshotOverride = (options.snapshot && typeof options.snapshot === 'object') ? options.snapshot : null;
        let overrideVal = Number(options.divisorOverride);
        let hasOverride = !isNaN(overrideVal) && isFinite(overrideVal) && overrideVal > 0;
        if (!hasOverride && snapshotOverride && typeof snapshotOverride.divisor !== 'undefined') {
          const snapDivisor = Number(snapshotOverride.divisor);
          if (!isNaN(snapDivisor) && isFinite(snapDivisor) && snapDivisor > 0) {
            overrideVal = snapDivisor;
            hasOverride = true;
          }
        }

        function recalcForActiveRange(){
          try{ if (typeof syncPeriodScopedData === 'function') syncPeriodScopedData(); }catch(e){}
          try{
            if (typeof calculatePayrollFromResultsTable === 'function') {
              calculatePayrollFromResultsTable();
            } else if (typeof calculatePayrollFromRecords === 'function') {
              calculatePayrollFromRecords();
            }
          }catch(e){}
          try{ if (typeof checkAndToggleEditState === 'function') checkAndToggleEditState(); }catch(e){}
          try{ if (typeof window.rebuildReports === 'function') window.rebuildReports(); }catch(e){}
        }

        if (ws) ws.value = targetS;
        if (we) we.value = targetE;

        recalcForActiveRange();

        setTimeout(async function(){
          let appliedOverride = false;
          let appliedSnapshot = false;
          try{
            if (snapshotOverride && typeof window !== 'undefined') {
              window.__snapshotPayrollOverride = snapshotOverride;
              appliedSnapshot = true;
            }
            if (hasOverride && typeof window !== 'undefined') {
              window.__snapshotDivisorOverride = overrideVal;
              appliedOverride = true;
            }
            await exportExcelAllTabs();
          } catch(err){
            console.warn('Export (all tabs) for range failed', err);
          } finally {
            if (appliedSnapshot && typeof window !== 'undefined') {
              try { delete window.__snapshotPayrollOverride; }
              catch(e){ window.__snapshotPayrollOverride = undefined; }
            }
            if (appliedOverride && typeof window !== 'undefined') {
              try { delete window.__snapshotDivisorOverride; }
              catch(e){ window.__snapshotDivisorOverride = undefined; }
            }
            if (ws) ws.value = prevS;
            if (we) we.value = prevE;
            if (changed) {
              recalcForActiveRange();
            } else {
              try{ if (typeof checkAndToggleEditState === 'function') checkAndToggleEditState(); }catch(e){}
              try{ if (typeof window.rebuildReports === 'function') window.rebuildReports(); }catch(e){}
            }
          }
        }, 300);
      }catch(e){ console.warn('Export for range failed', e); }
    }
    try { window.exportExcelAllTabsForRange = exportExcelAllTabsForRange; } catch(e){}

    function exportCSVPerProject(){
      if (!__report){ alert('No report to export yet.'); return; }
      const { data, dates, from, to } = __report;

      const dayHeader = dates.map(d=>{
        const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
        return [`RWH ${lbl}`, `OTH ${lbl}`];
      }).flat();
      const header = ['PERSONNEL','RATE'].concat(dayHeader, ['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);

      const projects = Object.keys(data).sort();
      projects.forEach(proj=>{
        const empMap = data[proj];
        const rows = [header];
        let pReg=0,pOT=0,pGross=0;

        Object.keys(empMap).sort((a,b)=>{
          const A = (empMap[a].name||a).toUpperCase();
          const B = (empMap[b].name||b).toUpperCase();
          return A.localeCompare(B);
        }).forEach(empId=>{
          const rec = empMap[empId];
          const display = rec.name || empId;
          const rate = getRate(empId, display);

          let rReg=0,rOT=0;
          const dayCells = [];
          dates.forEach(d=>{
            const key = d.setHours(0,0,0,0);
            const v = rec.days[key] || { rwh:0, oth:0 };
            rReg += v.rwh; rOT += v.oth;
            dayCells.push(to2(v.rwh), to2(v.oth));
          });

          const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
          const gross = (rReg * rate) + (rOT * rate * otMult);
          pReg += rReg; pOT += rOT; pGross += gross;

          rows.push([display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg + rOT), to2(gross)]));
        });

        rows.push(['Project Total', ''].concat(
          new Array(dates.length*2).fill(''),
          [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]
        ));

        const csv = rows.map(r=>r.map(csvEscape).join(',')).join('\n');
        const a=document.createElement('a');
        const safeProj = proj.replace(/[^a-z0-9_\-]+/gi,'_');
        a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
        a.download=`report_${safeProj}_${from}_to_${to}.csv`;
        a.click(); URL.revokeObjectURL(a.href);
      });
    }

  // Use the clean per-project print handler defined later; avoid double-binding here.
  // $('#r_print')?.addEventListener('click', ()=> safePrint());
    // Subtab wiring for Detailed/Master
    (function(){
      const btns = Array.from(document.querySelectorAll('#panelProjectTotals .subtab-btn'));
      function show(id){
        btns.forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('#panelProjectTotals .subtab-panel').forEach(p=>p.classList.remove('active'));
        const target = document.getElementById(id);
        if (target) target.classList.add('active');
        const activator = document.querySelector(`#panelProjectTotals .subtab-btn[data-subtab="${id}"]`);
        if (activator) activator.classList.add('active');
        if (id === 'masterReportTab') { try{ renderMasterReport(); }catch(e){} }
      }
      btns.forEach(b=>{ if (b._wired) return; b._wired = true; b.addEventListener('click', ()=> show(b.getAttribute('data-subtab'))); });
    })();

    $('#r_csv')?.addEventListener('click', exportCSVAll);const dtr = document.getElementById('resultsTable');
    if (dtr && 'MutationObserver' in window){
      const mo = new MutationObserver(()=> { buildTable(); try{ renderMasterReport(); }catch(e){} });
      mo.observe(dtr, { childList:true, subtree:true });
    }
    // Expose a global rebuild hook so other tabs (e.g., Payroll bantay edits)
    // can refresh the report without a full page reload.
    try { window.rebuildReports = function(){ try{ buildTable(); }catch(e){} try{ renderMasterReport(); }catch(e){} }; } catch(e){}
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ buildTable(); try{ renderMasterReport(); }catch(e){} }, { once:true });
    } else { buildTable(); try{ renderMasterReport(); }catch(e){} }
  })();
  </script>
</section>
<!-- Master Report builder (contributions summary + per-project totals) -->
<script>
(function(){
  // Utilities
  function num(v){ const n=parseFloat(String(v||'').replace(/,/g,'')); return isNaN(n)?0:n; }
  function f2(n){ const x=Number(n)||0; return x.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2}); }
  function safe(val){ return String(val==null?'':val); }

  const CONTRIBUTION_FIELDS = ['piEE','piER','phEE','phER','sssEE','sssER','loanSSS','loanPI'];
  const makeContributionBucket = () => ({ piEE:0, piER:0, phEE:0, phER:0, sssEE:0, sssER:0, loanSSS:0, loanPI:0 });
  const renderContributionTable = (bucket, opts = {}) => {
    const data = bucket || makeContributionBucket();
    const rowClassAttr = opts.rowClass ? ` class="${opts.rowClass}"` : '';
    const cellStyleAttr = opts.bold ? ' style="font-weight:600;"' : '';
    const cell = (value) => `<td${cellStyleAttr}>${f2(value)}</td>`;
    const toNum = (v) => Number(v || 0);
    if (opts.combineEEER) {
      const piTotal = toNum(data.piEE) + toNum(data.piER);
      const phTotal = toNum(data.phEE) + toNum(data.phER);
      const sssTotal = toNum(data.sssEE) + toNum(data.sssER);
      return '<table class="mr-table mr-contrib-table"><thead>'+
        '<tr><th>PAG-IBIG</th><th>PHILHEALTH</th><th>SSS</th><th>SSS LOAN</th><th>PAG-IBIG LOAN</th></tr>'+
        `</thead><tbody><tr${rowClassAttr}>${cell(piTotal)}${cell(phTotal)}${cell(sssTotal)}${cell(data.loanSSS)}${cell(data.loanPI)}</tr></tbody></table>`;
    }
    return '<table class="mr-table mr-contrib-table"><thead>'+
      '<tr><th colspan="2">PAG-IBIG</th><th colspan="2">PHILHEALTH</th><th colspan="2">SSS</th><th rowspan="2">SSS LOAN</th><th rowspan="2">PAG-IBIG LOAN</th></tr>'+
      '<tr><th>EE</th><th>ER</th><th>EE</th><th>ER</th><th>EE</th><th>ER</th></tr>'+
      `</thead><tbody><tr${rowClassAttr}>${cell(data.piEE)}${cell(data.piER)}${cell(data.phEE)}${cell(data.phER)}${cell(data.sssEE)}${cell(data.sssER)}${cell(data.loanSSS)}${cell(data.loanPI)}</tr></tbody></table>`;
  };

  const renderSitePayrollTable = (orderedCompanies, totalsByCompany, opts = {}) => {
    const bucketFactory = (typeof opts.makeBucket === 'function') ? opts.makeBucket : makeContributionBucket;
    const safeFn = (typeof opts.safe === 'function') ? opts.safe : safe;
    const companies = Array.isArray(orderedCompanies) ? orderedCompanies : [];
    const groups = [
      { label: 'PAG-IBIG', keys: ['piEE', 'piER'] },
      { label: 'PHILHEALTH', keys: ['phEE', 'phER'] },
      { label: 'SSS', keys: ['sssEE', 'sssER'] }
    ];
    const singles = [
      { label: 'SSS LOAN', key: 'loanSSS' },
      { label: 'PAG-IBIG LOAN', key: 'loanPI' }
    ];

    const ensureBucket = (name) => {
      const label = (typeof name === 'string' && name.trim().length) ? name.trim() : 'Unassigned';
      if (totalsByCompany && totalsByCompany[label]) return totalsByCompany[label];
      return bucketFactory();
    };

    const totals = bucketFactory();
    const rows = [];

    companies.forEach(companyName => {
      const bucket = ensureBucket(companyName);
      const rowCells = [`<th scope="row" class="mr-site-label">${safeFn(companyName)}</th>`];
      groups.forEach(group => {
        group.keys.forEach((key, idx) => {
          const value = Number(bucket && bucket[key] != null ? bucket[key] : 0);
          totals[key] += value;
          rowCells.push(`<td>${f2(value)}</td>`);
        });
      });
      singles.forEach(single => {
        const value = Number(bucket && bucket[single.key] != null ? bucket[single.key] : 0);
        totals[single.key] += value;
        rowCells.push(`<td>${f2(value)}</td>`);
      });
      rows.push(`<tr>${rowCells.join('')}</tr>`);
    });

    const totalRow = () => {
      if (!companies.length) return '';
      const cells = [`<th scope="row" class="mr-site-label">TOTAL</th>`];
      groups.forEach(group => {
        group.keys.forEach(key => {
          const value = Number(totals && totals[key] != null ? totals[key] : 0);
          cells.push(`<td>${f2(value)}</td>`);
        });
      });
      singles.forEach(single => {
        const value = Number(totals && totals[single.key] != null ? totals[single.key] : 0);
        cells.push(`<td>${f2(value)}</td>`);
      });
      return `<tr class="mr-site-total">${cells.join('')}</tr>`;
    };

    const headerTop = [
      '<tr>',
      '<th rowspan="2" class="mr-site-label">SITE PAYROLL</th>',
      ...groups.map(group => `<th colspan="${group.keys.length}">${group.label}</th>`),
      singles.map(single => `<th rowspan="2">${single.label}</th>`).join(''),
      '</tr>'
    ].join('');

    const headerBottom = [
      '<tr>',
      groups.map(group => group.keys.map((_, idx) => `<th>${idx === 0 ? 'EE' : 'ER'}</th>`).join('')).join(''),
      '</tr>'
    ].join('');

    const body = rows.length
      ? rows.join('')
      : `<tr><td class="mr-site-label" colspan="${1 + groups.reduce((sum, group) => sum + group.keys.length, 0) + singles.length}">No site payroll data available.</td></tr>`;

    const foot = totalRow();

    return [
      '<table class="mr-table mr-contrib-table mr-site-payroll">',
      `<thead>${headerTop}${headerBottom}</thead>`,
      `<tbody>${body}</tbody>`,
      foot ? `<tfoot>${foot}</tfoot>` : '',
      '</table>'
    ].join('');
  };

  function getPayrollRange(){
    try{
      const ws = document.getElementById('weekStart')?.value || '';
      const we = document.getElementById('weekEnd')?.value || '';
      if (ws || we) return [ws, we];
    }catch(e){}
    return ['', ''];
  }

  function formatDateLong(value){
    if (!value) return '';
    try{
      const dt = new Date(value);
      if (!(dt instanceof Date) || isNaN(dt.getTime())) return String(value || '');
      return dt.toLocaleDateString(undefined,{ year:'numeric', month:'long', day:'numeric' });
    }catch(e){
      return String(value || '');
    }
  }

  function formatPayrollPeriodLabel(start, end){
    const startLabel = formatDateLong(start);
    const endLabel = formatDateLong(end);
    if (startLabel && endLabel){
      return (startLabel === endLabel) ? startLabel : `${startLabel} – ${endLabel}`;
    }
    return startLabel || endLabel || '';
  }

  // Compute contribution totals across employees for the active period
  function computeContributionTotals(){
    try{ if (typeof syncPeriodScopedData==='function') syncPeriodScopedData(); }catch(e){}
    const hasCompanyOptions = (typeof COMPANY_OPTIONS !== 'undefined') && Array.isArray(COMPANY_OPTIONS);
    const defaults = hasCompanyOptions
      ? COMPANY_OPTIONS.filter(name => typeof name === 'string' && name.trim().length)
      : ['Edifice','Portafolio'];
    const makeBucket = makeContributionBucket;
    const sums = {};
    const ensureBucket = (companyName) => {
      const label = (typeof companyName === 'string' && companyName.trim().length) ? companyName.trim() : 'Unassigned';
      if (!sums[label]) sums[label] = makeBucket();
      return sums[label];
    };
    const seeds = defaults.length ? defaults : ['Edifice','Portafolio'];
    seeds.forEach(name => ensureBucket(name));
    try{
      const list = (typeof employeeList!=='undefined' && employeeList) ? employeeList : [];
      const rates = (typeof payrollRates!=='undefined' && payrollRates) ? payrollRates : {};
      const se = (typeof storedEmployees!=='undefined' && storedEmployees) ? storedEmployees : {};
      const rHours = (typeof regHours!=='undefined' && regHours) ? regHours : {};
      const flagsAll = (typeof contribFlags!=='undefined' && contribFlags) ? contribFlags : {};
      const div = Number(typeof divisor!=='undefined' ? divisor : 1) || 1;
      const lSSS = (typeof loanSSS!=='undefined' && loanSSS) ? loanSSS : {};
      const lPI  = (typeof loanPI!=='undefined'  && loanPI ) ? loanPI  : {};
      const includePagibig = isDeductionColumnIncluded('pagibig');
      const includePhilhealth = isDeductionColumnIncluded('philhealth');
      const includeSSS = isDeductionColumnIncluded('sss');
      const includeLoanSSS = isDeductionColumnIncluded('loanSSS');
      const includeLoanPI = isDeductionColumnIncluded('loanPI');
      list.forEach(emp=>{
        const id = emp.id;
        const rH = num(rHours[id]);
        const oH = (typeof otHours !== 'undefined' && otHours) ? num(otHours[id]) : 0;
        const adjH = (typeof adjHrs !== 'undefined' && adjHrs) ? num(adjHrs[id]) : 0;
        const totalHours = rH + oH + Math.abs(adjH);
        if (totalHours <= 0) return;
        const bucket = ensureBucket(se?.[id]?.company);
        const rate = num(se?.[id]?.hourlyRate ?? rates?.[id]);
        const regPay = +(rH * rate).toFixed(2);
        const monthly = rate * 8 * 24;
        const piRate = (typeof pagibigRateByMonthly==='function') ? pagibigRateByMonthly(monthly) : 0;
        const phRate = (typeof philhealthRateByMonthly==='function') ? philhealthRateByMonthly(monthly) : 0;
        const sssFull = (typeof sssShareByMonthly==='function') ? sssShareByMonthly(monthly) : 0;
        const sssEmployerFull = (typeof sssEmployerShareByMonthly==='function') ? sssEmployerShareByMonthly(monthly) : sssFull;
        const flags = flagsAll[id] || {};
        const pi = (!includePagibig || flags.pagibig===false) ? 0 : +(regPay * piRate).toFixed(2);
        const ph = (!includePhilhealth || flags.philhealth===false) ? 0 : +(regPay * phRate).toFixed(2);
        const sssEE = (!includeSSS || flags.sss===false) ? 0 : +(sssFull/div).toFixed(2);
        const sssER = (!includeSSS || flags.sss===false) ? 0 : +(sssEmployerFull/div).toFixed(2);
        const loanSssVal = includeLoanSSS ? +(num(lSSS[id]) / div).toFixed(2) : 0;
        const loanPiVal  = includeLoanPI  ? +(num(lPI[id])  / div).toFixed(2) : 0;
        bucket.piEE += pi; bucket.piER += pi;
        bucket.phEE += ph; bucket.phER += ph;
        bucket.sssEE += sssEE; bucket.sssER += sssER;
        bucket.loanSSS += loanSssVal;
        bucket.loanPI  += loanPiVal;
      });
    }catch(e){}
    return sums;
  }

  function resolveProjectDetails(projectIdHint, projectLabel){
    const sp = (typeof storedProjects !== 'undefined' && storedProjects) ? storedProjects : {};
    const clean = (val) => {
      if (val == null) return '';
      return String(val).trim();
    };
    const id = clean(projectIdHint);
    const label = clean(projectLabel);
    const fallbackName = label || id;

    if (id && sp[id]){
      const rec = sp[id] || {};
      return {
        id,
        name: clean(rec.name) || fallbackName,
        company: clean(rec.company)
      };
    }

    if (label && sp[label]){
      const rec = sp[label] || {};
      return {
        id: label,
        name: clean(rec.name) || fallbackName,
        company: clean(rec.company)
      };
    }

    const lowerLabel = label.toLowerCase();
    if (lowerLabel){
      for (const [pid, proj] of Object.entries(sp)){
        const projName = clean(proj && proj.name);
        if (projName && projName.toLowerCase() === lowerLabel){
          return {
            id: clean(pid),
            name: projName,
            company: clean(proj && proj.company)
          };
        }
      }
    }

    const lowerId = id.toLowerCase();
    if (lowerId){
      for (const [pid, proj] of Object.entries(sp)){
        const projName = clean(proj && proj.name);
        if (projName && projName.toLowerCase() === lowerId){
          return {
            id: clean(pid),
            name: projName,
            company: clean(proj && proj.company)
          };
        }
      }
    }

    return {
      id,
      name: fallbackName,
      company: ''
    };
  }

  // Read per-project totals by copying values from the Detailed reports table
  function computeProjectTotalsFromDetailed(){
    const rows = [];
    try{
      const tbl = document.getElementById('r_table');
      if (!tbl) return rows;
      const blocks = Array.from(tbl.querySelectorAll('tbody.proj-page'));
      blocks.forEach(tb => {
        const rawName = (tb.querySelector('.proj-break td')?.textContent || '').trim();
        let tot = tb.querySelector('tr.totals:last-child');
        if (!tot) {
          const trs = Array.from(tb.querySelectorAll('tr'));
          tot = trs.reverse().find(tr => (tr.cells[0]?.textContent||'').trim().toLowerCase() === 'project total');
        }
        if (!tot) return;
        const cells = tot.querySelectorAll('td');
        if (!cells || cells.length < 2) return;
        const gross = num(cells[cells.length-1].textContent);
        const hrs   = num(cells[cells.length-2].textContent);
        const meta = resolveProjectDetails('', rawName);
        const displayName = meta.name || rawName;
        const company = meta.company || '';
        rows.push({ name: displayName, hrs, total: gross, company });
      });
      rows.sort((a,b)=>{
        const aComp = (a.company || '').localeCompare(b.company || '');
        if (aComp) return aComp;
        return (a.name || '').localeCompare(b.name || '');
      });
    }catch(e){}
    return rows;
  }

  // Fallback: compute from DTR if detailed table isn’t available
  function computeProjectTotalsFromDTR(){
    const rows = [];
    try{
      const projMap = {};
      const trs = Array.from(document.querySelectorAll('#resultsTable tbody tr'));
      trs.forEach(tr=>{
        const id = (tr.cells[0]?.textContent||'').trim();
        const name = (tr.cells[1]?.textContent||'').trim();
        const cell = tr.cells[2];
        let proj = '';
        let projIdHint = '';
        try{
          const sel = cell?.querySelector('select');
          if (sel){
            const opt = sel.options[sel.selectedIndex];
            proj = (opt && (opt.textContent||opt.label)) || sel.value || '';
            projIdHint = sel.value || sel.getAttribute('data-project-id') || '';
            if (!proj) {
              proj = cell?.dataset?.projectName || cell?.dataset?.project || '';
            }
          }
          else {
            proj = cell?.dataset?.projectName || cell?.dataset?.project || (cell?.textContent||'');
            projIdHint = cell?.dataset?.projectId || cell?.dataset?.project || '';
          }
        }catch(_){
          proj = (cell?.textContent||'');
          projIdHint = cell?.dataset?.projectId || cell?.dataset?.project || '';
        }
        proj = String(proj||'').trim();
        projIdHint = String(projIdHint||'').trim();
        if (!proj && projIdHint) proj = projIdHint;
        const rwh = num(tr.cells[11]?.textContent) || num(tr.querySelector('.regHrs')?.value);
        const oth = num(tr.cells[12]?.textContent) || num(tr.querySelector('.otHrs')?.value);
        if (!proj) return;
        const meta = resolveProjectDetails(projIdHint, proj);
        const rec = (projMap[proj] = projMap[proj] || { emp:{}, meta:null });
        if (!rec.meta){
          rec.meta = { ...meta };
        } else {
          if (meta.company && !rec.meta.company) rec.meta.company = meta.company;
          if (meta.id && !rec.meta.id) rec.meta.id = meta.id;
          if (meta.name && (!rec.meta.name || rec.meta.name === proj || rec.meta.name === rec.meta.id)) rec.meta.name = meta.name;
        }
        const er = (rec.emp[id] = rec.emp[id] || { name, rwh:0, oth:0 });
        er.rwh += rwh; er.oth += oth;
      });
      const otMult = num(document.getElementById('otMultiplier')?.value) || 1.5;
      const rates = (typeof payrollRates!=='undefined' && payrollRates) ? payrollRates : {};
      const se = (typeof storedEmployees!=='undefined' && storedEmployees) ? storedEmployees : {};
      Object.keys(projMap).forEach(p=>{
        const rec = projMap[p]; let hrs=0, gross=0;
        Object.keys(rec.emp).forEach(id=>{
          const e = rec.emp[id];
          const rate = num(se?.[id]?.hourlyRate ?? rates?.[id]);
          hrs += (e.rwh + e.oth);
          gross += (e.rwh * rate) + (e.oth * rate * otMult);
        });
        try{
          const allow = Object.keys((window.bantay||{})).reduce((sum, empId)=>{
            const assigned = (window.bantayProj||{})[empId]; if(!assigned) return sum;
            const sp = (typeof storedProjects!=='undefined' && storedProjects) ? storedProjects : {};
            const matchesById = (assigned === p);
            const matchesByName = (sp[assigned]?.name === p);
            const amt = num((window.bantay||{})[empId]);
            return (matchesById || matchesByName) ? (sum + amt) : sum;
          }, 0);
          gross += allow;
        }catch(_){ }
        const meta = rec.meta || resolveProjectDetails('', p);
        const displayName = meta.name || p;
        const company = meta.company || '';
        rows.push({ name:displayName, hrs:hrs, total:gross, company });
      });
      rows.sort((a,b)=>{
        const aComp = (a.company || '').localeCompare(b.company || '');
        if (aComp) return aComp;
        return (a.name || '').localeCompare(b.name || '');
      });
    }catch(e){}
    return rows;
  }

  function computeProjectTotals(){
    const fromDetailed = computeProjectTotalsFromDetailed();
    if (fromDetailed.length) return fromDetailed;
    return computeProjectTotalsFromDTR();
  }

  function renderMasterReport(){
    const host = document.getElementById('masterReportContainer'); if(!host) return;
    const totalsByCompany = computeContributionTotals();
    const prows = computeProjectTotals();
    const g = prows.reduce((acc,r)=>{
      acc.h += Number((r && r.hrs != null) ? r.hrs : 0);
      acc.t += Number((r && r.total != null) ? r.total : 0);
      return acc;
    }, {h:0,t:0});
    let html = '';
    html += '<h2>PAYROLL REPORT</h2>';
    const [rangeStart, rangeEnd] = getPayrollRange();
    const periodLabel = formatPayrollPeriodLabel(rangeStart, rangeEnd);
    if (periodLabel){
      html += `<div class="mr-period">Payroll Period: <span>${safe(periodLabel)}</span></div>`;
    } else {
      html += '<div class="mr-period">Payroll Period: <span class="mr-period-missing">Not set</span></div>';
    }
    const makeBucket = makeContributionBucket;
    const hasCompanyOptions = (typeof COMPANY_OPTIONS !== 'undefined') && Array.isArray(COMPANY_OPTIONS);
    const defaults = hasCompanyOptions
      ? COMPANY_OPTIONS.filter(name => typeof name === 'string' && name.trim().length)
      : ['Edifice','Portafolio'];
    const normalizeCompanyLabel = (val) => {
      const label = safe(val).trim();
      return label.length ? label : 'Unassigned';
    };
    const seen = new Set();
    const orderedCompanies = [];
    const pushCompany = (name) => {
      const label = (typeof name === 'string' && name.trim().length) ? name.trim() : 'Unassigned';
      if (seen.has(label)) return;
      seen.add(label);
      orderedCompanies.push(label);
    };
    (defaults.length ? defaults : ['Edifice','Portafolio']).forEach(pushCompany);
    Object.keys(totalsByCompany || {}).forEach(pushCompany);
    if (!orderedCompanies.length) pushCompany('Unassigned');
    const sitePayrollTable = renderSitePayrollTable(orderedCompanies, totalsByCompany, { makeBucket, safe });
    html += '<div class="mr-section">';
    html += sitePayrollTable;
    html += '</div>';

    const allCompanyBuckets = (totalsByCompany && typeof totalsByCompany === 'object')
      ? Object.values(totalsByCompany)
      : [];
    const overallBucket = allCompanyBuckets.reduce((acc, bucket) => {
      CONTRIBUTION_FIELDS.forEach(key => {
        const val = Number(bucket && bucket[key] != null ? bucket[key] : 0);
        acc[key] += val;
      });
      return acc;
    }, makeBucket());
    if (orderedCompanies.length){
      html += '<div class="mr-section mr-grand-contributions">';
      html += '<h4>GRAND TOTAL - CONTRIBUTIONS</h4>';
      html += renderContributionTable(overallBucket, { bold: true, combineEEER: true });
      html += '</div>';
    }

    const projectGroups = {};
    const ensureProjectGroup = (companyName) => {
      const label = normalizeCompanyLabel(companyName);
      if (!projectGroups[label]) projectGroups[label] = { label, rows: [], hrs:0, total:0 };
      return projectGroups[label];
    };
    prows.forEach(row => {
      const group = ensureProjectGroup(row && row.company);
      group.rows.push(row);
      group.hrs += Number((row && row.hrs != null) ? row.hrs : 0);
      group.total += Number((row && row.total != null) ? row.total : 0);
    });
    const projectSeen = new Set();
    const projectOrder = [];
    const pushProjectCompany = (name) => {
      const label = normalizeCompanyLabel(name);
      if (projectSeen.has(label)) return;
      const grp = projectGroups[label];
      if (!grp || !grp.rows.length) return;
      projectSeen.add(label);
      projectOrder.push(label);
    };
    const defaultOrder = (defaults.length ? defaults : ['Edifice','Portafolio']).map(normalizeCompanyLabel);
    defaultOrder.forEach(pushProjectCompany);
    Object.keys(projectGroups).sort((a,b)=>{
      const aUn = (a === 'Unassigned');
      const bUn = (b === 'Unassigned');
      if (aUn && !bUn) return 1;
      if (!aUn && bUn) return -1;
      return a.localeCompare(b);
    }).forEach(pushProjectCompany);

    html += '<div class="mr-section" style="margin-top:16px;">';
    html += '<h4 class="mr-project-title">PROJECT</h4>';
    html += '<table class="mr-table"><thead><tr><th class="left">NAME</th><th class="mr-num">HRS</th><th class="mr-num">GRAND TOTAL</th></tr></thead><tbody>';
    if (!projectOrder.length){
      if (!prows.length){
        html += '<tr><td class="left" colspan="3">No project totals available.</td></tr>';
      } else {
        prows.forEach(r=>{ html += `<tr><td class="left">${safe(r.name)}</td><td class="mr-num">${f2(r.hrs)}</td><td class="mr-num">${f2(r.total)}</td></tr>`; });
      }
    } else {
      projectOrder.forEach(companyName => {
        const group = projectGroups[companyName];
        if (!group || !group.rows.length) return;
        const companyLabel = normalizeCompanyLabel(companyName);
        html += `<tr class="mr-company"><th colspan="3">${safe(companyLabel)}</th></tr>`;
        const sortedRows = group.rows.slice().sort((a,b)=> safe(a && a.name).localeCompare(safe(b && b.name)));
        sortedRows.forEach(r=>{
          html += `<tr><td class="left">${safe(r && r.name)}</td><td class="mr-num">${f2(r && r.hrs)}</td><td class="mr-num">${f2(r && r.total)}</td></tr>`;
        });
        html += `<tr class="mr-subtotal"><td class="left" style="font-weight:600;">Subtotal - ${safe(companyLabel)}</td><td class="mr-num" style="font-weight:600;">${f2(group.hrs)}</td><td class="mr-num" style="font-weight:600;">${f2(group.total)}</td></tr>`;
      });
    }
    html += `</tbody><tfoot><tr><td class="left">Grand Total</td><td class="mr-num">${f2(g.h)}</td><td class="mr-num">${f2(g.t)}</td></tr></tfoot></table>`;
    html += '</div>';

    host.innerHTML = html;
  }

  try { window.renderMasterReport = renderMasterReport; } catch (e) {}

  function attachMasterPrint(){
    const btn = document.getElementById('mr_print');
    if (!btn || btn.__wired) return; btn.__wired = true;
    btn.addEventListener('click', function(ev){
      ev.preventDefault();
      try{
        const node = document.getElementById('masterReportContainer');
        if (!node) return; const html = '<!doctype html><html><head><meta charset="utf-8"><title>Master Report</title>'+
          '<style>body{font-family:Arial,Helvetica,sans-serif;padding:10px} table{width:100%;border-collapse:collapse;font-size:12px} th,td{border:0.6pt solid #000;padding:4px 6px;text-align:left} .mr-num{text-align:right;font-variant-numeric:tabular-nums;white-space:nowrap} .mr-company th{text-align:center} h2{text-align:center;margin:0 0 10px 0}</style>'+
          '</head><body>'+ node.innerHTML +'</body></html>';
        const w = window.open('', '', 'width=1024,height=768'); if (!w) return; w.document.open(); w.document.write(html); w.document.close(); w.focus(); setTimeout(()=>{ try{ w.print(); }catch(_){} }, 0);
      }catch(_){ window.print(); }
    });
  }

  function init(){ renderMasterReport(); attachMasterPrint(); }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); }
  else { init(); }

  try{
    const old = window.rebuildReports;
    window.rebuildReports = function(){ try{ old && old(); }catch(e){} try{ renderMasterReport(); }catch(e){} };
  }catch(e){}
})();
</script>

  <section class="panel" id="panelContributionSummary">
    <style>
      #panelContributionSummary .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:18px;box-shadow:0 4px 18px rgba(0,0,0,.06)}
      #panelContributionSummary .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
      #panelContributionSummary .controls label{font-size:13px;color:#334155;font-weight:600;display:flex;flex-direction:column;align-items:flex-start;gap:6px}
      #panelContributionSummary .controls label .hint{font-weight:400;font-size:12px;color:#64748b}
      #panelContributionSummary .controls select{padding:6px 10px;border:1px solid #cbd5e1;border-radius:8px;font-size:14px;min-width:220px;background:#fff;color:#0f172a}
      #panelContributionSummary .controls .actions{display:flex;gap:8px;align-items:center;margin-left:auto}
      #panelContributionSummary .controls .actions button{padding:8px 12px;border:1px solid #cbd5e1;border-radius:8px;background:#f8fafc;color:#0f172a;font-weight:600;cursor:pointer;transition:background .15s ease,box-shadow .15s ease}
      #panelContributionSummary .controls .actions button:hover{background:#eef4fb;box-shadow:0 1px 3px rgba(0,0,0,.08)}
      #panelContributionSummary .controls .actions button:focus{outline:2px solid #a5b4fc;outline-offset:2px}
      #panelContributionSummary .summary-meta{font-size:13px;color:#475569;margin-bottom:10px}
      #panelContributionSummary .empty-state{padding:16px;border:1px dashed #cbd5e1;border-radius:10px;background:#f8fafc;color:#64748b;font-size:14px;text-align:center}
      #panelContributionSummary .table-wrap{overflow-x:auto}
      #panelContributionSummary table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px}
      #panelContributionSummary th,#panelContributionSummary td{border:1px solid #dbe3ef;padding:8px 10px;text-align:right}
      #panelContributionSummary th:first-child,#panelContributionSummary td:first-child{ text-align:left; white-space:nowrap }
      #panelContributionSummary th:nth-child(2),#panelContributionSummary td:nth-child(2){ text-align:left }
      #panelContributionSummary thead th{background:#eef4fb;color:#0f172a;text-align:center}
      #panelContributionSummary tfoot th,#panelContributionSummary tfoot td{font-weight:600;background:#fff7ed}
    </style>
    <div class="card">
      <h3 style="margin:0 0 12px 0;">Contribution &amp; Loan Summary</h3>
      <div class="controls">
        <label class="period-control">Payroll Periods
          <select id="contribPeriodSelect" multiple size="6" title="Hold Ctrl (Windows) or Command (macOS) to select multiple periods."></select>
          <span class="hint">Hold Ctrl (Windows) or ⌘ (macOS) to select multiple periods.</span>
        </label>
        <div class="actions">
          <button id="contribPrintBtn" type="button">Print</button>
          <button id="contribExcelBtn" type="button">Download Excel</button>
        </div>
      </div>
      <div id="contribSummaryMeta" class="summary-meta">Choose one or more payroll periods to view contribution totals from payroll history.</div>
      <div id="contribSummaryEmpty" class="empty-state">Select at least one payroll period to view contribution totals.</div>
      <div class="table-wrap">
        <table id="contribSummaryTable" style="display:none">
          <thead>
            <tr>
              <th>Employee ID</th>
              <th>Name</th>
              <th>Pag-IBIG</th>
              <th>PhilHealth</th>
              <th>SSS</th>
              <th>SSS Loan</th>
              <th>Pag-IBIG Loan</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr>
              <th colspan="2">Grand Total</th>
              <td>0.00</td>
              <td>0.00</td>
              <td>0.00</td>
              <td>0.00</td>
              <td>0.00</td>
              <td>0.00</td>
            </tr>
          </tfoot>
        </table>
      </div>
    </div>
  </section>

  <script>
  (function(){
    const HIST_KEY = 'payroll_hist';
    const PERIOD_SELECT_ID = 'contribPeriodSelect';
    const EMPTY_ID = 'contribSummaryEmpty';
    const META_ID = 'contribSummaryMeta';
    const TABLE_ID = 'contribSummaryTable';
    const PRINT_ID = 'contribPrintBtn';
    const EXCEL_ID = 'contribExcelBtn';

    function readHistory(){
      if (Array.isArray(window.payrollHistory)) return window.payrollHistory.slice();
      try {
        const raw = localStorage.getItem(HIST_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (e) {
        return [];
      }
    }

    function toIsoDate(value){
      if (!value) return '';
      const str = String(value).trim();
      if (!str) return '';
      if (/^\d{4}-\d{2}-\d{2}$/.test(str)) return str;
      const parsed = new Date(str);
      if (!isNaN(parsed)){
        const year = parsed.getFullYear();
        const month = String(parsed.getMonth()+1).padStart(2,'0');
        const day = String(parsed.getDate()).padStart(2,'0');
        return `${year}-${month}-${day}`;
      }
      return '';
    }

    function toNumber(value){
      if (value == null || value === '') return 0;
      const num = Number(String(value).replace(/,/g,''));
      return Number.isFinite(num) ? num : 0;
    }

    function escapeHtml(value){
      return String(value == null ? '' : value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatNumber(value){
      return Number(value || 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function formatDisplayDate(value){
      const str = value != null ? String(value).trim() : '';
      if (!str) return '';
      const parsed = new Date(str);
      if (!isNaN(parsed)){
        return parsed.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
      }
      return str;
    }

    function createPeriodKey(start, end){
      const safeStart = (start || '').trim();
      const safeEnd = (end || '').trim();
      return `${safeStart}__${safeEnd}`;
    }

    function createPeriodDescriptor(snap){
      if (!snap) return null;
      const rawStart = snap.startDate != null ? String(snap.startDate).trim() : '';
      const rawEnd = snap.endDate != null ? String(snap.endDate).trim() : '';
      const startIso = toIsoDate(rawStart);
      const endIso = toIsoDate(rawEnd);
      const start = startIso || rawStart;
      const end = endIso || rawEnd;
      if (!start && !end) return null;
      const key = createPeriodKey(start, end);
      const displayStart = formatDisplayDate(start || rawStart);
      const displayEnd = formatDisplayDate(end || rawEnd);
      const label = displayStart && displayEnd
        ? `${displayStart} – ${displayEnd}`
        : displayStart || displayEnd || 'Unnamed period';
      const sortValue = endIso || startIso || end || start || '';
      return { key, start, end, startIso, endIso, displayStart, displayEnd, label, sortValue };
    }

    function listPeriods(){
      const history = readHistory();
      const map = new Map();
      history.forEach(snap => {
        const descriptor = createPeriodDescriptor(snap);
        if (!descriptor) return;
        if (!map.has(descriptor.key)) map.set(descriptor.key, descriptor);
      });
      return Array.from(map.values()).sort((a, b) => {
        const aSort = (a.sortValue || '').trim();
        const bSort = (b.sortValue || '').trim();
        if (aSort || bSort){
          const comp = (bSort || '').localeCompare(aSort || '');
          if (comp) return comp;
        }
        const aStart = (a.startIso || a.start || '').trim();
        const bStart = (b.startIso || b.start || '').trim();
        return (bStart || '').localeCompare(aStart || '');
      });
    }

    function populatePeriodSelect({ preserveSelection = false } = {}){
      const select = document.getElementById(PERIOD_SELECT_ID);
      if (!select) return [];
      const periods = listPeriods();
      const previous = preserveSelection
        ? Array.from(select.selectedOptions || []).map(opt => opt.value).filter(Boolean)
        : [];
      select.innerHTML = periods.map(period => `<option value="${escapeHtml(period.key)}">${escapeHtml(period.label)}</option>`).join('');
      if (previous.length){
        const previousSet = new Set(previous);
        Array.from(select.options).forEach(opt => {
          opt.selected = previousSet.has(opt.value);
        });
      }
      return periods;
    }

    function ensureDefaultPeriod(periods){
      const select = document.getElementById(PERIOD_SELECT_ID);
      if (!select) return;
      const hasSelection = Array.from(select.selectedOptions || []).some(opt => opt.value);
      if (hasSelection) return;
      const list = Array.isArray(periods) ? periods : listPeriods();
      if (!list.length) return;
      const defaultKey = list[0].key;
      Array.from(select.options || []).forEach(opt => {
        opt.selected = opt.value === defaultKey;
      });
    }

    function computeSummary(selectedKeys){
      const keys = Array.isArray(selectedKeys)
        ? selectedKeys.filter(key => typeof key === 'string' && key.trim().length)
        : [];
      const uniqueKeys = Array.from(new Set(keys.map(key => key.trim())));
      const history = readHistory();
      const periodMeta = new Map();
      const map = new Map();
      if (!uniqueKeys.length){
        return {
          entries: [],
          totals: { pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, total:0, perPeriod: [] },
          periods: [],
          periodKeys: []
        };
      }
      const keySet = new Set(uniqueKeys);
      const normalizeDivisor = (value) => {
        const num = Number(value);
        return (Number.isFinite(num) && num > 0) ? num : 1;
      };
      const normalizeLoanValue = (raw, divisor) => {
        const base = toNumber(raw);
        if (!divisor || !Number.isFinite(divisor) || divisor <= 0) return base;
        return Number(((base || 0) / divisor).toFixed(2));
      };

      history.forEach(snap => {
        const descriptor = createPeriodDescriptor(snap);
        if (!descriptor || !keySet.has(descriptor.key)) return;
        if (!periodMeta.has(descriptor.key)){
          periodMeta.set(descriptor.key, { ...descriptor });
        }
        const divisor = normalizeDivisor(snap && snap.divisor);
        const rows = Array.isArray(snap.rows) ? snap.rows : [];
        rows.forEach(row => {
          if (!row) return;
          const id = row.id != null ? String(row.id).trim() : '';
          if (!id) return;
          const record = map.get(id) || {
            id,
            name: '',
            pagibig: 0,
            philhealth: 0,
            sss: 0,
            loanSSS: 0,
            loanPI: 0,
            byPeriod: {}
          };
          const name = row.name != null ? String(row.name).trim() : '';
          if (name && !record.name) record.name = name;
          const pagibigVal = toNumber(row.pagibig);
          const philVal = toNumber(row.philhealth);
          const sssVal = toNumber(row.sss);
          const loanSssVal = normalizeLoanValue(row.loanSSS, divisor);
          const loanPiVal = normalizeLoanValue(row.loanPI, divisor);
          record.pagibig += pagibigVal;
          record.philhealth += philVal;
          record.sss += sssVal;
          record.loanSSS += loanSssVal;
          record.loanPI += loanPiVal;
          const perPeriod = record.byPeriod[descriptor.key] || { pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0 };
          perPeriod.pagibig += pagibigVal;
          perPeriod.philhealth += philVal;
          perPeriod.sss += sssVal;
          perPeriod.loanSSS += loanSssVal;
          perPeriod.loanPI += loanPiVal;
          record.byPeriod[descriptor.key] = perPeriod;
          map.set(id, record);
        });
      });
      const orderedPeriods = Array.from(periodMeta.values()).sort((a, b) => {
        const aSort = (a.sortValue || '').trim();
        const bSort = (b.sortValue || '').trim();
        const comp = aSort.localeCompare(bSort);
        if (comp) return comp;
        const aStart = (a.startIso || a.start || '').trim();
        const bStart = (b.startIso || b.start || '').trim();
        return aStart.localeCompare(bStart);
      }).map((period, idx) => ({ ...period, index: idx }));
      const periodKeys = orderedPeriods.map(p => p.key);
      const entries = Array.from(map.values()).map(entry => {
        const perPeriod = periodKeys.map(key => {
          const values = entry.byPeriod && entry.byPeriod[key] ? entry.byPeriod[key] : {};
          return {
            pagibig: values.pagibig || 0,
            philhealth: values.philhealth || 0,
            sss: values.sss || 0,
            loanSSS: values.loanSSS || 0,
            loanPI: values.loanPI || 0
          };
        });
        const total = entry.pagibig + entry.philhealth + entry.sss + entry.loanSSS + entry.loanPI;
        const { byPeriod, ...rest } = entry;
        return { ...rest, name: rest.name || rest.id, total, perPeriod };
      }).sort((a,b) => {
        const nameComp = a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        if (nameComp) return nameComp;
        return a.id.localeCompare(b.id, undefined, { sensitivity: 'base' });
      });
      const totals = {
        pagibig: 0,
        philhealth: 0,
        sss: 0,
        loanSSS: 0,
        loanPI: 0,
        total: 0,
        perPeriod: periodKeys.map(() => ({ pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0 }))
      };
      entries.forEach(entry => {
        totals.pagibig += entry.pagibig;
        totals.philhealth += entry.philhealth;
        totals.sss += entry.sss;
        totals.loanSSS += entry.loanSSS;
        totals.loanPI += entry.loanPI;
        totals.total += entry.total;
        entry.perPeriod.forEach((periodData, idx) => {
          const slot = totals.perPeriod[idx];
          if (!slot) return;
          slot.pagibig += periodData.pagibig;
          slot.philhealth += periodData.philhealth;
          slot.sss += periodData.sss;
          slot.loanSSS += periodData.loanSSS;
          slot.loanPI += periodData.loanPI;
        });
      });
      totals.perPeriod.forEach(slot => {
        if (!slot) return;
        slot.total = slot.pagibig + slot.philhealth + slot.sss + slot.loanSSS + slot.loanPI;
      });
      return { entries, totals, periods: orderedPeriods, periodKeys: orderedPeriods.map(period => period.key) };
    }

    function updateMeta(periods, selectedKeys){
      const metaEl = document.getElementById(META_ID);
      if (!metaEl) return;
      const keys = Array.isArray(selectedKeys) ? selectedKeys.filter(Boolean) : [];
      if (!keys.length){
        metaEl.textContent = 'Choose one or more payroll periods to view contribution totals from payroll history.';
        return;
      }
      const periodList = Array.isArray(periods) ? periods : [];
      if (!periodList.length){
        metaEl.textContent = keys.length === 1
          ? 'Selected payroll period was not found in payroll history.'
          : 'Selected payroll periods were not found in payroll history.';
        return;
      }
      if (periodList.length === 1){
        const range = periodList[0].label || 'Selected payroll period';
        metaEl.innerHTML = `Viewing contribution totals for <strong>${escapeHtml(range)}</strong>.`;
      } else {
        const primary = periodList[0].label || 'Selected payroll periods';
        const joined = periodList.map(period => period.label || period.key).join(', ');
        metaEl.innerHTML = `Viewing contribution totals for <strong>${escapeHtml(primary)}</strong> plus ${periodList.length - 1} more period${periodList.length - 1 === 1 ? '' : 's'}. Combined snapshots: ${escapeHtml(joined)}.`;
      }
    }

    function render(){
      const periods = populatePeriodSelect({ preserveSelection: true });
      ensureDefaultPeriod(periods);
      const select = document.getElementById(PERIOD_SELECT_ID);
      const selectedKeys = select ? Array.from(select.selectedOptions || []).map(opt => opt.value).filter(Boolean) : [];
      const { entries, totals, periods: periodDetails } = computeSummary(selectedKeys);
      const table = document.getElementById(TABLE_ID);
      const emptyEl = document.getElementById(EMPTY_ID);
      if (!table) return;
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      const tfoot = table.querySelector('tfoot');
      if (!thead || !tbody || !tfoot) return;

      const categories = [
        { key: 'pagibig', label: 'Pag-IBIG' },
        { key: 'philhealth', label: 'PhilHealth' },
        { key: 'sss', label: 'SSS' },
        { key: 'loanSSS', label: 'SSS Loan' },
        { key: 'loanPI', label: 'Pag-IBIG Loan' }
      ];
      const periodList = Array.isArray(periodDetails) ? periodDetails : [];
      const perPeriodTotals = Array.isArray(totals.perPeriod) ? totals.perPeriod : [];
      const formatPeriodRange = (period) => {
        if (!period) return '';
        const start = period.displayStart || formatDisplayDate(period.start);
        const end = period.displayEnd || formatDisplayDate(period.end);
        if (start && end) return `${start} – ${end}`;
        return start || end || '';
      };

      const headerCells = [];
      headerCells.push('<th>Employee ID</th>');
      headerCells.push('<th>Name</th>');
      categories.forEach(cat => {
        periodList.forEach((period, idx) => {
          const headerLabel = periodList.length > 1 ? `${cat.label} P${idx + 1}` : `${cat.label}`;
          const range = formatPeriodRange(period);
          const titleAttr = range ? ` title="${escapeHtml(range)}"` : '';
          headerCells.push(`<th${titleAttr}>${escapeHtml(headerLabel)}</th>`);
        });
        headerCells.push(`<th>${escapeHtml(cat.label + ' Total')}</th>`);
      });
      headerCells.push('<th>Grand Total</th>');
      thead.innerHTML = `<tr>${headerCells.join('')}</tr>`;

      tbody.innerHTML = '';
      if (entries.length){
        entries.forEach(entry => {
          const tr = document.createElement('tr');
          const cells = [];
          cells.push(`<td>${escapeHtml(entry.id)}</td>`);
          cells.push(`<td>${escapeHtml(entry.name)}</td>`);
          categories.forEach(cat => {
            periodList.forEach((_, idx) => {
              const periodData = entry.perPeriod && entry.perPeriod[idx] ? entry.perPeriod[idx] : {};
              const value = periodData[cat.key] || 0;
              cells.push(`<td>${formatNumber(value)}</td>`);
            });
            cells.push(`<td>${formatNumber(entry[cat.key] || 0)}</td>`);
          });
          cells.push(`<td>${formatNumber(entry.total)}</td>`);
          tr.innerHTML = cells.join('');
          tbody.appendChild(tr);
        });
      }

      const totalCells = [];
      categories.forEach(cat => {
        periodList.forEach((_, idx) => {
          const slot = perPeriodTotals[idx] || {};
          const value = slot[cat.key] || 0;
          totalCells.push(`<td>${formatNumber(value)}</td>`);
        });
        totalCells.push(`<td>${formatNumber(totals[cat.key] || 0)}</td>`);
      });
      totalCells.push(`<td>${formatNumber(totals.total || 0)}</td>`);
      tfoot.innerHTML = `<tr><th colspan="2">Grand Total</th>${totalCells.join('')}</tr>`;

      const hasSelection = selectedKeys.length > 0;
      const hasData = entries.length > 0;
      table.style.display = hasData ? 'table' : 'none';
      if (emptyEl){
        if (!hasSelection){
          emptyEl.textContent = 'Select at least one payroll period to view contribution totals.';
        } else if (!periodList.length){
          emptyEl.textContent = 'Selected payroll periods were not found in payroll history.';
        } else if (!hasData){
          const label = formatPeriodRange(periodList[0]) || 'the selected payroll period';
          emptyEl.textContent = `No payroll data found for ${label}.`;
        }
        emptyEl.style.display = hasData ? 'none' : '';
      }

      updateMeta(periodDetails, selectedKeys);
    }

    function cloneVisibleTable(){
      const table = document.getElementById(TABLE_ID);
      if (!table) return null;
      const clone = table.cloneNode(true);
      clone.style.removeProperty('display');
      return clone;
    }

    function hasContributionRows(table){
      if (!table) return false;
      return Array.from(table.querySelectorAll('tbody tr')).length > 0;
    }

    function printContributionSummary(){
      const tableClone = cloneVisibleTable();
      if (!tableClone || !hasContributionRows(tableClone)){
        alert('Select at least one payroll period with contribution data before printing.');
        return;
      }
      const metaEl = document.getElementById(META_ID);
      const metaHtml = metaEl ? metaEl.innerHTML : '';
      const html = `<!doctype html><html><head><meta charset="utf-8"><title>Contribution Summary</title>`+
        '<style>body{font-family:Arial,Helvetica,sans-serif;padding:16px;color:#0f172a} h2{margin:0 0 10px 0;text-align:center}' +
        '#meta{margin-bottom:12px;font-size:13px;color:#475569} table{width:100%;border-collapse:collapse;font-size:12px}' +
        'th,td{border:1px solid #1f2937;padding:6px 8px;text-align:right;font-variant-numeric:tabular-nums}' +
        'th:first-child,td:first-child{text-align:left;white-space:nowrap}' +
        'th:nth-child(2),td:nth-child(2){text-align:left}' +
        'thead th{background:#eef2ff}' +
        'tfoot th,tfoot td{font-weight:600;background:#fef3c7}' +
        '</style></head><body>' +
        '<h2>Contribution &amp; Loan Summary</h2>' +
        (metaHtml ? `<div id="meta">${metaHtml}</div>` : '') +
        tableClone.outerHTML +
        '</body></html>';
      const w = window.open('', '', 'width=1024,height=768');
      if (!w) return;
      w.document.open();
      w.document.write(html);
      w.document.close();
      w.focus();
      setTimeout(()=>{ try{ w.print(); }catch(_){} }, 10);
    }

    function exportContributionExcel(){
      const table = cloneVisibleTable();
      if (!table || !hasContributionRows(table)){
        alert('Select at least one payroll period with contribution data before downloading.');
        return;
      }
      if (typeof XLSX === 'undefined'){
        alert('Excel library not available');
        return;
      }
      const metaEl = document.getElementById(META_ID);
      const metaText = metaEl ? metaEl.textContent.trim() : '';
      const rows = Array.from(table.querySelectorAll('tr')).map(tr =>
        Array.from(tr.querySelectorAll('th,td')).map(cell => {
          const text = (cell.textContent || '').trim();
          const numeric = Number(text.replace(/,/g,''));
          return (text !== '' && Number.isFinite(numeric)) ? numeric : text;
        })
      );
      const aoa = [['Contribution & Loan Summary']];
      if (metaText) aoa.push([metaText]);
      aoa.push([]);
      rows.forEach(row => aoa.push(row));
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      ws['!cols'] = (rows[0] || []).map(() => ({ wch: 16 }));
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Contributions');
      XLSX.writeFile(wb, 'contribution-summary.xlsx');
    }

    function bind(){
      const select = document.getElementById(PERIOD_SELECT_ID);
      if (select && !select.__wired){
        select.addEventListener('change', render);
        select.addEventListener('input', render);
        select.__wired = true;
      }
      const printBtn = document.getElementById(PRINT_ID);
      if (printBtn && !printBtn.__wired){
        printBtn.addEventListener('click', printContributionSummary);
        printBtn.__wired = true;
      }
      const excelBtn = document.getElementById(EXCEL_ID);
      if (excelBtn && !excelBtn.__wired){
        excelBtn.addEventListener('click', exportContributionExcel);
        excelBtn.__wired = true;
      }
    }

    function init(){
      render();
      bind();
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    try { window.renderContributionSummary = render; } catch (e) {}
  })();
  </script>
      </main>
    </div>
    <!-- Sidebar navigation behaviour -->
    <script>
    (function(){
      const ICONS = {
        dashboard: '📊',
        dtr: '🕒',
        schedules: '🗓️',
        employees: '👥',
        projects: '🚀',
        payroll: '💰',
        totals: '📈',
        contribSummary: '💳'
      };
      function setTitleFrom(btn){
        try{
          const pg = btn && (btn.dataset.page || btn.getAttribute('data-page')) || '';
          const label = (btn.textContent || '').replace(/^[^A-Za-z0-9]+/,'').trim();
          const icon = ICONS[pg] || '📊';
          const title = document.querySelector('.page-title');
          if (title){ title.innerHTML = '<span class="icon-emoji" style="font-size:32px">'+icon+'</span> ' + label; }
        }catch(_){}
      }
      document.querySelectorAll('.nav-link').forEach(function(link){
        link.addEventListener('click', function(e){
          e.preventDefault();
          document.querySelectorAll('.nav-link').forEach(function(l){ l.classList.remove('active'); });
          this.classList.add('active');
          setTitleFrom(this);
          closeMobileMenu();
        });
      });
      // Initial set from the currently active tab
      const active = document.querySelector('.nav-link.active');
      if (active) setTitleFrom(active);
    })();
    function toggleMobileMenu(button){
        const btn = button || document.querySelector('.mobile-menu-btn');
        const nav = document.getElementById('primaryNav');
        if (!btn || !nav) return;
        const isOpen = !nav.classList.contains('open');
        nav.classList.toggle('open', isOpen);
        btn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
        nav.setAttribute('aria-hidden', isOpen ? 'false' : (window.innerWidth <= 768 ? 'true' : 'false'));
        if (isOpen && window.innerWidth <= 768) {
            const firstLink = nav.querySelector('.nav-link');
            if (firstLink) {
                setTimeout(() => { try { firstLink.focus(); } catch (_) {} }, 0);
            }
        }
    }
    function closeMobileMenu(options){
        const nav = document.getElementById('primaryNav');
        const btn = document.querySelector('.mobile-menu-btn');
        if (!nav || !btn) return;
        const wasOpen = nav.classList.contains('open');
        nav.classList.remove('open');
        btn.setAttribute('aria-expanded', 'false');
        nav.setAttribute('aria-hidden', window.innerWidth <= 768 ? 'true' : 'false');
        if (options && options.focusToggle && wasOpen && window.innerWidth <= 768) {
            try { btn.focus(); } catch (_) {}
        }
    }
    function syncMobileMenuState(){
        const nav = document.getElementById('primaryNav');
        const btn = document.querySelector('.mobile-menu-btn');
        if (!nav || !btn) return;
        if (window.innerWidth > 768) {
            nav.classList.remove('open');
            nav.setAttribute('aria-hidden', 'false');
            btn.setAttribute('aria-expanded', 'false');
        } else if (!nav.classList.contains('open')) {
            nav.setAttribute('aria-hidden', 'true');
        }
    }
    document.addEventListener('click', function(e){
        const nav = document.getElementById('primaryNav');
        const btn = document.querySelector('.mobile-menu-btn');
        if(window.innerWidth <= 768 && nav && nav.classList.contains('open') && btn){
            if(!nav.contains(e.target) && !btn.contains(e.target)){
                closeMobileMenu();
            }
        }
    });
    document.addEventListener('keydown', function(e){
        if(e.key === 'Escape'){
            closeMobileMenu({ focusToggle: true });
        }
    });
    window.addEventListener('resize', syncMobileMenuState);
    syncMobileMenuState();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
   
const LS_RECORDS = 'att_records_v2';

const LS_SCHEDULES = 'att_schedules_v2';
const LS_SCHEDULES_DEFAULT = 'att_schedules_default';
const LS_EMPLOYEES = 'att_employees_v2';
const LS_PROJECTS = 'att_projects_v1';
const LS_FILTER_PROJECT = 'att_filter_project_v1';
const LS_OVERRIDES_SCHEDULES = 'att_overrides_schedules';
const LS_OVERRIDES_PROJECTS = 'att_overrides_projects';
const SPLIT_OVERRIDES_TABLE = 'split_overrides';
const COMPANY_OPTIONS = ['Edifice', 'Portafolio'];

let overridesSchedules = JSON.parse(localStorage.getItem(LS_OVERRIDES_SCHEDULES) || '{}');
let overridesProjects = JSON.parse(localStorage.getItem(LS_OVERRIDES_PROJECTS) || '{}');
// Store per-date split flags for half-day display. When true for an empId+date,
// the DTR entry is rendered as two separate rows (AM and PM) rather than a
// single combined row. The split state is persisted in localStorage under
// LS_SPLITS. Keys are formatted as empId + '___' + date.
const LS_SPLITS = 'att_splits_v1';
let splits = {};
try {
  splits = JSON.parse(localStorage.getItem(LS_SPLITS) || '{}');
} catch (e) {
  splits = {};
}
function saveSplits() {
  try {
    localStorage.setItem(LS_SPLITS, JSON.stringify(splits));
  } catch (e) {
    console.warn('Saving splits failed', e);
  }
  syncSplitOverrides();
}
// Toggle split and unsplit state for a given employee/date key.  These helper
// functions are used by the DTR table buttons to avoid inline IIFEs.  They set
// the split flag in the `splits` object, persist it to localStorage via
// saveSplits(), and trigger a re-render of the results.
function splitRecord(key) {
  // When splitting, mark all three segments (AM, PM, OT) as split.  Use
  // an object so we can track split state per segment.
  splits[key] = { AM: true, PM: true, OT: true };
  saveSplits();
  renderResults();
}
function unsplitRecord(key) {
  // Group AM/PM/OT segments by their resolved project IDs.  Each group with
  // more than one segment is recombined (segment-level overrides cleared and
  // marked as unsplit).  Groups with a single segment remain split.
  const [empId] = key.split('___');
  const emp = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees[empId] : null;
  const defaultProj = emp && emp.projectId ? emp.projectId : '';
  let dayProj = overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, key)
    ? overridesProjects[key]
    : defaultProj;

  const segments = ['AM', 'PM', 'OT'];
  const groups = {};
  segments.forEach(seg => {
    const segKey = key + '___' + seg;
    const pid = (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, segKey))
      ? overridesProjects[segKey]
      : dayProj;
    const p = String(pid || '');
    if (!groups[p]) groups[p] = [];
    groups[p].push(seg);
  });

  let splitEntry = splits[key];
  if (!splitEntry || typeof splitEntry !== 'object') {
    splitEntry = { AM: true, PM: true, OT: true };
  }

  Object.keys(groups).forEach(proj => {
    const segs = groups[proj];
    if (segs.length > 1) {
      // Multiple segments share this project â†’ clear per-segment overrides and
      // mark them unsplit. Also set day-level override if needed.
      segs.forEach(seg => {
        const segKey = key + '___' + seg;
        if (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, segKey)) {
          delete overridesProjects[segKey];
        }
        if (overridesSchedules && Object.prototype.hasOwnProperty.call(overridesSchedules, segKey)) {
          delete overridesSchedules[segKey];
        }
        splitEntry[seg] = false;
      });
      const unifiedProj = proj;
      if (String(unifiedProj || '') !== String(defaultProj || '')) {
        overridesProjects[key] = unifiedProj;
      } else {
        delete overridesProjects[key];
      }
    } else {
      // Single segment â†’ keep its split flag
      segs.forEach(seg => { splitEntry[seg] = true; });
    }
  });

  // Remove split entry if no segments remain split
  const anySplit = segments.some(seg => splitEntry[seg]);
  if (anySplit) {
    splits[key] = splitEntry;
  } else {
    delete splits[key];
  }

  saveSplits();
  saveOverrides();
  renderResults();
}
function saveOverrides(){
  localStorage.setItem(LS_OVERRIDES_SCHEDULES, JSON.stringify(overridesSchedules));
  localStorage.setItem(LS_OVERRIDES_PROJECTS, JSON.stringify(overridesProjects));
  syncSplitOverrides();
}

function baseKey(k){
  const parts = String(k || '').split('___');
  return parts.length >= 2 ? parts[0] + '___' + parts[1] : k;
}
function collectOverridesForKey(src, key){
  const obj = {};
  if (src && Object.prototype.hasOwnProperty.call(src, key)) obj.base = src[key];
  ['AM','PM','OT'].forEach(function(seg){
    const segKey = key + '___' + seg;
    if (src && Object.prototype.hasOwnProperty.call(src, segKey)) obj[seg] = src[segKey];
  });
  return Object.keys(obj).length ? obj : null;
}
async function syncSplitOverrides(){
  if (!window.supabase) return;
  try {
    const keySet = new Set();
    Object.keys(splits || {}).forEach(k => keySet.add(baseKey(k)));
    Object.keys(overridesProjects || {}).forEach(k => keySet.add(baseKey(k)));
    Object.keys(overridesSchedules || {}).forEach(k => keySet.add(baseKey(k)));
    if (keySet.size === 0) return;
    const rows = [];
    keySet.forEach(function(k){
      const parts = k.split('___');
      rows.push({
        emp_id: parts[0],
        date: parts[1],
        splits: splits[k] || null,
        overrides_projects: collectOverridesForKey(overridesProjects, k),
        overrides_schedules: collectOverridesForKey(overridesSchedules, k)
      });
    });
    const { error } = await window.supabase
      .from(SPLIT_OVERRIDES_TABLE)
      .upsert(rows, { onConflict: 'emp_id,date' });
    if (error) console.warn('syncSplitOverrides error', error);
  } catch (e) {
    console.warn('syncSplitOverrides failed', e);
  }
}
async function hydrateSplitOverrides(){
  if (!window.supabase) return;
  try {
    const { data, error } = await window.supabase
      .from(SPLIT_OVERRIDES_TABLE)
      .select('*');
    if (error) throw error;
    (data || []).forEach(function(row){
      const key = row.emp_id + '___' + row.date;
      if (row.splits) splits[key] = row.splits;
      if (row.overrides_projects) {
        const proj = row.overrides_projects;
        if (proj.base != null) overridesProjects[key] = proj.base;
        ['AM','PM','OT'].forEach(function(seg){
          if (proj[seg] != null) overridesProjects[key + '___' + seg] = proj[seg];
        });
      }
      if (row.overrides_schedules) {
        const sch = row.overrides_schedules;
        if (sch.base != null) overridesSchedules[key] = sch.base;
        ['AM','PM','OT'].forEach(function(seg){
          if (sch[seg] != null) overridesSchedules[key + '___' + seg] = sch[seg];
        });
      }
    });
    try { localStorage.setItem(LS_SPLITS, JSON.stringify(splits)); } catch(e){}
    try { localStorage.setItem(LS_OVERRIDES_PROJECTS, JSON.stringify(overridesProjects)); } catch(e){}
    try { localStorage.setItem(LS_OVERRIDES_SCHEDULES, JSON.stringify(overridesSchedules)); } catch(e){}
  } catch (e) {
    console.warn('hydrate split_overrides failed', e);
  }
}


const DEFAULT_RANGES = {
  rng_am_in_start:"05:00", rng_am_in_end:"09:00",
  rng_am_out_start:"11:30", rng_am_out_end:"12:30",
  rng_pm_in_start:"12:30", rng_pm_in_end:"14:30",
  rng_pm_out_start:"15:00", rng_pm_out_end:"20:00",
  rng_ot_in_start:"19:00", rng_ot_in_end:"22:00",
  rng_ot_out_start:"19:00", rng_ot_out_end:"23:59",
  rng_sat_ot_start:"11:00", rng_sat_ot_end:"23:59"
};
const DEFAULT_SCHEDULE = {
  name: "Default",
  sch_am_start:"08:00", sch_am_end:"12:00",
  sch_pm_start:"13:00", sch_pm_end:"17:00",
  
  sch_sat_start:"", sch_sat_end:"",
  sch_grace:15,
  ...DEFAULT_RANGES

};

/*
 * Initialize the local storedRecords variable from the global store.  The
 * global `window.storedRecords` is set by the boot guard.  Avoid pulling
 * from localStorage here so that Supabase data is always preferred.  If
 * the global has not been defined for some reason, fall back to an empty
 * array.  This ensures the application never silently falls back to a
 * stale local cache when a remote dataset may be available.
 */
let storedRecords = (typeof window !== 'undefined' && Array.isArray(window.storedRecords))
  ? window.storedRecords
  : [];
let storedEmployees = JSON.parse(localStorage.getItem(LS_EMPLOYEES) || '{}');
let storedSchedules = JSON.parse(localStorage.getItem(LS_SCHEDULES) || 'null');
let defaultScheduleId = localStorage.getItem(LS_SCHEDULES_DEFAULT) || null;
let storedProjects = JSON.parse(localStorage.getItem(LS_PROJECTS) || '{}');
document.getElementById('downloadEmployeesCSV').addEventListener('click', () => {
  const header = ['ID','Name','Hourly Rate','Company','Bank Account','Schedule Name','Schedule ID','Project Name','Project ID','Deduct Pag-IBIG','Deduct PhilHealth','Deduct SSS'];
  const rows = [header];
  Object.keys(storedEmployees).forEach(id => {
    const emp = storedEmployees[id] || {};
    const schedId = emp.scheduleId || '';
    const schedName = (storedSchedules && storedSchedules[schedId]?.name) || '';
    const projId = emp.projectId || '';
    const projName = (storedProjects && storedProjects[projId]?.name) || '';
    const bank = emp.bankAccount || '';
    const company = emp.company || COMPANY_OPTIONS[0] || '';
    const flags = (typeof contribFlags !== 'undefined' && contribFlags[id]) || {};
    const fPI = (flags.pagibig !== false) ? 'Yes' : 'No';
    const fPH = (flags.philhealth !== false) ? 'Yes' : 'No';
    const fSSS = (flags.sss !== false) ? 'Yes' : 'No';
    rows.push([id, emp.name || '', emp.hourlyRate || '', company, bank, schedName, schedId, projName, projId, fPI, fPH, fSSS]);
  });

  const csv = rows.map(r => r.map(v => {
    const s = String(v ?? '');
    return (s.includes(',') || s.includes('"') || s.includes('\n')) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'employees_backup.csv';
  a.click();
});

let currentProjectFilter = localStorage.getItem(LS_FILTER_PROJECT) || 'all';

function ensureSchedules(){
  if(!storedSchedules || typeof storedSchedules !== 'object'){
    const id = 'sched_' + Date.now();
    storedSchedules = {};
    storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE);
    storedSchedules[id].name = DEFAULT_SCHEDULE.name;
    defaultScheduleId = id;
    saveSchedulesToLS();
  } else {
    Object.keys(storedSchedules).forEach(id=>{
      storedSchedules[id] = { ...DEFAULT_RANGES, ...storedSchedules[id] };
      storedSchedules[id].sch_am_start = storedSchedules[id].sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
      storedSchedules[id].sch_am_end   = storedSchedules[id].sch_am_end   || DEFAULT_SCHEDULE.sch_am_end;
      storedSchedules[id].sch_pm_start = storedSchedules[id].sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
      storedSchedules[id].sch_pm_end   = storedSchedules[id].sch_pm_end   || DEFAULT_SCHEDULE.sch_pm_end;
      if(typeof storedSchedules[id].sch_grace !== 'number') storedSchedules[id].sch_grace = DEFAULT_SCHEDULE.sch_grace;
      storedSchedules[id].name = storedSchedules[id].name || 'Schedule';
    });
    if(!defaultScheduleId || !storedSchedules[defaultScheduleId]){
      const keys = Object.keys(storedSchedules);
      if(keys.length) defaultScheduleId = keys[0];
      saveSchedulesToLS();
    }
  }
}
function saveSchedulesToLS(){
  localStorage.setItem(LS_SCHEDULES, JSON.stringify(storedSchedules));
  localStorage.setItem(LS_SCHEDULES_DEFAULT, defaultScheduleId);
}

const tabs = {
  tabMain: document.getElementById('tabMain'),
  // Dashboard tab/button for high-level summary and payroll history
  tabDashboard: document.getElementById('tabDashboard'),
  tabSchedule: document.getElementById('tabSchedule'),
  tabEmployees: document.getElementById('tabEmployees'),
  tabProjects: document.getElementById('tabProjects'),
  panelMain: document.getElementById('panelMain'),
  // Corresponding Dashboard panel
  panelDashboard: document.getElementById('panelDashboard'),
  panelSchedule: document.getElementById('panelSchedule'),
  panelEmployees: document.getElementById('panelEmployees'),
  panelProjects: document.getElementById('panelProjects'),
  tabPayroll: document.getElementById('tabPayroll'),
  panelPayroll: document.getElementById('panelPayroll'),
  tabProjectTotals: document.getElementById('tabProjectTotals'),
  panelProjectTotals: document.getElementById('panelProjectTotals'),
  tabContributionSummary: document.getElementById('tabContributionSummary'),
  panelContributionSummary: document.getElementById('panelContributionSummary')
};
function showTab(name){
  Object.values(tabs).forEach(el => el && el.classList && el.classList.remove('active'));

  // Manage date range controls: disable on non-dashboard tabs, enable on dashboard unless forced
  (() => {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (wsEl && weEl) {
      const isDash = (name === 'dashboard');
      // Only toggle if the inputs are not forcibly disabled (e.g., due to lock/open)
      const forced = wsEl.dataset.forced === 'true' || weEl.dataset.forced === 'true';
      if (!forced) {
        wsEl.disabled = !isDash;
        weEl.disabled = !isDash;
      }
    }
  })();
  if(name==='main'){ tabs.tabMain.classList.add('active'); tabs.panelMain.classList.add('active'); }
  // When the dashboard is selected, activate its tab and panel
  if(name==='dashboard'){ tabs.tabDashboard && tabs.tabDashboard.classList.add('active'); tabs.panelDashboard && tabs.panelDashboard.classList.add('active'); }
  if(name==='schedule'){ tabs.tabSchedule.classList.add('active'); tabs.panelSchedule.classList.add('active'); renderScheduleEditor(); }
  if(name==='employees'){ tabs.tabEmployees.classList.add('active'); tabs.panelEmployees.classList.add('active'); renderEmployees(); }
  if(name==='projects'){ tabs.tabProjects.classList.add('active'); tabs.panelProjects.classList.add('active'); renderProjects(); }

  if(name==='payroll'){ tabs.tabPayroll && tabs.tabPayroll.classList.add('active'); tabs.panelPayroll && tabs.panelPayroll.classList.add('active'); }
  if(name==='projectTotals'){ tabs.tabProjectTotals && tabs.tabProjectTotals.classList.add('active'); tabs.panelProjectTotals && tabs.panelProjectTotals.classList.add('active'); }
  if(name==='contribSummary'){ tabs.tabContributionSummary && tabs.tabContributionSummary.classList.add('active'); tabs.panelContributionSummary && tabs.panelContributionSummary.classList.add('active'); }
}
window.__dtrFilterBackup = null;
// When switching to the main (DTR) tab, render results and then toggle the edit
// state based on whether the selected period is locked. Without this call,
// the DTR UI may remain interactive even when a locked payroll period is
// selected. Any errors are caught to avoid breaking tab switching.
tabs.tabMain.addEventListener('click', () => {
  showTab('main');
  try {
    if (window.__dtrFilterBackup) {
      const { name, project, from, to } = window.__dtrFilterBackup;
      const nameEl = document.getElementById('dtrSearchName');
      const projectEl = document.getElementById('filterProject');
      const fromEl = document.getElementById('dtrDateFrom');
      const toEl = document.getElementById('dtrDateTo');
      if (nameEl) nameEl.value = name;
      if (projectEl) {
        projectEl.value = project;
        currentProjectFilter = project || 'all';
        try { localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter); } catch (e) {}
      }
      if (fromEl) fromEl.value = from;
      if (toEl) toEl.value = to;
      try {
        if (from) localStorage.setItem(LS_FROM, from);
        else localStorage.removeItem(LS_FROM);
        if (to) localStorage.setItem(LS_TO, to);
        else localStorage.removeItem(LS_TO);
      } catch (e) {}
      window.__dtrFilterBackup = null;
    }
    renderResults();
  } catch (e) {}
  try {
    if (typeof checkAndToggleEditState === 'function') {
      checkAndToggleEditState();
    }
  } catch (e) {}
});
tabs.tabSchedule.addEventListener('click', ()=>showTab('schedule'));
tabs.tabEmployees.addEventListener('click', ()=>showTab('employees'));
tabs.tabProjects.addEventListener('click', ()=>showTab('projects'));

tabs.tabPayroll.addEventListener('click', ()=>{
  try {
    const defaultBtn = document.querySelector('#panelPayroll .tabs .tab-btn[data-tab="payrollTab"]');
    if (defaultBtn) defaultBtn.click();
  } catch (e) {}

  showTab('payroll');
  // Ensure the DTR grid is rendered so payroll hours can be derived even if the user
  // hasn't opened the DTR tab in this session.
  try {
    if (typeof renderResults === 'function') renderResults();
  } catch (e) {}
  // When entering the payroll tab, derive hours directly from the DTR results table
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch(e){}
});

// On initial load, render the DTR grid so dependent tabs (like payroll) have hours
// available without requiring a prior visit to the DTR tab.
(function ensureDtrRenderedOnBoot(){
  const renderDtr = () => {
    try {
      if (typeof renderResults === 'function') renderResults();
    } catch (e) {}
  };

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', renderDtr, { once: true });
  else renderDtr();
})();

// Switch to the dashboard tab when clicked. Render payroll history if available.
if (tabs.tabDashboard) {
  tabs.tabDashboard.addEventListener('click', () => {
    showTab('dashboard');
    try {
      if (typeof renderHistory === 'function') renderHistory();
    } catch (e) {}
  });
}

const scheduleSelect = document.getElementById('scheduleSelect');
const scheduleNameInput = document.getElementById('scheduleName');

function renderScheduleSelector(){
  scheduleSelect.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = (storedSchedules[id].name || id) + (id === defaultScheduleId ? " (Default)" : "");
    scheduleSelect.appendChild(opt);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) scheduleSelect.value = defaultScheduleId;
  else if(scheduleSelect.options.length) scheduleSelect.selectedIndex = 0;
  renderEmpScheduleDropdowns();
  renderEmpScheduleDropdownsInTable();
}

function renderScheduleEditor(){
  const sel = scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  const s = storedSchedules[sel];
  document.querySelector('[data-key="sch_am_start"]').value = s.sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
  document.querySelector('[data-key="sch_am_end"]').value = s.sch_am_end || DEFAULT_SCHEDULE.sch_am_end;
  document.querySelector('[data-key="sch_pm_start"]').value = s.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
  document.querySelector('[data-key="sch_pm_end"]').value = s.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end;
  
  const satStartInp = document.querySelector('[data-key="sch_sat_start"]');
  const satEndInp   = document.querySelector('[data-key="sch_sat_end"]');
  if (satStartInp) satStartInp.value = (s.sch_sat_start || "");
  if (satEndInp)   satEndInp.value   = (s.sch_sat_end   || "");
document.querySelector('[data-key="sch_grace"]').value = (s.sch_grace !== undefined ? s.sch_grace : DEFAULT_SCHEDULE.sch_grace);
  scheduleNameInput.value = s.name || ("Schedule " + sel);
  document.querySelectorAll('#rangesTable input[data-key]').forEach(inp=>{
    const key = inp.dataset.key;
    inp.value = s[key] || (DEFAULT_RANGES && DEFAULT_RANGES[key]) || "";
  });
}

function gatherScheduleFromEditor(){
  return {
    name: scheduleNameInput.value.trim() || ("Schedule " + Date.now()),
    sch_am_start: document.querySelector('[data-key="sch_am_start"]').value || DEFAULT_SCHEDULE.sch_am_start,
    sch_am_end: document.querySelector('[data-key="sch_am_end"]').value || DEFAULT_SCHEDULE.sch_am_end,
    sch_pm_start: document.querySelector('[data-key="sch_pm_start"]').value || DEFAULT_SCHEDULE.sch_pm_start,
    sch_pm_end: document.querySelector('[data-key="sch_pm_end"]').value || DEFAULT_SCHEDULE.sch_pm_end,
    
    sch_sat_start: (document.querySelector('[data-key="sch_sat_start"]')?.value || ""),
    sch_sat_end:   (document.querySelector('[data-key="sch_sat_end"]')?.value   || ""),
sch_grace: Number(document.querySelector('[data-key="sch_grace"]').value || DEFAULT_SCHEDULE.sch_grace),
    ...Object.fromEntries([...document.querySelectorAll('#rangesTable input[data-key]')].map(i=>[i.dataset.key, i.value || DEFAULT_RANGES[i.dataset.key] || ""]))
  };
}

document.getElementById('addScheduleBtn').addEventListener('click', ()=>{
  const id = 'sched_' + Date.now();
  storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE); storedSchedules[id].name = 'New schedule';
  saveSchedulesToLS(); renderScheduleSelector(); scheduleSelect.value = id; renderScheduleEditor();
});
document.getElementById('deleteScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  if(Object.keys(storedSchedules).length === 1){ alert('Cannot delete the only schedule.'); return; }
  if(!confirm('Delete schedule "' + storedSchedules[sel].name + '"?')) return;
  delete storedSchedules[sel];
  if(!storedSchedules[defaultScheduleId]) defaultScheduleId = Object.keys(storedSchedules)[0];
  Object.keys(storedEmployees).forEach(eid=>{
    if(storedEmployees[eid].scheduleId === sel) storedEmployees[eid].scheduleId = defaultScheduleId;
  });
  saveSchedulesToLS(); saveEmployeesToLS(); renderScheduleSelector(); renderEmployees(); renderResults();
});
document.getElementById('setDefaultScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return; defaultScheduleId = sel; saveSchedulesToLS(); renderScheduleSelector();
});
document.getElementById('saveScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  const oldRanges = {};
  Object.keys(DEFAULT_RANGES).forEach(k=> oldRanges[k] = (storedSchedules[sel] && storedSchedules[sel][k]) || DEFAULT_RANGES[k]);
  storedSchedules[sel] = { ...gatherScheduleFromEditor(), ...oldRanges, name: document.getElementById('scheduleName').value.trim() || storedSchedules[sel].name || 'Schedule' };
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || DEFAULT_RANGES[i.dataset.key] || "";
  });
  saveSchedulesToLS(); renderScheduleSelector(); renderEmpScheduleDropdowns(); renderResults();
});
scheduleSelect.addEventListener('change', ()=>{ renderScheduleEditor(); });

function saveRangesFromUI(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || "";
  });
  saveSchedulesToLS();
  renderResults();
}
function resetRanges(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  Object.keys(DEFAULT_RANGES).forEach(k=>{
    storedSchedules[sel][k] = DEFAULT_RANGES[k];
  });
  saveSchedulesToLS();
  renderScheduleEditor();
  renderResults();
}
document.getElementById('saveRangesBtn').addEventListener('click', saveRangesFromUI);
document.getElementById('resetRangesBtn').addEventListener('click', resetRanges);

function saveEmployeesToLS(){ localStorage.setItem(LS_EMPLOYEES, JSON.stringify(storedEmployees)); }
function renderEmpScheduleDropdowns(){
  const sel = document.getElementById('empScheduleSelect'); if(!sel) return;
  sel.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const o=document.createElement('option'); o.value=id;
    o.textContent=storedSchedules[id].name + (id===defaultScheduleId?' (Default)':'');
    sel.appendChild(o);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) sel.value = defaultScheduleId;
}
function renderEmpScheduleDropdownsInTable(){
  document.querySelectorAll('.emp-sel-schedule').forEach(sel=>{
    const id = sel.dataset.id;
    sel.innerHTML = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      const o = document.createElement('option'); o.value = sid; o.textContent = label;
      if(storedEmployees[id] && storedEmployees[id].scheduleId === sid) o.selected = true;
      sel.appendChild(o);
    });
  });
}

function saveProjectsToLS(options = {}){
  localStorage.setItem(LS_PROJECTS, JSON.stringify(storedProjects));
  if(!(options && options.skipRender)){
    renderProjects();
  }
  renderProjectDropdowns();
  renderProjectFilterOptions();
  renderResults();
}
function renderProjects(){
  const tbody = document.querySelector('#projectsTable tbody'); tbody.innerHTML = '';
  const projectCompanySel = document.getElementById('projectCompanySelect');
  const prevCompany = projectCompanySel ? projectCompanySel.value : '';
  populateCompanySelect(projectCompanySel, prevCompany);
  let needsSave = false;
  Object.keys(storedProjects).forEach(pid=>{
    const project = storedProjects[pid];
    let company = project.company;
    if (!COMPANY_OPTIONS.includes(company)) {
      company = COMPANY_OPTIONS[0] || '';
      project.company = company;
      needsSave = true;
    }
    const companyOptionsHtml = buildCompanyOptionsHtml(company);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td><input class="cell proj-name-input" data-id="${pid}" value="${project.name}"></td>
      <td><select class="proj-company-select" data-id="${pid}">${companyOptionsHtml}</select></td>
      <td><button class="del-proj" data-id="${pid}">Delete</button></td>`;
    tbody.appendChild(tr);
  });
  if (needsSave) saveProjectsToLS({ skipRender: true });
  document.querySelectorAll('.del-proj').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const id = e.target.dataset.id;
      if(confirm('Delete project "' + storedProjects[id].name + '"?')){
        delete storedProjects[id];
        Object.keys(storedEmployees).forEach(eid=>{ if(storedEmployees[eid].projectId === id) storedEmployees[eid].projectId = null; });
        saveProjectsToLS(); saveEmployeesToLS(); renderEmployees(); renderResults();
      }
    });
  });
  document.querySelectorAll('.proj-name-input').forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.dataset.id;
      storedProjects[id].name = e.target.value;
      saveProjectsToLS();
    });
  });
  document.querySelectorAll('.proj-company-select').forEach(sel => {
    sel.addEventListener('change', e => {
      const id = e.target.dataset.id;
      if (!storedProjects[id]) return;
      let value = e.target.value;
      if (!COMPANY_OPTIONS.includes(value)) {
        value = COMPANY_OPTIONS[0] || '';
        e.target.value = value;
      }
      storedProjects[id].company = value;
      saveProjectsToLS();
    });
  });

}
function renderProjectDropdowns(){
  const sel = document.getElementById('empProjectSelect');
  if(!sel) return;
  sel.innerHTML = '';
  const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid=>{
    const o=document.createElement('option'); o.value=pid; o.textContent=storedProjects[pid].name; sel.appendChild(o);
  });
}
function renderEmpProjectDropdownsInTable(){
  document.querySelectorAll('.emp-sel-project').forEach(sel=>{
    const id = sel.dataset.id;
    const prev = sel.value;
    sel.innerHTML = '';
    const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
    Object.keys(storedProjects).forEach(pid=>{
      const o = document.createElement('option'); o.value = pid; o.textContent = storedProjects[pid].name;
      if(storedEmployees[id] && storedEmployees[id].projectId === pid) o.selected = true;
      sel.appendChild(o);
    });
    if(prev) sel.value = prev;
  });
}

const filterProjectSel = document.getElementById('filterProject');
function renderProjectFilterOptions(){
  if(!filterProjectSel) return;
  const prev = currentProjectFilter || 'all';
  filterProjectSel.innerHTML = '';
  const make = (value, label)=>{ const o=document.createElement('option'); o.value=value; o.textContent=label; return o; };
  filterProjectSel.appendChild(make('all','All Projects'));
  filterProjectSel.appendChild(make('none','(No project)'));
  Object.keys(storedProjects).forEach(pid=>{
    filterProjectSel.appendChild(make(pid, storedProjects[pid].name));
  });
  if([...filterProjectSel.options].some(o=>o.value===prev)) filterProjectSel.value = prev;
  else filterProjectSel.value = 'all';
  currentProjectFilter = filterProjectSel.value;
}
filterProjectSel && filterProjectSel.addEventListener('change', ()=>{
  currentProjectFilter = filterProjectSel.value || 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);
  renderResults();
});

function buildCompanyOptionsHtml(selectedValue){
  const value = (selectedValue && COMPANY_OPTIONS.includes(selectedValue))
    ? selectedValue
    : (COMPANY_OPTIONS[0] || '');
  return COMPANY_OPTIONS.map(option =>
    `<option value="${option}" ${option === value ? 'selected' : ''}>${option}</option>`
  ).join('');
}

function populateCompanySelect(selectEl, selectedValue){
  if (!selectEl) return;
  const value = (selectedValue && COMPANY_OPTIONS.includes(selectedValue))
    ? selectedValue
    : (COMPANY_OPTIONS[0] || '');
  selectEl.innerHTML = buildCompanyOptionsHtml(value);
  if (value || value === '') {
    selectEl.value = value;
  }
}

function renderEmployees(){
  renderEmpScheduleDropdowns();
  renderProjectDropdowns();
  const empCompanySel = document.getElementById('empCompanySelect');
  const prevCompany = empCompanySel ? empCompanySel.value : '';
  populateCompanySelect(empCompanySel, prevCompany);
  const tbody = document.querySelector('#employeesTable tbody'); tbody.innerHTML = '';
  const ids = Object.keys(storedEmployees).sort((a,b)=>{
    const na = /^\d+$/.test(a), nb = /^\d+$/.test(b);
    if (na && nb) return Number(a) - Number(b);
    return String(a).localeCompare(String(b));
  });
  let needsSave = false;
  ids.forEach(id => {
    const emp = storedEmployees[id];
    let company = emp.company;
    if (!COMPANY_OPTIONS.includes(company)) {
      company = COMPANY_OPTIONS[0] || '';
      if (company !== undefined) {
        emp.company = company;
        needsSave = true;
      }
    }
    let scheduleOptionsHtml = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      scheduleOptionsHtml += `<option value="${sid}" ${emp.scheduleId===sid ? 'selected' : ''}>${label}</option>`;
    });
    let projectOptionsHtml = `<option value="">(None)</option>`;
    Object.keys(storedProjects).forEach(pid=>{
      projectOptionsHtml += `<option value="${pid}" ${emp.projectId===pid ? 'selected' : ''}>${storedProjects[pid].name}</option>`;
    });
    const companyOptionsHtml = buildCompanyOptionsHtml(company);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${id}</td>
      <td><input class="cell emp-name-input" data-id="${id}" value="${emp.name}"></td>
      <td><input class="cell emp-rate-input" type="number" step="0.01" min="0" data-id="${id}" value="${emp.hourlyRate != null ? emp.hourlyRate : ''}"></td>
      <td><select class="emp-sel-schedule" data-id="${id}">${scheduleOptionsHtml}</select></td>
      <td><select class="emp-sel-project" data-id="${id}">${projectOptionsHtml}</select></td>
      <td><select class="emp-company-select" data-id="${id}">${companyOptionsHtml}</select></td>
      <td><input class="cell emp-bank-input" data-id="${id}" value="${emp.bankAccount != null ? emp.bankAccount : ''}"></td>
      <td><input type="checkbox" class="emp-pagibig" data-id="${id}" ${ (contribFlags[id] && contribFlags[id].pagibig === false) ? '' : 'checked'}></td>
      <td><input type="checkbox" class="emp-philhealth" data-id="${id}" ${ (contribFlags[id] && contribFlags[id].philhealth === false) ? '' : 'checked'}></td>
      <td><input type="checkbox" class="emp-sss" data-id="${id}" ${ (contribFlags[id] && contribFlags[id].sss === false) ? '' : 'checked'}></td>
      <td><button class="del-emp" data-id="${id}">Delete</button></td>`;
    tbody.appendChild(tr);
    // Attach event listeners for contribution checkboxes for this employee
    const cbPagibig = tr.querySelector('.emp-pagibig');
    const cbPhilhealth = tr.querySelector('.emp-philhealth');
    const cbSss = tr.querySelector('.emp-sss');
    if (cbPagibig) {
      cbPagibig.addEventListener('change', () => {
        if (!contribFlags[id]) contribFlags[id] = {};
        contribFlags[id].pagibig = cbPagibig.checked;
        localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
        calculateAll();
      });
    }
    if (cbPhilhealth) {
      cbPhilhealth.addEventListener('change', () => {
        if (!contribFlags[id]) contribFlags[id] = {};
        contribFlags[id].philhealth = cbPhilhealth.checked;
        localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
        calculateAll();
      });
    }
    if (cbSss) {
      cbSss.addEventListener('change', () => {
        if (!contribFlags[id]) contribFlags[id] = {};
        contribFlags[id].sss = cbSss.checked;
        localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
        calculateAll();
      });
    }
  });

  if (needsSave) saveEmployeesToLS();

  document.querySelectorAll('.emp-name-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].name = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-rate-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    const id = e.target.dataset.id;
    const val = parseFloat(e.target.value) || 0;
    storedEmployees[id].hourlyRate = val; saveEmployeesToLS();
    try { payrollRates[id] = val; localStorage.setItem(LS_RATES, JSON.stringify(payrollRates)); } catch(err) {}
    renderResults();
  }));
document.querySelectorAll('.emp-sel-schedule').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].scheduleId = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-sel-project').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].projectId = e.target.value || null; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-company-select').forEach(sel=> sel.addEventListener('change', (e)=>{
    const id = e.target.dataset.id;
    if (!storedEmployees[id]) return;
    let value = e.target.value;
    if (!COMPANY_OPTIONS.includes(value)) {
      value = COMPANY_OPTIONS[0] || '';
      e.target.value = value;
    }
    storedEmployees[id].company = value;
    saveEmployeesToLS();
    renderResults();
  }));
  document.querySelectorAll('.del-emp').forEach(btn=> btn.addEventListener('click', (e)=>{
    const id=e.target.dataset.id;
    if(confirm(`Delete employee ${id} - ${storedEmployees[id].name}?`)){
      delete storedEmployees[id]; saveEmployeesToLS(); renderEmployees(); renderResults();
    }
  }));
}

document.getElementById('addEmployeeBtn').addEventListener('click', ()=>{
  const id = document.getElementById('empIdInput').value.trim();
  const name = document.getElementById('empNameInput').value.trim();
  const rate = parseFloat(document.getElementById('empRateInput').value) || 0;
  const scheduleId = document.getElementById('empScheduleSelect').value || defaultScheduleId;
  const projectId = document.getElementById('empProjectSelect').value || null;
  const companySelect = document.getElementById('empCompanySelect');
  let company = companySelect ? companySelect.value : '';
  if (!COMPANY_OPTIONS.includes(company)) company = COMPANY_OPTIONS[0] || '';
  const bank = document.getElementById('empBankInput').value.trim();
  if(!id){ alert('Enter ID'); return; } if(!name){ alert('Enter Name'); return; }
  storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId, company: company };
  // Initialize default contribution deduction flags for new employee if not already set
  if (!contribFlags[id]) {
    contribFlags[id] = { pagibig: true, philhealth: true, sss: true };
    localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
  }
  saveEmployeesToLS();
  document.getElementById('empIdInput').value=''; document.getElementById('empNameInput').value=''; document.getElementById('empRateInput').value=''; document.getElementById('empBankInput').value='';
  if (companySelect) companySelect.value = COMPANY_OPTIONS[0] || '';
  renderEmployees(); renderResults();
});
document.getElementById('clearEmployeesBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all employees?')) return;
  storedEmployees = {}; saveEmployeesToLS(); renderEmployees(); renderResults();
});

document.getElementById('empFileInput').addEventListener('change', (evt) => {
  const file = evt.target.files && evt.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      
const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
let added = 0, updated = 0;
const headerRow = rows[0] || [];
const normalizedHeader = headerRow.map(cell => String(cell ?? '').trim().toLowerCase());
const headerLikely = normalizedHeader.some(val => val === 'id' || val === 'employee id') && normalizedHeader.some(val => val === 'name' || val === 'employee name');
const dataRows = rows.slice(headerLikely ? 1 : 0);
const findIndex = (labels) => {
  for (const label of labels) {
    const idx = normalizedHeader.indexOf(label);
    if (idx !== -1) return idx;
  }
  return -1;
};
const companyHeaderIdx = findIndex(['company']);
const scheduleHeaderIdx = findIndex(['schedule name','schedule']);
const projectHeaderIdx = findIndex(['project name','project']);
const bankHeaderIdx = findIndex(['bank account','bank']);
const getCell = (row, idx) => (idx >= 0 && idx < row.length) ? row[idx] : '';
const companyIdxNew = companyHeaderIdx !== -1 ? companyHeaderIdx : 3;
const scheduleIdxNew = scheduleHeaderIdx !== -1 ? scheduleHeaderIdx : 4;
const projectIdxNew = projectHeaderIdx !== -1 ? projectHeaderIdx : 5;
const bankIdxNew = bankHeaderIdx !== -1 ? bankHeaderIdx : 6;
const scheduleIdxOld = scheduleHeaderIdx !== -1 ? scheduleHeaderIdx : 3;
const projectIdxOld = projectHeaderIdx !== -1 ? projectHeaderIdx : 4;
const bankIdxOld = bankHeaderIdx !== -1 ? bankHeaderIdx : 5;

dataRows.forEach(row => {
  if (!row || row.length < 2) return;
  const id = String(row[0] ?? '').trim();
  const name = String(row[1] ?? '').trim();
  const rate = row.length >= 3 ? parseFloat(row[2]) || 0 : 0;
  if (!id || !name) return;

  const newCompanyCandidate = String(getCell(row, companyIdxNew) ?? '').trim();
  const newScheduleCandidate = String(getCell(row, scheduleIdxNew) ?? '').trim();
  const newProjectCandidate = String(getCell(row, projectIdxNew) ?? '').trim();
  const newBankCandidate = String(getCell(row, bankIdxNew) ?? '').trim();

  const oldScheduleCandidateRaw = String(getCell(row, scheduleIdxOld) ?? '').trim();
  const oldProjectCandidateRaw = String(getCell(row, projectIdxOld) ?? '').trim();
  const oldBankCandidate = String(getCell(row, bankIdxOld) ?? '').trim();

  let useNewFormat = companyHeaderIdx !== -1;
  if (!useNewFormat) {
    if (COMPANY_OPTIONS.includes(newCompanyCandidate)) {
      useNewFormat = true;
    } else if (newCompanyCandidate && !oldScheduleCandidateRaw && newScheduleCandidate) {
      useNewFormat = true;
    } else if (!oldScheduleCandidateRaw && oldProjectCandidateRaw && newScheduleCandidate && oldProjectCandidateRaw === newScheduleCandidate) {
      useNewFormat = true;
    } else if (!oldScheduleCandidateRaw && oldBankCandidate && newProjectCandidate && oldBankCandidate === newProjectCandidate) {
      useNewFormat = true;
    } else if (!oldScheduleCandidateRaw && !oldProjectCandidateRaw && (newScheduleCandidate || newProjectCandidate)) {
      useNewFormat = true;
    } else if (row.length >= 7) {
      useNewFormat = true;
    }
  }

  let company = useNewFormat ? newCompanyCandidate : '';
  let scheduleName = (useNewFormat ? newScheduleCandidate : oldScheduleCandidateRaw) || '';
  let projectName = (useNewFormat ? newProjectCandidate : oldProjectCandidateRaw) || '';
  let bank = useNewFormat ? newBankCandidate : oldBankCandidate;

  if (!scheduleName && !useNewFormat) scheduleName = newScheduleCandidate || '';
  if (!projectName && !useNewFormat) projectName = newProjectCandidate || '';
  if (!bank && useNewFormat) bank = oldBankCandidate;
  if (!bank && !useNewFormat) bank = newBankCandidate;

  scheduleName = scheduleName.toLowerCase();
  projectName = projectName.toLowerCase();
  if (!COMPANY_OPTIONS.includes(company)) company = COMPANY_OPTIONS[0] || '';

  if (!storedEmployees[id]) { added++; } else { updated++; }
  let scheduleId = Object.keys(storedSchedules).find(k => (storedSchedules[k].name || '').toLowerCase() === scheduleName) || defaultScheduleId;
  let projectId = Object.keys(storedProjects).find(k => (storedProjects[k].name || '').toLowerCase() === projectName) || null;

  storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId, company: company };
});
saveEmployeesToLS();
renderEmployees();
renderResults();
if (added || updated) alert(`Imported: ${added}, Updated: ${updated}`);
    } catch (err) { console.error(err); alert('Error reading file.'); }
    finally { evt.target.value = ''; }
  };
  reader.readAsArrayBuffer(file);
});

function parseLine(line){
  if(!line || !line.trim()) return null;
  const parts = line.trim().split(/\t+/);
  if(parts.length >= 2){
    const id = parts[0].trim(); const dt = parts[1].trim();
    const m = dt.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})(:\d{2})?$/);
    if(m) return { empId: id, date: m[1], time: m[2] };
  }
  const m2 = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
  if(m2){
    const before = line.slice(0, m2.index); const idm = before.match(/(\d+)/);
    if(!idm) return null; return { empId: idm[1], date: m2[1], time: m2[2].slice(0,5) };
  }
  return null;
}



document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const inputEl = ev.target;
  const files = inputEl.files;
  if (!files || !files.length) return;

  let processed = 0, totalAdded = 0, errors = 0;
  const total = files.length;
  inputEl.disabled = true;

  Array.from(files).forEach(file=>{
    // Upload the raw .DAT/.TXT file to Supabase for backup/crossâ€‘device sync.
    try {
      if (typeof uploadDtrFileToCloud === 'function') {
        uploadDtrFileToCloud(file);
      }
    } catch (err) {
      // Ignore upload errors to avoid blocking file parsing
    }
    const r = new FileReader();
    r.onload = (e)=>{
      try {
        const content = String(e.target.result || '');
        const lines = content.split(/\r?\n/);
// === MIN PATCH: Only keep records inside the current payroll period (From/To) ===
let __from = '', __to = '';
try {
  const fEl = document.getElementById('weekStart');
  const tEl = document.getElementById('weekEnd');
  __from = (fEl && fEl.value) ? fEl.value : (localStorage.getItem('payroll_week_start') || '');
  __to   = (tEl && tEl.value) ? tEl.value : (localStorage.getItem('payroll_week_end')   || '');
} catch(_) {}
function __inRange(d){
  if (!d) return false;
  if (__from && d < __from) return false;
  if (__to   && d > __to)   return false;
  return true;
}
// === /MIN PATCH ===

        let added = 0;
        for(const ln of lines){
          const p = (typeof parseLine === 'function') ? parseLine(ln) : null;
          if (p && p.empId && p.date && p.time && __inRange(p.date)){
            storedRecords.push({ empId: String(p.empId), date: p.date, time: padHM(p.time) });
            added++;
          }
        }
        // Persist records locally for offline use
        try { localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords)); } catch(e){}
        // Refresh the DTR grid
        if (typeof renderResults === 'function') renderResults();
        // Persist the records to Supabase for crossâ€‘device sync
        try {
          if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
        } catch (e) {
          console.warn('Failed to save DTR to Supabase', e);
        }
        // Hide the remote alert since we now have data after upload
        try {
          if (typeof hideRemoteDtrAlert === 'function') hideRemoteDtrAlert();
        } catch (e) {
          // ignore alert errors
        }
        totalAdded += added;
      } catch(err){
        console.error('Error reading', file.name, err);
        errors++;
      } finally {
        processed++;
        if (processed === total){
          inputEl.disabled = false; inputEl.value = '';
          if (errors > 0){
            alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
          } else {
            alert(`Upload successful: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}.`);
          }
        }
      }
    };
    r.onerror = ()=>{
      errors++; processed++;
      if (processed === total){
        inputEl.disabled = false; inputEl.value = '';
        alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
      }
    };
    r.readAsText(file);
  });
});
function padHM(hm){ if(!hm) return ''; const [h,m]=hm.split(':').map(x=>String(Number(x)).padStart(2,'0')); return h.padStart(2,'0')+':'+m.padStart(2,'0'); }
function toMins(hm){ if(!hm) return null; const [h,m]=hm.split(':').map(Number); return h*60+m; }
function minsToDecimal(mins){ return (mins/60).toFixed(2); }

function buildScheduleDropdown(empId, date, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesSchedules[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}
function buildProjectDropdown(empId, date, currentProjectId){
  const sel = document.createElement('select');
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesProjects[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

// Build a project dropdown for half-day (AM/PM) rows. Uses a key that
// appends the half identifier (e.g. '123___2023-08-19___AM') so that
// overrides can be stored separately for morning and afternoon entries.
function buildProjectDropdownHalf(empId, date, half, currentProjectId){
  const sel = document.createElement('select');
  // Include a none/default option
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    // Persist override keyed by empId + date + half
    overridesProjects[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    // Re-render to apply changes
    renderResults();
  });
  return sel;
}

// Build a schedule dropdown for half-day (AM/PM) rows. Similar to
// buildScheduleDropdown but stores overrides using a half-specific key.
function buildScheduleDropdownHalf(empId, date, half, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    overridesSchedules[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

function formatHours(value){
  const num = parseFloat(value);
  return (!isFinite(num) || num === 0) ? '-' : num.toFixed(2);
}

function renderResults(){

// 12-hour clock formatter for display only (keeps underlying logic 24h)
function __fmt12Clock(hhmm){
  if(!hhmm || typeof hhmm !== 'string') return hhmm || '';
  const m = hhmm.match(/^\s*(\d{1,2})\s*:\s*(\d{2})\s*$/);
  if(!m) return hhmm;
  let h = parseInt(m[1],10), mm = m[2];
  let suffix = 'AM';
  if(h === 0){ h = 12; suffix = 'AM'; }
  else if(h === 12){ suffix = 'PM'; }
  else if(h > 12){ h = h - 12; suffix = 'PM'; }
  else { suffix = 'AM'; }
  return h + ':' + mm + ' ' + suffix;
}


  renderScheduleSelector();
  renderProjectFilterOptions();

  // Respect DTR tab's Date filter when present; fall back to active week.
  const __df = document.getElementById('dtrDateFrom');
  const __dt = document.getElementById('dtrDateTo');
  const startDate = (__df && __df.value) ? __df.value : (document.getElementById('weekStart').value || null);
  const endDate   = (__dt && __dt.value) ? __dt.value : (document.getElementById('weekEnd').value || null);
  currentProjectFilter = document.getElementById('filterProject') ? document.getElementById('filterProject').value : 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);

  
  const nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
const groups = {};
  const manualKeys = new Set();
  for(const r of storedRecords){
    if(startDate && r.date < startDate) continue;
    if(endDate && r.date > endDate) continue;
    const key = r.date + '___' + r.empId;
    if(!groups[key]) groups[key]=[];
    groups[key].push(r.time);
    if (r.manual) manualKeys.add(key);
  }

  const keys = Object.keys(groups).sort((a,b)=>{
    const [da,ea]=a.split('___'), [db,eb]=b.split('___');
    const nameA=(storedEmployees[ea] ? storedEmployees[ea].name : '').toLowerCase();
    const nameB=(storedEmployees[eb] ? storedEmployees[eb].name : '').toLowerCase();
    if(nameA && nameB){ if(nameA!==nameB) return nameA.localeCompare(nameB); if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb)); }
    if(nameA && !nameB) return -1; if(!nameA && nameB) return 1; if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb));
  });

  const tbody = document.querySelector('#resultsTable tbody'); tbody.innerHTML='';
  // Track rows appended to avoid expensive DOM queries after render
  let _rowCount = 0;
  // Initialize totals for DTR summary. We will accumulate regular and OT hours and unique employee IDs
  let _dtrTotalReg = 0;
  let _dtrTotalOt  = 0;
  const _dtrEmpIds = new Set();

  const __nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
  for(const key of keys){
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId] || null;
      if (__nameQuery) { const _nm = (emp && emp.name ? String(emp.name).toLowerCase() : ''); if (_nm.indexOf(__nameQuery) === -1) continue; }
let empProjId = emp ? (emp.projectId || '') : '';
    const overrideKeyProj = empId + '___' + date;
    if(overridesProjects[overrideKeyProj] !== undefined) empProjId = overridesProjects[overrideKeyProj];
    const passesProject =
      currentProjectFilter === 'all' ||
      (currentProjectFilter === 'none' && !empProjId) ||
      currentProjectFilter === empProjId;
    let _passes = passesProject;
if(!_passes && typeof splits !== 'undefined' && splits && splits[empId + '___' + date]){
  const segs = ['AM','PM','OT'];
  for (let i=0;i<segs.length;i++){
    const hk = empId + '___' + date + '___' + segs[i];
    const pidSeg = (typeof overridesProjects !== 'undefined' && overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, hk)) ? overridesProjects[hk] : empProjId;
    if (currentProjectFilter === 'all' || (currentProjectFilter === 'none' && !pidSeg) || currentProjectFilter === pidSeg){ _passes = true; break; }
  }
}
if(!_passes) continue;

    const times = Array.from(new Set(groups[key])).sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if(overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = storedSchedules[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);
    const rangesForEmp = {
      amIn: { start: schedule.rng_am_in_start || DEFAULT_RANGES.rng_am_in_start, end: schedule.rng_am_in_end || DEFAULT_RANGES.rng_am_in_end },
      amOut:{ start: schedule.rng_am_out_start || DEFAULT_RANGES.rng_am_out_start, end: schedule.rng_am_out_end || DEFAULT_RANGES.rng_am_out_end },
      pmIn: { start: schedule.rng_pm_in_start || DEFAULT_RANGES.rng_pm_in_start, end: schedule.rng_pm_in_end || DEFAULT_RANGES.rng_pm_in_end },
      pmOut:{ start: schedule.rng_pm_out_start || DEFAULT_RANGES.rng_pm_out_start, end: schedule.rng_pm_out_end || DEFAULT_RANGES.rng_pm_out_end },
      otIn: { start: schedule.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start, end: schedule.rng_ot_in_end || DEFAULT_RANGES.rng_ot_in_end },
      otOut:{ start: schedule.rng_ot_out_start || DEFAULT_RANGES.rng_ot_out_start, end: schedule.rng_ot_out_end || DEFAULT_RANGES.rng_ot_out_end }
    };

    const amInActual = pickEarliest(rangesForEmp.amIn), amOutActual = pickLatest(rangesForEmp.amOut);
    const pmInActual = pickEarliest(rangesForEmp.pmIn), pmOutActual = pickLatest(rangesForEmp.pmOut);

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otCandidates = times.filter(t => {
      const mins = toMins(t);
      return mins > pmOutRefMins && mins >= toMins(rangesForEmp.otIn.start) && mins <= toMins(rangesForEmp.otIn.end);
    });
    // --- Patched OT In/Out picking (DTR) ---
const otInCandidates = times.filter(t => {
  const m = toMins(t);
  return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otIn.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otIn.end);
});
const otInActual = otInCandidates.length ? otInCandidates[0] : null;

const otOutCandidates = times
  .filter(t => {
    const m = toMins(t);
    return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otOut.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otOut.end);
  })
  .filter(t => !otInActual || toMins(t) >= toMins(otInActual));
const otOutActual = otOutCandidates.length ? otOutCandidates[otOutCandidates.length - 1] : null;
// --- end patch ---

// Saturday fallback: if only a single OUT exists beyond the Saturday end, treat OT as (satEnd -> lastOut)
let otInCalc = otInActual;
let otOutCalc = otOutActual;
try {
  if (__isSaturday && __satEnd) {
    const lastOut = pmOutActual || amOutActual || null;
    const lastOutM = lastOut ? toMins(lastOut) : null;
    const satEndM = toMins(__satEnd);
    if (lastOutM !== null && lastOutM > satEndM) {
      if (!otInCalc) otInCalc = __satEnd;
      if (!otOutCalc) otOutCalc = lastOut;
    }
  }
} catch(e){ console.warn('Saturday OT fallback failed', e); }


    
    
    
    // Recompute regular time deterministically (no dependency on raw 'times' array)
    let totalMins = 0; const grace = Number(schedule.sch_grace) || 0;

    const clampSeg = (inStr, outStr, segStartStr, segEndStr) => {
      // Helper to add minutes
      const addMin = (m, d) => /* no-op placeholder removed */ m; // placeholder
    
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const segStart = toMins(segStartStr), segEndRaw = toMins(segEndStr);
      let segEnd = segEndRaw;
      // Auto-correct common input mistake: PM End typed as AM (e.g., 06:00 instead of 18:00)
      if (segEnd <= segStart && segStart >= 12*60 && segEnd <= 12*60) {
        segEnd += 12*60; // push to PM
      }
      if (segEnd <= segStart) return 0;
      if (inM <= segStart + grace) inM = segStart;
      const endM = Math.min(outM, segEnd);
      return Math.max(0, endM - inM);
    };

    if (__isSaturday && __satStart && __satEnd) {
      // Use the earliest actual IN and latest actual OUT between AM/PM within the Saturday window
      const firstIn  = amInActual || pmInActual || null;
      const lastOut  = pmOutActual || amOutActual || null;
      totalMins = clampSeg(firstIn, lastOut, __satStart, __satEnd);
    } else {
      // Weekdays: compute AM and PM independently; add them
      const hasBridge = !!(amInActual && !amOutActual && !pmInActual && pmOutActual);
      if (hasBridge) {
        const synthAmOut = schedule.sch_am_end || "12:00";
        const synthPmIn  = schedule.sch_pm_start || "13:00";
        totalMins =
          clampSeg(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
          clampSeg(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
      } else {
        const amMins = clampSeg(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
        const pmMins = clampSeg(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
        totalMins = amMins + pmMins;
      }
    }

    const totalRegularDecimal = minsToDecimal(totalMins);
let otMins = 0;
    if(otInCalc && otOutCalc){
      const otStartClamp = Math.max(toMins(otInCalc), toMins(__isSaturday ? (__satEnd || rangesForEmp.otIn.start) : rangesForEmp.otIn.start));
      const otEndClamp   = Math.min(toMins(otOutCalc), toMins(__isSaturday ? '23:59' : (rangesForEmp.otOut.end || rangesForEmp.otIn.end)));
      if(otEndClamp > otStartClamp) otMins = otEndClamp - otStartClamp;
    }
    
    // Saturday definitive OT computation: last OUT beyond Saturday end is OT
    try {
      if (__isSaturday && __satEnd) {
        const lastOut = (pmOutActual || amOutActual || null);
        if (lastOut) {
          const satEndM = toMins(__satEnd);
          const satStartClamp = Math.max(satEndM, toMins(schedule.rng_sat_ot_start || __satEnd || DEFAULT_RANGES.rng_sat_ot_start));
          const satEndClamp   = toMins(schedule.rng_sat_ot_end || DEFAULT_RANGES.rng_sat_ot_end);
          const lastOutM = toMins(lastOut);
          const startM = satStartClamp;
          const endM   = Math.min(lastOutM, satEndClamp);
          const diff = endM - startM;
          if (diff > 0) otMins = diff;
        }
      }
    } catch(e){ console.warn('Saturday OT direct compute failed', e); }

    // Fallback OT computation for nonâ€‘Saturday days.
    // When there are no explicit OT punches (or the OT IN occurs before
    // the end of the regular shift), treat any minutes worked beyond
    // the scheduled PM end as overtime. Only the final clockâ€‘out time
    // is considered to avoid counting intermediate segments.
    try {
      if (!__isSaturday) {
        // Determine the reference end time for regular work (PM shift end)
        const pmRef = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end || (typeof DEFAULT_SCHEDULE !== 'undefined' ? DEFAULT_SCHEDULE.sch_pm_end : '17:00'));
        // Determine if explicit OT was applied (OT IN after PM end)
        let hasExplicitOT = false;
        if (typeof otInCalc !== 'undefined' && typeof otOutCalc !== 'undefined' && otInCalc && otOutCalc) {
          const otInM = toMins(otInCalc);
          if (otInM > pmRef) hasExplicitOT = true;
        }
        if (!hasExplicitOT) {
          const lastOutFallback = pmOutActual || amOutActual || null;
          if (lastOutFallback) {
            const lastOutM = toMins(lastOutFallback);
            if (lastOutM > pmRef) {
              otMins = lastOutM - pmRef;
            }
          }
        }
      }
    } catch(err) { console.warn('Nonâ€‘Saturday OT fallback failed', err); }

    const otDecimal = minsToDecimal(otMins);

    // --- Begin AM/PM/OT Split Logic ---
    // If this record is flagged for split, render separate rows for the AM,
    // PM and OT portions instead of one combined row. A split is recorded
    // in the `splits` object keyed by the employee/date (empId + '___' + date).
    // When a record is split we compute the regular hours and overtime
    // separately for each segment using the schedule assigned to that half
    // (any overrides are honoured). Each segment has its own project and
    // schedule dropdowns. Grace periods are applied according to the
    // selected schedule.

    const splitKey = empId + '___' + date;
    let splitEntry = splits && splits[splitKey];
    if (splitEntry) {
      if (splitEntry === true) splitEntry = { AM: true, PM: true, OT: true };
      const name = emp ? emp.name : '';
      const merged = { regMins:0, otMins:0, amIn:null, amOut:null, pmIn:null, pmOut:null, otIn:null, otOut:null, count:0 };
      const clampSegHalf = (inStr, outStr, segStartStr, segEndStr, sched) => {
        if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
        let inM = toMins(inStr);
        const outM = toMins(outStr);
        const segStart = toMins(segStartStr);
        let segEnd = toMins(segEndStr);
        if (segEnd <= segStart && segStart >= 12 * 60 && segEnd <= 12 * 60) segEnd += 12 * 60;
        if (segEnd <= segStart) return 0;
        const g = Number(sched && sched.sch_grace) || 0;
        if (inM <= segStart + g) inM = segStart;
        const endM = Math.min(outM, segEnd);
        return Math.max(0, endM - inM);
      };
      const computeOtHalf = (sched) => {
        let otM = 0, otIn = null, otOut = null;
        let pmOutRef = pmOutActual ? toMins(pmOutActual) : toMins(sched.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end);
        let isSat = false, satStart = null, satEnd = null;
        try {
          const dow = (function(d){ const dt = new Date(d + 'T00:00'); return (isNaN(dt) ? new Date(d) : dt).getDay(); })(date);
          if (dow === 6) { isSat = true; satStart = sched.sch_sat_start || sched.sch_am_start || '08:00'; satEnd = sched.sch_sat_end || sched.sch_pm_end || sched.sch_am_end || '11:00'; pmOutRef = toMins(satEnd); }
        } catch(e){}
        const rng = {
          otIn: { start: sched.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start, end: sched.rng_ot_in_end || DEFAULT_RANGES.rng_ot_in_end },
          otOut:{ start: sched.rng_ot_out_start||DEFAULT_RANGES.rng_ot_out_start, end: sched.rng_ot_out_end||DEFAULT_RANGES.rng_ot_out_end }
        };
        const otInCands = times.filter(t=>{ const m=toMins(t); return m>pmOutRef && m>=toMins(isSat?satEnd:rng.otIn.start) && m<=toMins(isSat?'23:59':rng.otIn.end); });
        otIn = otInCands.length ? otInCands[0] : null;
        const otOutCands = times.filter(t=>{ const m=toMins(t); return m>pmOutRef && m>=toMins(isSat?satEnd:rng.otOut.start) && m<=toMins(isSat?'23:59':rng.otOut.end); }).filter(t=>!otIn||toMins(t)>=toMins(otIn));
        otOut = otOutCands.length ? otOutCands[otOutCands.length-1] : null;
        if (isSat && satEnd) { const lastOut=pmOutActual||amOutActual||null; const lastOutM=lastOut?toMins(lastOut):null; const satEndM=toMins(satEnd); if (lastOutM!==null&&lastOutM>satEndM){ if(!otIn) otIn=satEnd; if(!otOut) otOut=lastOut; } }
        if (otIn && otOut) { const startClamp=Math.max(toMins(otIn), toMins(isSat?(satEnd||rng.otIn.start):rng.otIn.start)); const endClamp=Math.min(toMins(otOut), toMins(isSat?'23:59':(rng.otOut.end||rng.otIn.end))); if(endClamp>startClamp) otM=endClamp-startClamp; }
        return { mins: otM, otIn: otIn, otOut: otOut };
      };
      const hasBridge = !!(amInActual && !amOutActual && !pmInActual && pmOutActual);
      const middayStart = schedule.sch_am_end || '12:00';
      const middayEnd   = schedule.sch_pm_start || '13:00';
      ['AM','PM','OT'].forEach(segment => {
        const halfKey = empId + '___' + date + '___' + segment;
        const schedIdHalf = (overridesSchedules && overridesSchedules[halfKey]) ? overridesSchedules[halfKey] : scheduleIdForEmp;
        const schedHalf = storedSchedules[schedIdHalf] || DEFAULT_SCHEDULE;
        let regMinsSeg=0, otMinsSeg=0, otInSeg=null, otOutSeg=null;
        if(segment==='AM'){ regMinsSeg = hasBridge ? clampSegHalf(amInActual, middayStart, schedHalf.sch_am_start || DEFAULT_SCHEDULE.sch_am_start, schedHalf.sch_am_end || DEFAULT_SCHEDULE.sch_am_end, schedHalf) : clampSegHalf(amInActual, amOutActual, schedHalf.sch_am_start || DEFAULT_SCHEDULE.sch_am_start, schedHalf.sch_am_end || DEFAULT_SCHEDULE.sch_am_end, schedHalf); }
        else if(segment==='PM'){ regMinsSeg = hasBridge ? clampSegHalf(middayEnd, pmOutActual, schedHalf.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start, schedHalf.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end, schedHalf) : clampSegHalf(pmInActual, pmOutActual, schedHalf.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start, schedHalf.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end, schedHalf); }
        else { const otRes=computeOtHalf(schedHalf); otMinsSeg=otRes.mins; otInSeg=otRes.otIn; otOutSeg=otRes.otOut; }
        const regDecSeg = minsToDecimal(regMinsSeg);
        const otDecSeg = segment==='OT'? minsToDecimal(otMinsSeg):'0.00';
        let projIdSeg = (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey)) ? overridesProjects[halfKey] : empProjId;
        const __segPass = (currentProjectFilter === 'all' || (currentProjectFilter === 'none' && !projIdSeg) || currentProjectFilter === projIdSeg);
        if(!__segPass){ return; }
        if (splitEntry[segment]) {
          const trSeg = document.createElement('tr');
          let htmlSeg='';
          htmlSeg += '<td>' + __fmt12Clock(empId) + '</td>';
          htmlSeg += '<td>' + (name || '') + '</td>';
          htmlSeg += '<td></td><td></td>';
          htmlSeg += '<td>' + __fmt12Clock(date) + '</td>';
          if(segment==='AM'){
            htmlSeg += (amInActual ? '<td>' + __fmt12Clock(amInActual) + '</td>' : '<td class="missing">-</td>');
            htmlSeg += (hasBridge || !amOutActual) ? '<td class="missing">-</td>' : '<td>' + __fmt12Clock(amOutActual) + '</td>';
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td>';
          } else if(segment==='PM'){
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td>';
            htmlSeg += (hasBridge || !pmInActual) ? '<td class="missing">-</td>' : '<td>' + __fmt12Clock(pmInActual) + '</td>';
            htmlSeg += (pmOutActual ? '<td>' + __fmt12Clock(pmOutActual) + '</td>' : '<td class="missing">-</td>');
          } else {
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td><td class="missing">-</td><td class="missing">-</td>';
          }
          if(segment==='OT'){
            htmlSeg += (otInSeg ? '<td>'+__fmt12Clock(otInSeg)+'</td>' : '<td class="missing">-</td>');
            htmlSeg += (otOutSeg ? '<td>'+__fmt12Clock(otOutSeg)+'</td>' : '<td class="missing">-</td>');
          } else {
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td>';
          }
          htmlSeg += '<td>' + formatHours(regDecSeg) + '</td>';
          htmlSeg += '<td>' + formatHours(otDecSeg) + '</td>';
          htmlSeg += '<td>' + formatHours(String((parseFloat(regDecSeg)||0)+(parseFloat(otDecSeg)||0))) + '</td>';
          htmlSeg += '<td><button type="button" class="btn-unsplit" data-key="' + splitKey + '" onclick="unsplitRecord(this.dataset.key)">Unsplit</button></td>';
          // Ensure Actions column always has a Delete button for split rows
          htmlSeg += '<td class="actions-cell"><button type="button" class="dtr-del-btn">Delete</button></td>';
          trSeg.innerHTML = htmlSeg;
          try {
            if (typeof manualKeys !== 'undefined' && manualKeys.has(splitKey)) {
              const nmCellSeg = trSeg.cells[1];
              if (nmCellSeg && !nmCellSeg.querySelector('.manual-indicator')) {
                const s2 = document.createElement('span');
                s2.className = 'manual-indicator';
                s2.title = 'Contains manual DTR';
                s2.textContent = '*';
                nmCellSeg.appendChild(s2);
              }
            }
          } catch(e){}
          const hasOverrideSeg = (overridesSchedules && overridesSchedules[halfKey]) || (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey));
          if (hasOverrideSeg) { trSeg.style.backgroundColor = '#fff3cd'; }
          const pcSeg = trSeg.cells[2]; if (pcSeg) { pcSeg.innerHTML=''; pcSeg.appendChild(buildProjectDropdownHalf(empId, date, segment, projIdSeg)); }
          const scSeg = trSeg.cells[3]; if (scSeg) { scSeg.innerHTML=''; scSeg.appendChild(buildScheduleDropdownHalf(empId, date, segment, schedIdHalf)); }
          trSeg.dataset.empId = empId;
          trSeg.dataset.date = date;
          trSeg.dataset.half = segment;
          const timesForHalf = [];
          if(segment==='AM'){
            if(amInActual) timesForHalf.push(amInActual);
            if(!hasBridge && amOutActual) timesForHalf.push(amOutActual);
            trSeg.dataset.clockIn1 = amInActual || '';
            trSeg.dataset.clockOut1 = (!hasBridge && amOutActual) ? amOutActual : '';
          } else if(segment==='PM'){
            if(!hasBridge && pmInActual) timesForHalf.push(pmInActual);
            if(pmOutActual) timesForHalf.push(pmOutActual);
            trSeg.dataset.clockIn2 = (!hasBridge && pmInActual) ? pmInActual : '';
            trSeg.dataset.clockOut2 = pmOutActual || '';
          } else {
            if(otInSeg) timesForHalf.push(otInSeg);
            if(otOutSeg) timesForHalf.push(otOutSeg);
            trSeg.dataset.otIn = otInSeg || '';
            trSeg.dataset.otOut = otOutSeg || '';
          }
          trSeg.dataset.times = JSON.stringify(timesForHalf);
          tbody.appendChild(trSeg);
          _rowCount++;
          const _regVal=parseFloat(regDecSeg)||0; const _otVal=parseFloat(otDecSeg)||0;
          _dtrTotalReg+=_regVal; _dtrTotalOt+=_otVal; _dtrEmpIds.add(empId);
        } else {
          merged.count++;
          if(segment==='AM'){ merged.regMins+=regMinsSeg; merged.amIn=amInActual; merged.amOut=hasBridge?middayStart:amOutActual; }
          else if(segment==='PM'){ merged.regMins+=regMinsSeg; merged.pmIn=hasBridge?middayEnd:pmInActual; merged.pmOut=pmOutActual; }
          else { merged.otMins+=otMinsSeg; merged.otIn=otInSeg; merged.otOut=otOutSeg; }
        }
      });
      if (merged.count) {
        const tr = document.createElement('tr');
        const projectName = (empProjId && storedProjects[empProjId]) ? storedProjects[empProjId].name : (emp && !emp.projectId ? '' : '');
        const scheduleName = storedSchedules[scheduleIdForEmp] ? storedSchedules[scheduleIdForEmp].name + (scheduleIdForEmp===defaultScheduleId ? ' (Default)' : '') : '';
        const cell = (v) => v ? '<td>' + __fmt12Clock(v) + '</td>' : '<td class="missing">-</td>';
        const regDec = minsToDecimal(merged.regMins);
        const otDec = minsToDecimal(merged.otMins);
        tr.innerHTML = '<td>'+empId+'</td><td>'+name+'</td><td>'+projectName+'</td><td>'+scheduleName+'</td><td>'+date+'</td>' +
          cell(merged.amIn) + cell(merged.amOut) + cell(merged.pmIn) + cell(merged.pmOut) +
          (merged.otIn ? '<td>'+__fmt12Clock(merged.otIn)+'</td>' : '<td class="missing">-</td>') +
          (merged.otOut ? '<td>'+__fmt12Clock(merged.otOut)+'</td>' : '<td class="missing">-</td>') +
          '<td>'+formatHours(regDec)+'</td><td>'+formatHours(otDec)+'</td><td>'+formatHours(minsToDecimal(merged.regMins + merged.otMins))+'</td>' +
          '<td><button type="button" class="btn-split" data-key="'+splitKey+'" onclick="splitRecord(this.dataset.key)">Split</button></td>';
        if(overridesSchedules[overrideKey] || overridesProjects[overrideKeyProj] !== undefined){ tr.style.backgroundColor='#fff3cd'; }
        try{
          if (typeof manualKeys !== 'undefined' && manualKeys.has(splitKey)) {
            const nmCell = tr.cells[1];
            if (nmCell && !nmCell.querySelector('.manual-indicator')) {
              const s = document.createElement('span');
              s.className='manual-indicator';
              s.title='Contains manual DTR';
              s.textContent='*';
              nmCell.appendChild(s);
            }
          }
        }catch(e){}
        const projCell = tr.cells[2]; if(projCell){ projCell.innerHTML=''; projCell.appendChild(buildProjectDropdown(empId, date, empProjId)); }
        const schedCell = tr.cells[3]; if(schedCell){ schedCell.innerHTML=''; schedCell.appendChild(buildScheduleDropdown(empId, date, scheduleIdForEmp)); }
        tbody.appendChild(tr);
        const _regVal=parseFloat(regDec)||0; const _otVal=parseFloat(otDec)||0; _dtrTotalReg+=_regVal; _dtrTotalOt+=_otVal; _dtrEmpIds.add(empId);
      }
      continue;
    }

    // --- End AM/PM/OT Split Logic ---

    const name = emp ? emp.name : '';
    const scheduleName = storedSchedules[scheduleIdForEmp] ? storedSchedules[scheduleIdForEmp].name + (scheduleIdForEmp===defaultScheduleId ? ' (Default)' : '') : '';
    const projectName = (empProjId && storedProjects[empProjId]) ? storedProjects[empProjId].name : (emp && !emp.projectId ? '' : '');

    const cell = (v) => v ? '<td>' + __fmt12Clock(v) + '</td>' : '<td class="missing">-</td>';
    const tr = document.createElement('tr');
    const __tot = ((parseFloat(totalRegularDecimal)||0)+(parseFloat(otDecimal)||0));
    tr.innerHTML =
      '<td>'+empId+'</td><td>'+name+'</td><td>'+projectName+'</td><td>'+scheduleName+'</td><td>'+date+'</td>' +
      cell(amInActual) + cell(amOutActual) + cell(pmInActual) + cell(pmOutActual) +
      (otInCalc ? '<td>' + __fmt12Clock(otInCalc) + '</td>' : '<td class=\"missing\">-</td>') +
      (otOutCalc ? '<td>' + __fmt12Clock(otOutCalc) + '</td>' : '<td class=\"missing\">-</td>') +
      '<td>'+formatHours(totalRegularDecimal)+'</td><td>'+formatHours(otDecimal)+'</td><td>'+formatHours(__tot)+'</td>' +
      // Use a named handler with a data-key attribute instead of an inline IIFE.
      '<td><button type="button" class="btn-split" data-key="' + empId + '___' + date + '" onclick="splitRecord(this.dataset.key)">Split</button></td>' +
      // Ensure Actions column always has a Delete button for unsplit rows
      '<td class="actions-cell"><button type="button" class="dtr-del-btn">Delete</button></td>';
    if(overridesSchedules[overrideKey] || overridesProjects[overrideKeyProj] !== undefined){
      tr.style.backgroundColor = '#fff3cd';
    }
    // Add a star indicator next to the Name if this row contains manual DTR entries
    try {
      if (typeof manualKeys !== 'undefined' && manualKeys.has(key)) {
        const nmCell = tr.cells[1];
        if (nmCell && !nmCell.querySelector('.manual-indicator')) {
          const s = document.createElement('span');
          s.className = 'manual-indicator';
          s.title = 'Contains manual DTR';
          s.textContent = '*';
          nmCell.appendChild(s);
        }
      }
    } catch(e){}
    const projCell = tr.cells[2];
    if(projCell){ projCell.innerHTML = ''; projCell.appendChild(buildProjectDropdown(empId, date, empProjId)); }
    const schedCell = tr.cells[3];
    if(schedCell){ schedCell.innerHTML = ''; schedCell.appendChild(buildScheduleDropdown(empId, date, scheduleIdForEmp)); }
    tr.dataset.empId = empId;
    tr.dataset.date = date;
    tr.dataset.clockIn1 = amInActual || '';
    tr.dataset.clockOut1 = amOutActual || '';
    tr.dataset.clockIn2 = pmInActual || '';
    tr.dataset.clockOut2 = pmOutActual || '';
    tr.dataset.otIn = otInCalc || '';
    tr.dataset.otOut = otOutCalc || '';
    try { tr.dataset.times = JSON.stringify(times); } catch(_) { tr.dataset.times = '[]'; }
    tbody.appendChild(tr);
    _rowCount++;
    // Accumulate totals for unsplit rows
    const _regVal = parseFloat(totalRegularDecimal) || 0;
    const _otVal  = parseFloat(otDecimal) || 0;
    _dtrTotalReg += _regVal;
    _dtrTotalOt  += _otVal;
    _dtrEmpIds.add(empId);
  }

  // --- DTR Summary ---
  // After building the table, update the summary using accumulated totals
  (function(){
    const summaryEl = document.getElementById('dtrSummary');
    if (!summaryEl) return;
    const rowCount = _rowCount;
    if (!rowCount) {
      summaryEl.textContent = '';
      return;
    }
    // Compute combined total hours (regular + OT)
    const _dtrTotalHours = _dtrTotalReg + _dtrTotalOt;
    summaryEl.textContent = `Grand Total Hours: ${formatHours(_dtrTotalHours)} | Regular Hours: ${formatHours(_dtrTotalReg)} | OT Hours: ${formatHours(_dtrTotalOt)} | Employees: ${_dtrEmpIds.size}`;
  })();

(function(){
  const tbl = document.getElementById('resultsTable');
  if (!tbl) return;
  // Create/clear tfoot
  let foot = tbl.querySelector('tfoot#resultsFoot');
  if (!foot) {
    foot = document.createElement('tfoot');
    foot.id = 'resultsFoot';
    tbl.appendChild(foot);
  }
  // Locate important columns by header text
  const ths = Array.from(tbl.querySelectorAll('thead th'));
  const norm = s => String((s||'')).trim().toLowerCase();
  const regIdx = ths.findIndex(th => (function(t){t=String(t||'').trim().toLowerCase();return t==='regular hrs'||t==='total regular hrs';})(th.textContent));
  const otIdx  = ths.findIndex(th => norm(th.textContent) === 'ot hrs');
  const totIdx = ths.findIndex(th => norm(th.textContent) === 'total hours');
  const nameIdx = ths.findIndex(th => norm(th.textContent) === 'name');
  const cols = ths.length;
  // Values: prefer internal running totals if present; otherwise sum from table
  function sumCol(idx){
    if (idx < 0) return 0;
    let s = 0;
    const rows = (tbl.tBodies && tbl.tBodies[0]) ? Array.from(tbl.tBodies[0].rows) : [];
    rows.forEach(tr => {
      const td = tr.cells[idx]; if (!td) return;
      const v = parseFloat(String(td.textContent||'').replace(/[^0-9.\-]/g,''));
      if (!isNaN(v)) s += v;
    });
    return s;
  }
  const reg = (typeof _dtrTotalReg === 'number') ? _dtrTotalReg : sumCol(regIdx);
  const ot  = (typeof _dtrTotalOt  === 'number') ? _dtrTotalOt  : sumCol(otIdx);
  const tot = reg + ot;
  const empCount = (typeof _dtrEmpIds === 'object' && _dtrEmpIds) ? _dtrEmpIds.size : (window.__lastEmpCount || 0);
  // Build row with cells aligned to columns
  const tr = document.createElement('tr');
  tr.className = 'totals-row';
  for (let i=0;i<cols;i++){
    const td = document.createElement('td');
    td.style.fontWeight = '700';
    td.style.background = '#fafafa';
    if (i===nameIdx) { td.textContent = 'Employees: ' + empCount; td.style.textAlign = 'left'; }
    else if (i===regIdx) { td.textContent = formatHours(reg); td.style.textAlign = 'right'; }
    else if (i===otIdx)  { td.textContent = formatHours(ot);  td.style.textAlign = 'right'; }
    else if (i===totIdx) { td.textContent = formatHours(tot); td.style.textAlign = 'right'; }
    else if (i===0)      { td.textContent = 'Totals:'; td.style.textAlign = 'left'; }
    else { td.textContent = ''; }
    const headTxt = norm(ths[i] && ths[i].textContent);
      if (headTxt === 'split' || headTxt === 'actions') { td.style.display='none'; td.style.border='0'; }
      tr.appendChild(td);
  }
  foot.innerHTML = '';
  foot.appendChild(tr);
  // Hide old textual summary
  const summaryEl = document.getElementById('dtrSummary');
  if (summaryEl){ summaryEl.textContent = ''; summaryEl.style.display = 'none'; }
})();
}

document.getElementById('addProjectBtn').addEventListener('click', ()=>{
  const name = document.getElementById('projectNameInput').value.trim();
  if(!name) return alert('Enter project name');
  const id = 'proj_' + Date.now();
  const companySelect = document.getElementById('projectCompanySelect');
  let company = companySelect ? companySelect.value : '';
  if (!COMPANY_OPTIONS.includes(company)) company = COMPANY_OPTIONS[0] || '';
  storedProjects[id] = { name, company };
  document.getElementById('projectNameInput').value='';
  if (companySelect) companySelect.value = COMPANY_OPTIONS[0] || '';
  saveProjectsToLS();
});
document.getElementById('clearProjectsBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all projects?')) return;
  storedProjects = {}; saveProjectsToLS();
});

async function initApp(){
  await hydrateSplitOverrides();
  ensureSchedules();
  renderScheduleSelector();
  renderScheduleEditor();
  renderEmployees();
  renderProjects();
  renderProjectFilterOptions();
  const savedFilter = localStorage.getItem(LS_FILTER_PROJECT);
  if(document.getElementById('filterProject') && savedFilter && [...document.getElementById('filterProject').options].some(o=>o.value===savedFilter)){
    document.getElementById('filterProject').value = savedFilter;
    currentProjectFilter = savedFilter;
  }
  renderResults();
}
initApp();
  </script>
  <script>
function computeHoursForDateRange(startDate, endDate) {
  const totalsReg = {};
  const totalsOT = {};
  Object.keys(storedEmployees).forEach(id => {
    totalsReg[id] = 0;
    totalsOT[id] = 0;
  });

  const keys = Object.keys(storedSchedules).length ? storedSchedules : {default: DEFAULT_SCHEDULE};
  const grouped = {};

  for (const r of storedRecords) {
    if (startDate && r.date < startDate) continue;
    if (endDate && r.date > endDate) continue;
    const emp = storedEmployees[r.empId];
    if (!emp) continue;
    const dayKey = r.date + '___' + r.empId;
    if (!grouped[dayKey]) grouped[dayKey] = [];
    grouped[dayKey].push(r.time);
  }

  const toMins = hm => { const [h,m] = hm.split(':').map(Number); return h*60+m; };
  const minsToDec = mins => mins / 60;

  for (const key in grouped) {
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId];
    if (!emp) continue;

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if (overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = keys[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);

    const times = [...new Set(grouped[key])].sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    const amInActual = pickEarliest({start: schedule.rng_am_in_start, end: schedule.rng_am_in_end});
    const amOutActual = pickLatest({start: schedule.rng_am_out_start, end: schedule.rng_am_out_end});
    const pmInActual = pickEarliest({start: schedule.rng_pm_in_start, end: schedule.rng_pm_in_end});
    const pmOutActual = pickLatest({start: schedule.rng_pm_out_start, end: schedule.rng_pm_out_end});

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otInActual = pickEarliest({start: schedule.rng_ot_in_start, end: schedule.rng_ot_in_end});
    const otOutActual = pickLatest({start: schedule.rng_ot_out_start, end: schedule.rng_ot_out_end});

    let regMins = 0;
    const grace = Number(schedule.sch_grace) || 0;
    const segMins = (inStr, outStr, segStartStr, segEndStr) => {
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const sS = toMins(segStartStr), sEraw = toMins(segEndStr);
      let sE = sEraw;
      if (sE <= sS && sS >= 12*60 && sE <= 12*60) sE += 12*60; // fix 06:00 vs 18:00 typo
      if (sE <= sS) return 0;
      if (inM <= sS + grace) inM = sS; // grace on start
      const endM = Math.min(outM, sE);
      return Math.max(0, endM - inM);
    };
    // Compute regular minutes.  Use Saturday-specific start/end ranges when
    // applicable; otherwise fall back to the normal AM/PM schedule ranges.
    if (__isSaturday) {
      // On Saturdays, clamp both AM and PM segments to the Saturday window
      regMins += segMins(amInActual, amOutActual, __satStart, __satEnd);
      regMins += segMins(pmInActual, pmOutActual, __satStart, __satEnd);
    } else {
      regMins += segMins(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
      regMins += segMins(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
    }
    // Bridge case: AM IN + PM OUT only.  If no regular minutes were
    // computed above, but we have an AM clock-in and a PM clock-out,
    // synthesize a noon break.  On Saturdays, treat the entire day as
    // a single continuous window between __satStart and __satEnd.
    if (regMins === 0 && amInActual && !amOutActual && !pmInActual && pmOutActual) {
      if (__isSaturday) {
        // Saturday bridging: compute the full span between the first
        // clock-in and final clock-out within the Saturday window.
        regMins = segMins(amInActual, pmOutActual, __satStart, __satEnd);
      } else {
        const synthAmOut = schedule.sch_am_end || "12:00";
        const synthPmIn  = schedule.sch_pm_start || "13:00";
        regMins =
          segMins(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
          segMins(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
      }
    }
    totalsReg[empId] += minsToDec(regMins);

    /*
     * Compute OT minutes for the current day/employee.  There are three
     * scenarios handled here:
     *
     *   1) Saturday: Any time worked after the scheduled Saturday end
     *      counts as OT, regardless of whether explicit OT punches were
     *      recorded.  Each in/out segment contributes separately to the
     *      OT total.  The resulting OT minutes are added to the employee's
     *      running total.
     *
     *   2) Nonâ€‘Saturday with explicit OT punches: When OT In and OT Out
     *      times are recorded and the OT In occurs after the normal
     *      scheduled end (pmOutRefMins), compute OT as the difference
     *      between OT Out and OT In.  This respects the configured OT
     *      ranges and leaves any early departures uncounted.
     *
     *   3) Nonâ€‘Saturday without explicit OT punches: When no valid OT
     *      punches exist but there is a single endâ€‘ofâ€‘day clockâ€‘out, treat
     *      any minutes worked after the scheduled end as OT.  This
     *      allows afterâ€‘hours work to be captured without requiring
     *      separate OT punches.  If multiple segments exist for the day
     *      (more than one in/out pair), only the final clockâ€‘out is
     *      considered for the fallback; intermediate segments are
     *      presumed to be normal work/breaks and do not contribute to OT.
     */
    let dayOTMins = 0;
    if (__isSaturday) {
      // Saturday override: sum minutes worked after the Saturday end for
      // every recorded segment.  Each segment contributes its own OT
      // minutes without regard to explicit OT punches.
      let extraOTMins = 0;
      const satEndM = toMins(__satEnd);
      for (let i = 0; i < times.length; i += 2) {
        const inStr  = times[i];
        const outStr = times[i+1];
        if (!outStr) continue;
        const inM  = toMins(inStr);
        const outM = toMins(outStr);
        const startM = Math.max(inM, satEndM);
        if (outM > startM) {
          extraOTMins += (outM - startM);
        }
      }
      dayOTMins = extraOTMins;
    } else {
      // Nonâ€‘Saturday: prefer explicit OT punches when they exist
      if (otInActual && otOutActual && toMins(otInActual) > pmOutRefMins) {
        let otInM = toMins(otInActual);
        let otOutM = toMins(otOutActual);
        if (otOutM < otInM) otOutM += 1440;
        dayOTMins = Math.max(0, otOutM - otInM);
      } else {
        // Fallback: no explicit OT punches.  Check the last clockâ€‘out and
        // count any minutes worked after the scheduled end as OT.  Only
        // the final out of the day is considered to avoid counting
        // intermediate segments twice.
        let lastOutM = null;
        for (let i = 0; i < times.length; i += 2) {
          const outStr = times[i+1];
          if (!outStr) continue;
          const outM = toMins(outStr);
          if (lastOutM === null || outM > lastOutM) lastOutM = outM;
        }
        if (lastOutM != null) {
          let adjLastOut = lastOutM;
          if (adjLastOut < pmOutRefMins) adjLastOut += 1440;
          if (adjLastOut > pmOutRefMins) {
            dayOTMins = adjLastOut - pmOutRefMins;
          }
        }
      }
    }
    totalsOT[empId] += minsToDec(dayOTMins);
  }
  return { totalsReg, totalsOT };
}
const dtrStartEl = document.getElementById('filterStart');
const dtrEndEl = document.getElementById('filterEnd');

function calculatePayrollFromRecords(){
  try { if (typeof renderResults === 'function') renderResults(); } catch(e){ console.warn('renderResults failed', e); }

  /*
   * Instead of deriving regular and OT hours from the filtered results table
   * (which can change when the DTR list is filtered), compute these values
   * directly from the underlying storedRecords for the selected date range.
   * This ensures that payroll calculations remain fixed regardless of
   * any filtering performed on the DTR tab.
   */
  try {
    // Determine the date range from the payroll period inputs.  Fall back
    // to the DTR filter inputs if the payroll period inputs are absent.
    const start = (typeof weekStartEl !== 'undefined' && weekStartEl && weekStartEl.value) ? weekStartEl.value : (dtrStartEl ? dtrStartEl.value : '');
    const end   = (typeof weekEndEl   !== 'undefined' && weekEndEl   && weekEndEl.value)   ? weekEndEl.value   : (dtrEndEl   ? dtrEndEl.value   : '');
    // Use the helper to compute perâ€‘employee hours across the full dataset.
    const { totalsReg, totalsOT } = computeHoursForDateRange(start, end);
    // Initialize regHours and otHours with computed totals
    regHours = Object.assign({}, totalsReg || {});
    otHours  = Object.assign({}, totalsOT  || {});
    // Guarantee every employee has a defined entry (default 0)
    Object.keys(storedEmployees || {}).forEach(id => {
      if (!regHours.hasOwnProperty(id)) regHours[id] = 0;
      if (!otHours.hasOwnProperty(id))  otHours[id]  = 0;
    });
    // Persist hours to localStorage
    try {
      localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
      localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
    } catch (err) {
      console.warn('LS save failed', err);
    }
  } catch (err) {
    console.warn('Error computing hours from full records', err);
  }
  // Ensure hourly rates are populated for all employees
  Object.keys(storedEmployees || {}).forEach(id => {
    if (!payrollRates[id] || payrollRates[id] === 0) {
      payrollRates[id] = storedEmployees[id]?.hourlyRate || 0;
    }
  });
  // Persist rates
  try {
    localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
  } catch (err) {}
  // Rebuild the payroll table with the newly computed hours
  try {
    if (typeof renderTable === 'function') renderTable();
  } catch (err) {
    console.warn('renderTable failed', err);
  }
}

  /**
   * Compute regular and overtime hours directly from the DTR results table.
   * This implementation scans the #resultsTable built by renderResults() and
   * aggregates the regular and OT hours by employee. By relying on the
   * existing DTR computation (which correctly handles split records and
   * schedule overrides), the payroll tab stays in sync with whatever
   * appears in the DTR tab, even when rounding and OT logic differs from
   * the generic computeHoursForDateRange() helper.  The selected payroll
   * period (weekStart/weekEnd) is mirrored onto the DTR date filters
   * before computing.  Project and name filters are temporarily
   * cleared so that all employees are included, and then restored.
   */
  function calculatePayrollFromResultsTable() {
    try {
      // Save current filter/search values
      const searchInput = document.getElementById('dtrSearchName');
      const filterSelect = document.getElementById('filterProject');
      const origSearch = searchInput ? searchInput.value : '';
      const origFilter = filterSelect ? filterSelect.value : '';
      // Save current DTR date inputs (so we can restore after aggregation)
      const dtrStartElTmp = document.getElementById('filterStart') || document.getElementById('dtrDateFrom');
      const dtrEndElTmp   = document.getElementById('filterEnd')   || document.getElementById('dtrDateTo');
      const origFrom = dtrStartElTmp ? dtrStartElTmp.value : '';
      const origTo   = dtrEndElTmp   ? dtrEndElTmp.value   : '';
      // Preserve original LS project filter to fully restore later
      let __savedLSFilter = null;
      try { __savedLSFilter = localStorage.getItem(LS_FILTER_PROJECT); } catch(_) {}
      // Clear name search and select all projects
      if (searchInput) searchInput.value = '';
      if (filterSelect) {
        filterSelect.value = 'all';
        // Persist the filter state so renderResults respects it
        if (typeof currentProjectFilter !== 'undefined') currentProjectFilter = 'all';
        // Do not permanently persist this temporary change; we will restore later.
        try { localStorage.setItem(LS_FILTER_PROJECT, 'all'); } catch (e) {}
      }
      // Sync the DTR date range with the payroll period.  Update the
      // DTR filter inputs if present (filterStart/filterEnd) and let
      // renderResults() handle the new range.  Some DTR pages use
      // dtrDateFrom/dtrDateTo instead.
      try {
        const dtrStart = document.getElementById('filterStart') || document.getElementById('dtrDateFrom');
        const dtrEnd   = document.getElementById('filterEnd')   || document.getElementById('dtrDateTo');
        if (weekStartEl && dtrStart) dtrStart.value = weekStartEl.value;
        if (weekEndEl   && dtrEnd)   dtrEnd.value   = weekEndEl.value;
      } catch (err) {}
      // Re-render the DTR results table with updated filters
      if (typeof renderResults === 'function') renderResults();
      // Aggregate hours from the rendered DTR table
      const rows = document.querySelectorAll('#resultsTable tbody tr');
      const regTotals = {};
      const otTotals = {};
      rows.forEach(row => {
        const cells = row.cells;
        if (!cells || cells.length < 13) return;
        const empId = cells[0].textContent.trim();
        // Column 11: total regular hours; column 12: OT hours
        const regVal = parseFloat(cells[11].textContent) || 0;
        const otVal  = parseFloat(cells[12].textContent) || 0;
        regTotals[empId] = (regTotals[empId] || 0) + regVal;
        otTotals[empId]  = (otTotals[empId]  || 0) + otVal;
      });
      // Restore original filters and search
      if (searchInput) searchInput.value = origSearch;
      if (filterSelect) {
        filterSelect.value = origFilter;
        if (typeof currentProjectFilter !== 'undefined') currentProjectFilter = origFilter;
        // Restore original LS filter value exactly as it was
        try {
          if (__savedLSFilter !== null && __savedLSFilter !== undefined) localStorage.setItem(LS_FILTER_PROJECT, __savedLSFilter);
          else localStorage.removeItem(LS_FILTER_PROJECT);
        } catch (e) {}
      }
      // Restore DTR date range values to what the user had prior to aggregation
      try {
        if (dtrStartElTmp) dtrStartElTmp.value = origFrom;
        if (dtrEndElTmp)   dtrEndElTmp.value   = origTo;
      } catch(_) {}
      // Ensure the visible DTR table reflects the restored date range.
      try {
        if (typeof window.applyDtrDateFilter === 'function') applyDtrDateFilter();
      } catch (_) {}
      // Re-render the DTR table with the original filter/search and date range
      if (typeof renderResults === 'function') renderResults();
      // Some pages patch renderResults to invoke the filter automatically,
      // but call it explicitly as a safeguard so the restored range is respected.
      try {
        if (typeof window.applyDtrDateFilter === 'function') applyDtrDateFilter();
      } catch (_) {}
      // Apply aggregated hours to regHours and otHours, rounding to two decimals
      regHours = {};
      otHours = {};
      Object.keys(regTotals).forEach(id => {
        regHours[id] = +(regTotals[id]).toFixed(2);
      });
      Object.keys(otTotals).forEach(id => {
        otHours[id] = +(otTotals[id]).toFixed(2);
      });
      // Ensure every employee has entries for reg and OT hours
      Object.keys(storedEmployees || {}).forEach(id => {
        if (!regHours.hasOwnProperty(id)) regHours[id] = 0;
        if (!otHours.hasOwnProperty(id))  otHours[id]  = 0;
      });
      // Persist the hours to localStorage
      try {
        localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
        localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
      } catch (err) {}
      // Rebuild the payroll table using the computed hours
      if (typeof renderTable === 'function') renderTable();
    } catch (err) {
      console.warn('calculatePayrollFromResultsTable failed', err);
    }
  }

weekStartEl.addEventListener('change', () => {
  if (dtrStartEl) dtrStartEl.value = weekStartEl.value;
  syncPeriodScopedData();
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch (e) {}
  if (typeof renderTable === 'function') renderTable();
  if (typeof renderAdjustmentsTable === 'function') renderAdjustmentsTable();
  calculateAll();
});
weekEndEl.addEventListener('change', () => {
  if (dtrEndEl) dtrEndEl.value = weekEndEl.value;
  syncPeriodScopedData();
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch (e) {}
  if (typeof renderTable === 'function') renderTable();
  if (typeof renderAdjustmentsTable === 'function') renderAdjustmentsTable();
  calculateAll();
});
if (dtrStartEl) {
  dtrStartEl.addEventListener('change', () => {
    weekStartEl.value = dtrStartEl.value;
    // When editing the DTR date range directly, recompute payroll hours from the DTR table
    syncPeriodScopedData();
    try {
      if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
      else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
    } catch (e) {}
  });
}
if (dtrEndEl) {
  dtrEndEl.addEventListener('change', () => {
    weekEndEl.value = dtrEndEl.value;
    // When editing the DTR date range directly, recompute payroll hours from the DTR table
    syncPeriodScopedData();
    try {
      if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
      else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
    } catch (e) {}
  });
}

tabs.tabPayroll.addEventListener('click', () => {
  if (dtrStartEl && !weekStartEl.value) weekStartEl.value = dtrStartEl.value;
  if (dtrEndEl && !weekEndEl.value) weekEndEl.value = dtrEndEl.value;
  // Compute hours based on the current DTR table rather than recomputing from raw records
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch (e) {}
});
function backupData() {
  const data = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    data[key] = localStorage.getItem(key);
  }
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'payroll_backup.json';
  a.click();
}

function restoreData(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      for (const key in data) {
        localStorage.setItem(key, data[key]);
      }
      alert('Data restored! Reloading...');
      location.reload();
    } catch (err) {
      alert('Invalid backup file.');
    }
  };
  reader.readAsText(file);
}
// Legacy backup UI removed - replaced by enhanced Backup & Restore controls.
  </script>
 
<!-- Manual DTR Modal -->
<div id="manualDtrModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:1000; align-items:center; justify-content:center;">
  <div style="background:white; padding:20px; border-radius:8px; width:320px; max-width:95vw;">
    <h3 style="margin-top:0;">Enter Manual DTR</h3>
    <label>Employee:<br/>
      <select id="manualEmpSelect" style="width:100%;"></select>
    </label><br/><br/>
    <label>Date:<br/>
      <input type="date" id="manualDate" style="width:100%;"/>
    </label><br/><br/>
    <label>Time:<br/>
      <input type="time" id="manualTime" style="width:100%;"/>
    </label><br/><br/>
    <div style="text-align:right; display:flex; gap:8px; justify-content:flex-end;">
      <button id="cancelManualDtr">Cancel</button>
      <button id="saveManualDtr" class="primary">Save</button>
    </div>
  </div>
</div>

<script>
(function(){
  function openManualModal(){
    const modal = document.getElementById('manualDtrModal');
    const empSelect = document.getElementById('manualEmpSelect');
    const manualDate = document.getElementById('manualDate');
    const manualTime = document.getElementById('manualTime');
    if(!modal || !empSelect) return;
    empSelect.innerHTML = '';
    try {
      Object.keys(storedEmployees || {}).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        const nm = (storedEmployees[id] && storedEmployees[id].name) ? storedEmployees[id].name : '';
        opt.textContent = nm ? `${nm} (${id})` : id;
        empSelect.appendChild(opt);
      });
    } catch(e) {}
    manualDate.value = '';
    manualTime.value = '';
    modal.style.display = 'flex';
  }
  function closeManualModal(){
    const modal = document.getElementById('manualDtrModal');
    if(modal) modal.style.display = 'none';
  }
  function wireManualDTR(){
    const btn = document.getElementById('manualDtrBtn');
    const cancelBtn = document.getElementById('cancelManualDtr');
    const saveBtn = document.getElementById('saveManualDtr');
    if(btn) btn.addEventListener('click', openManualModal);
    if(cancelBtn) cancelBtn.addEventListener('click', closeManualModal);
    if(saveBtn) saveBtn.addEventListener('click', function(){
      const empId = (document.getElementById('manualEmpSelect')||{}).value;
      const dateVal = (document.getElementById('manualDate')||{}).value;
      const timeVal = (document.getElementById('manualTime')||{}).value;
      if(!empId || !dateVal || !timeVal){
        alert('Please fill all fields.');
        return;
      }
      try {
        storedRecords.push({ empId: String(empId), date: dateVal, time: timeVal, manual: true });
        // Persist to localStorage
        localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
        // Persist to Supabase for crossâ€‘device sync
        if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
      } catch(e) { console.error('Saving manual DTR failed', e); }
      closeManualModal();
      if(typeof renderResults === 'function') renderResults();
    });
  }
  function ensureActionsHeader(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const theadRow = table.querySelector('thead tr');
    if(theadRow && !theadRow.querySelector('.actions-header')){
      const th = document.createElement('th');
      th.textContent = 'Actions';
      th.classList.add('actions-header');
      theadRow.appendChild(th);
    }
  }
  // Robust event delegation so Delete works even if rows insert buttons directly
  function setupDtrDeleteDelegation(){
    const table = document.getElementById('resultsTable');
    if (!table || table.__dtrDelBound) return;
    table.addEventListener('click', function(ev){
      const btn = ev.target && ev.target.closest ? ev.target.closest('.dtr-del-btn') : null;
      if (!btn) return;
      const tr = btn.closest('tr');
      if (!tr) return;
      const empIdCell = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
      const dateCell  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
      if(!empIdCell || !dateCell) return;
      const isSplitHalf = tr.dataset && tr.dataset.half;
      const confirmMsg = isSplitHalf
        ? `Delete this ${tr.dataset.half} DTR for ${empIdCell} on ${dateCell}?`
        : `Delete all DTR entries for ${empIdCell} on ${dateCell}?`;
      if(!confirm(confirmMsg)) return;
      try {
        if (isSplitHalf) {
          let timesForHalf = [];
          try { timesForHalf = JSON.parse(tr.dataset.times || '[]'); } catch(e) { timesForHalf = []; }
          timesForHalf.forEach(t => {
            for (let i = 0; i < storedRecords.length; i++) {
              const rec = storedRecords[i];
              if (String(rec.empId) === String(empIdCell) && rec.date === dateCell && rec.time === t) {
                storedRecords.splice(i, 1);
                break;
              }
            }
          });
          const splitKey = `${empIdCell}___${dateCell}`;
          if (splits && splits[splitKey]) {
            delete splits[splitKey];
            if (typeof saveSplits === 'function') saveSplits();
          }
        } else {
          for(let i = storedRecords.length - 1; i >= 0; i--){
            const rec = storedRecords[i];
            if(String(rec.empId) === String(empIdCell) && rec.date === dateCell){
              storedRecords.splice(i, 1);
            }
          }
        }
        localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
        try { if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords); } catch (e) {}
        renderResults();
      } catch(e){ console.error('DTR delete failed', e); }
    });
    table.__dtrDelBound = true;
  }
  function addDtrDeleteButtons(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    ensureActionsHeader();
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => {
      if(tr.querySelector('.dtr-del-btn')) return;
      const td = document.createElement('td');
      td.className = 'actions-cell';
      const btn = document.createElement('button');
      btn.textContent = 'Delete';
      btn.className = 'dtr-del-btn';
      btn.addEventListener('click', () => {
        // Get empId and date from row cells (empId at col 0, date at col 4)
        const empIdCell = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
        const dateCell  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
        if(!empIdCell || !dateCell) return;
        // Determine if this row is part of a split (AM/PM). If so, use the attached
        // metadata to remove only the specific half. Otherwise, remove all times.
        const isSplitHalf = tr.dataset && tr.dataset.half;
        const confirmMsg = isSplitHalf
          ? `Delete this ${tr.dataset.half} DTR for ${empIdCell} on ${dateCell}?`
          : `Delete all DTR entries for ${empIdCell} on ${dateCell}?`;
        if(!confirm(confirmMsg)) return;
        try {
          if (isSplitHalf) {
            // Parse times to remove for this half. The dataset.times stores an array
            // of the exact time strings (e.g., "08:00", "12:00") that belong to
            // this AM or PM half. Only records with matching empId, date and time
            // found in this array will be removed.
            let timesForHalf = [];
            try {
              timesForHalf = JSON.parse(tr.dataset.times || '[]');
            } catch(e) { timesForHalf = []; }
            // Remove only the specific occurrences of each time listed for this half.
            // We iterate through the array of times and, for each, remove one matching
            // record (empId/date/time). This avoids removing duplicates beyond the
            // count present in timesForHalf (e.g., AM out and OT may share the same
            // time value, so we only remove the intended PM/OT instances).
            timesForHalf.forEach(t => {
              for (let i = 0; i < storedRecords.length; i++) {
                const rec = storedRecords[i];
                if (String(rec.empId) === String(empIdCell) && rec.date === dateCell && rec.time === t) {
                  storedRecords.splice(i, 1);
                  break; // remove only one matching occurrence per time value
                }
              }
            });
            // After removing the half, unset the split flag for this emp/date so
            // the remaining records render as a single row. This mirrors the
            // behavior of the "Unsplit" button.
            const splitKey = `${empIdCell}___${dateCell}`;
            if (splits && splits[splitKey]) {
              delete splits[splitKey];
              if (typeof saveSplits === 'function') saveSplits();
            }
          } else {
            // Remove all records for this employee on this date
            for(let i = storedRecords.length - 1; i >= 0; i--){
              const rec = storedRecords[i];
              if(String(rec.empId) === String(empIdCell) && rec.date === dateCell){
                storedRecords.splice(i, 1);
              }
            }
          }
          // Persist updated records to localStorage
          localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
          // Also persist to Supabase so all devices reflect the deletion
          try {
            if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
          } catch (e) {
            console.warn('Failed to sync DTR deletion to Supabase', e);
          }
          renderResults();
        } catch(e){ console.error('DTR delete failed', e); }
      });
      td.appendChild(btn);
      tr.appendChild(td);
    });
  }
  function patchRenderResults(){
    if(typeof renderResults !== 'function') return false;
    const original = renderResults;
    window.renderResults = function(){
      const res = original.apply(this, arguments);
      try { addDtrDeleteButtons(); } catch(e){}
      try { setupDtrDeleteDelegation(); } catch(e){}
      // After rendering results, always check whether the selected payroll period is
      // locked and toggle editing accordingly. This ensures that dynamic
      // controls inserted by renderResults() respect the current lock state.
      try {
        if (typeof checkAndToggleEditState === 'function') {
          checkAndToggleEditState();
        }
      } catch(e) {}
      return res;
    };
    try { addDtrDeleteButtons(); } catch(e){}
    return true;
  }
  function init(){
    wireManualDTR();
    setupDtrDeleteDelegation();
    if(!patchRenderResults()){
      const iv = setInterval(() => {
        if(patchRenderResults()) clearInterval(iv);
      }, 200);
      setTimeout(() => clearInterval(iv), 6000);
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<script>
(function(){
  function q(id){ return document.getElementById(id); }
  function toMins(hm){ if(!hm) return null; var p=hm.split(':'), h=+p[0]||0, m=+p[1]||0; return h*60+m; }
  function minsToDec(mins){ return Math.round((mins/60)*100)/100; }
  function uniqSort(arr){ var seen={}, out=[]; for(var i=0;i<arr.length;i++){ var v=arr[i]; if(!seen[v]){ seen[v]=1; out.push(v);} } out.sort(); return out; }
  function max0(x){ return x>0?x:0; }

  // Extend tabs registry
  if (typeof tabs !== 'undefined' && tabs){
    tabs.tabProjectTotals   = tabs.tabProjectTotals || document.getElementById('tabProjectTotals');
    tabs.panelProjectTotals = tabs.panelProjectTotals || document.getElementById('panelProjectTotals');
    tabs.tabContributionSummary = tabs.tabContributionSummary || document.getElementById('tabContributionSummary');
    tabs.panelContributionSummary = tabs.panelContributionSummary || document.getElementById('panelContributionSummary');
  }

  // Wrap showTab to support projectTotals
  if (typeof showTab === 'function'){
    var _showTab = showTab;
    window.showTab = function(name){
      _showTab(name);
      if (name === 'projectTotals'){
        if (tabs.tabProjectTotals) tabs.tabProjectTotals.classList.add('active');
        if (tabs.panelProjectTotals) tabs.panelProjectTotals.classList.add('active');
        renderProjectTotals();
      }
      if (name === 'contribSummary'){
        if (tabs.tabContributionSummary) tabs.tabContributionSummary.classList.add('active');
        if (tabs.panelContributionSummary) tabs.panelContributionSummary.classList.add('active');
        try { if (typeof window.renderContributionSummary === 'function') window.renderContributionSummary(); } catch(e){}
      }
    };
  }

  // Click to open our tab
  if (tabs && tabs.tabProjectTotals){
    tabs.tabProjectTotals.addEventListener('click', function(){
      var nameEl = document.getElementById('dtrSearchName');
      var projectEl = document.getElementById('filterProject');
      var fromEl = document.getElementById('dtrDateFrom');
      var toEl = document.getElementById('dtrDateTo');
      window.__dtrFilterBackup = {
        name: nameEl ? nameEl.value : '',
        project: projectEl ? projectEl.value : 'all',
        from: fromEl ? fromEl.value : '',
        to: toEl ? toEl.value : ''
      };
      if (nameEl) nameEl.value = '';
      if (projectEl) projectEl.value = 'all';
      currentProjectFilter = 'all';
      try { localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter); } catch(e){}
      if (fromEl) fromEl.value = '';
      if (toEl) toEl.value = '';
      try {
        localStorage.removeItem(LS_FROM);
        localStorage.removeItem(LS_TO);
      } catch (e) {}
      try { renderResults(); } catch (e) {}
      showTab('projectTotals');
    });
  }

  const contribBtn = tabs && tabs.tabContributionSummary;
  if (contribBtn && !contribBtn.__wired){
    contribBtn.addEventListener('click', function(){
      showTab('contribSummary');
      try { if (typeof window.renderContributionSummary === 'function') window.renderContributionSummary(); } catch(e){}
    });
    contribBtn.__wired = true;
  }

  const contribSidebar = document.getElementById('old-tabContributionSummary');
  if (contribSidebar && !contribSidebar.__wired){
    contribSidebar.addEventListener('click', function(){
      showTab('contribSummary');
      try { if (typeof window.renderContributionSummary === 'function') window.renderContributionSummary(); } catch(e){}
    });
    contribSidebar.__wired = true;
  }

  // Re-render when date range changes while active
  ['weekStart','weekEnd'].forEach(function(id){
    var el = q(id);
    if (el) el.addEventListener('change', function(){
      if (tabs && tabs.tabProjectTotals && tabs.tabProjectTotals.classList.contains('active')) renderProjectTotals();
    });
  });

  
  // DTR name search live filter
  if (document.getElementById('dtrSearchName')) {
    document.getElementById('dtrSearchName').addEventListener('input', ()=>{
      renderResults();
    });
  }
// CSV export
  var dl = q('downloadProjectTotalsCSV');
  if (dl) dl.addEventListener('click', exportProjectTotalsCSV);

  // Core compute: honors date range + per-day project/schedule overrides + schedule windows, grace, OT windows
  function computeProjectTotals(startDate, endDate){
    var empMap = (typeof storedEmployees!=='undefined' && storedEmployees) || {};
    var schedMap = (typeof storedSchedules!=='undefined' && storedSchedules) || {};
    var defSchedId = (typeof defaultScheduleId!=='undefined' && defaultScheduleId) || null;
    var records = (typeof storedRecords!=='undefined' && storedRecords) || [];
    var projMap = (typeof storedProjects!=='undefined' && storedProjects) || {};
    var ovSched = (typeof overridesSchedules!=='undefined' && overridesSchedules) || {};
    var ovProj  = (typeof overridesProjects!=='undefined' && overridesProjects) || {};
    var DEF     = (typeof DEFAULT_SCHEDULE!=='undefined' && DEFAULT_SCHEDULE) || {};

    var dayGroups = {};
    for (var i=0;i<records.length;i++){
      var r = records[i];
      if (startDate && r.date < startDate) continue;
      if (endDate && r.date > endDate) continue;
      if (!empMap[r.empId]) continue;
      var key = r.date + '___' + r.empId;
      if (!dayGroups[key]) dayGroups[key] = [];
      dayGroups[key].push(r.time);
    }

    var totals = {}; // projectId => { name, reg, ot, total, employees:{} }
    var keys = Object.keys(dayGroups);
    for (var k=0;k<keys.length;k++){
      var key = keys[k];
      var parts = key.split('___');
      var date = parts[0], empId = parts[1];
      var emp = empMap[empId]; if (!emp) continue;

      var ovKey = empId + '___' + date;
      var projId = (ovProj.hasOwnProperty(ovKey) ? ovProj[ovKey] : (emp.projectId || '')) || '';
      var projName = (projId && projMap[projId]) ? (projMap[projId].name || projId) : '(No project)';

      var schedId = emp.scheduleId || defSchedId;
      if (ovSched[ovKey]) schedId = ovSched[ovKey];
      var S = (schedId && schedMap[schedId]) ? schedMap[schedId] : DEF;

      var times = uniqSort(dayGroups[key]);

      var win = {
        amIn:  {start:S.rng_am_in_start||'05:00', end:S.rng_am_in_end||'09:00'},
        amOut: {start:S.rng_am_out_start||'11:30', end:S.rng_am_out_end||'12:30'},
        pmIn:  {start:S.rng_pm_in_start||'12:30', end:S.rng_pm_in_end||'14:30'},
        pmOut: {start:S.rng_pm_out_start||'15:00', end:S.rng_pm_out_end||'20:00'},
        otIn:  {start:S.rng_ot_in_start||'19:00', end:S.rng_ot_in_end||'22:00'},
        otOut: {start:S.rng_ot_out_start||'19:00', end:S.rng_ot_out_end||'23:59'}
      };
      function pickEarliest(w){ for(var i2=0;i2<times.length;i2++){ var t=times[i2]; if(t>=w.start && t<=w.end) return t; } return null; }
      function pickLatest(w){ var last=null; for(var j2=0;j2<times.length;j2++){ var t2=times[j2]; if(t2>=w.start && t2<=w.end) last=t2; } return last; }

      var amIn  = pickEarliest(win.amIn);
      var amOut = pickLatest(win.amOut);
      var pmIn  = pickEarliest(win.pmIn);
      var pmOut = pickLatest(win.pmOut);

      var pmOutRefMins = pmOut ? toMins(pmOut) : toMins(S.sch_pm_end || '17:00');

      var otIn = null, otOut = null;
      for (var x=0;x<times.length;x++){
        var tt = times[x]; var m = toMins(tt);
        if (m>pmOutRefMins && m>=toMins(win.otIn.start) && m<=toMins(win.otIn.end)){ otIn = tt; break; }
      }
      for (var y=times.length-1;y>=0;y--){
        var tt2 = times[y]; var m2 = toMins(tt2);
        if (m2>pmOutRefMins && m2>=toMins(win.otOut.start) && m2<=toMins(win.otOut.end)){ otOut = tt2; if(!otIn || toMins(otOut)>=toMins(otIn)) break; }
      }

      var grace = Number(S.sch_grace)||0;
      var regMins = 0;

      if (amIn && pmOut && !amOut && !pmIn){
        var saS = toMins(S.sch_am_start||'08:00'), saE = toMins(S.sch_am_end||'12:00');
        var spS = toMins(S.sch_pm_start||'13:00'), spE = toMins(S.sch_pm_end||'17:00');
        var amInM = toMins(amIn), pmOutM = toMins(pmOut);
        var late = Math.max(0, amInM - saS);
        var under = Math.max(0, spE - pmOutM);
        var full = max0(saE-saS) + max0(spE-spS);
        regMins = (late <= grace) ? max0(full - under) : max0(full - late - under);
      } else {
        if (amIn && amOut){
          var inM = toMins(amIn), sS = toMins(S.sch_am_start||'08:00'), sE = toMins(S.sch_am_end||'12:00');
          if (inM <= sS + grace) inM = sS;
          var endM = Math.min(toMins(amOut), sE);
          if (endM > inM) regMins += (endM - inM);
        }
        if (pmIn && pmOut){
          var inM2 = toMins(pmIn), sS2 = toMins(S.sch_pm_start||'13:00'), sE2 = toMins(S.sch_pm_end||'17:00');
          if (inM2 <= sS2 + grace) inM2 = sS2;
          var endM2 = Math.min(toMins(pmOut), sE2);
          if (endM2 > inM2) regMins += (endM2 - inM2);
        }
      }

      var otMins = 0;
      if (otIn && otOut){
        var startClamp = Math.max(toMins(otIn), toMins(win.otIn.start));
        var endClamp   = Math.min(toMins(otOut), toMins(win.otOut.end));
        if (endClamp > startClamp) otMins = endClamp - startClamp;
      }

      var regDec = minsToDec(regMins);
      var otDec  = minsToDec(otMins);

      if (!totals[projId]) totals[projId] = { name: projName, reg: 0, ot: 0, total: 0, gross: 0, employees: {} };
      totals[projId].reg   = Math.round((totals[projId].reg + regDec)*100)/100;
      totals[projId].ot    = Math.round((totals[projId].ot  + otDec )*100)/100;
      totals[projId].total = Math.round((totals[projId].total + regDec + otDec)*100)/100;
      var rate = (emp && typeof emp.hourlyRate==='number') ? emp.hourlyRate : (+emp.hourlyRate||0);
      var otp = (document.getElementById('otMultiplier')&&parseFloat(document.getElementById('otMultiplier').value)) || 1.5;
      var grossInc = (regDec*rate) + (otDec*rate*otp);
      totals[projId].gross = Math.round((totals[projId].gross + grossInc)*100)/100;
      if (!totals[projId].employees[empId]) totals[projId].employees[empId] = { id: empId, name: (emp && emp.name) || '', reg: 0, ot: 0, total: 0, gross: 0, perDay: {} };
totals[projId].employees[empId].reg = Math.round((totals[projId].employees[empId].reg + regDec)*100)/100;
totals[projId].employees[empId].ot  = Math.round((totals[projId].employees[empId].ot  + otDec )*100)/100;
totals[projId].employees[empId].total = Math.round((totals[projId].employees[empId].total + regDec + otDec)*100)/100;
totals[projId].employees[empId].gross = Math.round((totals[projId].employees[empId].gross + grossInc)*100)/100;
// NEW: record per-day total hours (reg + OT) for this date
var _dTot = Math.round(((regDec + otDec))*100)/100;
if (!totals[projId].employees[empId].perDay) totals[projId].employees[empId].perDay = {};
totals[projId].employees[empId].perDay[date] = Math.round(((totals[projId].employees[empId].perDay[date]||0) + _dTot)*100)/100;
    }

    var rows = [];
    var pids = Object.keys(totals).sort(function(a,b){ var A=totals[a].name||''; var B=totals[b].name||''; return A.localeCompare(B); });
    for (var z=0; z<pids.length; z++){
      var pid = pids[z];
      var _emps = Object.values(totals[pid].employees || {}).sort(function(a,b){return (a.name||'').localeCompare(b.name||'') || String(a.id).localeCompare(String(b.id));});
rows.push({ projectId: pid, project: totals[pid].name, reg: totals[pid].reg, ot: totals[pid].ot, total: totals[pid].total, gross: totals[pid].gross, employees: Object.keys(totals[pid].employees).length , breakdown: _emps });
    }
    if (rows.length){
      var g = {reg:0, ot:0, total:0, gross:0, employees:0};
      for (var r=0;r<rows.length;r++){ g.reg+=rows[r].reg; g.ot+=rows[r].ot; g.total+=rows[r].total; g.gross+=rows[r].gross; g.employees+=rows[r].employees; }
      rows.push({ projectId: '__grand__', project: 'Grand Total', reg: Math.round(g.reg*100)/100, ot: Math.round(g.ot*100)/100, total: Math.round(g.total*100)/100, gross: Math.round(g.gross*100)/100, employees: g.employees });
    }
    return rows;
  }

  function renderProjectTotals(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var tbody = document.querySelector('#projectTotalsTable tbody'); if (!tbody) return;
    var data = computeProjectTotals(ws, we);
    tbody.innerHTML = '';
    if (!data.length){
      var tr = document.createElement('tr'); tr.innerHTML = '<td colspan="5" class="muted">No data for the selected date range.</td>'; tbody.appendChild(tr); return;
    }
    for (var i=0;i<data.length;i++){
      var row = data[i]; var tr = document.createElement('tr');
      tr.className = 'proj-row';
      if (row.projectId==='__grand__') tr.style.fontWeight = '700';
      tr.innerHTML = '<td>'+row.project+'</td>'
                   + '<td style="text-align:right">'+row.reg.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.ot.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.total.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+(row.gross!=null?row.gross.toFixed(2):'0.00')+'</td>'
                   + '<td style="text-align:right">'+row.employees+'</td>';
      tbody.appendChild(tr);
      if (row.projectId !== '__grand__' && Array.isArray(row.breakdown) && row.breakdown.length){
        tr.classList.add('has-breakdown');
        var dtr = document.createElement('tr');
        dtr.className = 'proj-emp-breakdown';
        var inner = '<td colspan="6" style="background:#f9fafb">'
  + '<div style="padding:8px 6px">'
  + '<strong>Employees (per-day hours):</strong>';

function dateRangeList(s, e){
  var out = []; if(!s || !e) return out;
  var d = new Date(s); var end = new Date(e);
  while (d <= end){ out.push(new Date(d)); d.setDate(d.getDate()+1); }
  return out;
}
var days = dateRangeList(ws, we);

inner += '<table style="width:100%;margin-top:6px;border-collapse:collapse">'
      + '<thead><tr>'
      + '<th style="text-align:left">ID</th>'
      + '<th style="text-align:left">Name</th>';
for (var di=0; di<days.length; di++){
  var dt = days[di];
  var label = (dt.getMonth()+1)+'/'+dt.getDate();
  inner += '<th style="text-align:right">'+label+'</th>';
}
inner += '<th style="text-align:right">Total Hrs</th>';
inner += '<th style="text-align:right">Total Amount</th>';
inner += '</tr></thead><tbody>';

for (var k=0;k<row.breakdown.length;k++){
  var e = row.breakdown[k];
  var totalRow = Number(e.total||0);
  var grossRow = Number(e.gross||0);
  inner += '<tr>'
        + '<td>'+(e.id ?? '')+'</td>'
        + '<td>'+(e.name ?? '')+'</td>';
  var perDay = (e.perDay||{});
  for (var di=0; di<days.length; di++){
    var dkey = days[di].toISOString().slice(0,10);
    var val = Number(perDay[dkey]||0).toFixed(2);
    inner += '<td style="text-align:right">'+val+'</td>';
  }
  inner += '<td style="text-align:right">'+ totalRow.toFixed(2) +'</td>';
  inner += '<td style="text-align:right">'+ grossRow.toFixed(2) +'</td>';
  inner += '</tr>';
}
inner += '</tbody></table></div></td>';
        dtr.innerHTML = inner;
        dtr.style.display = 'none';
        tbody.appendChild(dtr);
        // toggle and show detailed modal when a project row is clicked. The modal
        // provides a comprehensive breakdown and grand totals for the selected project.
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (function(detailRow, rowObj){
          return function(){
            // Show modal with project breakdown if available
            if (typeof showProjectReport === 'function') showProjectReport(rowObj);
            // Toggle the inline breakdown row visibility for quick reference
            if (detailRow) {
              detailRow.style.display = (detailRow.style.display === 'none' ? 'table-row' : 'none');
            }
          };
        })(dtr, row));
      }

    }
  }

  function exportProjectTotalsCSV(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var data = computeProjectTotals(ws, we);
    var rows = [['Week Start','Week End','Project','Regular Hours','OT Hours','Total Hours','Gross Amount','Employees']];
    for (var i=0;i<data.length;i++){ var r = data[i]; rows.push([ws,we,r.project,r.reg.toFixed(2),r.ot.toFixed(2),r.total.toFixed(2),(r.gross!=null?r.gross.toFixed(2):'0.00'),r.employees]); }
var csv = rows.map(function(r){
      return r.map(function(s){
        s = String(s==null?'':s);
        var needs = (s.indexOf('"')>=0) || (s.indexOf(',')>=0) || (s.indexOf('\n')>=0);
        if (needs) s = '"' + s.split('"').join('""') + '"';
        return s;
      }).join(',');
    }).join('\n');
    var blob = new Blob([csv], {type:'text/csv'}); var url = URL.createObjectURL(blob);
    var a = document.createElement('a'); a.href=url; a.download='project_totals.csv'; document.body.appendChild(a); a.click(); a.remove();
  }
})();
</script>


<script>
// --- Employees: small UX helpers ---
document.addEventListener('DOMContentLoaded', () => {
  const panel = document.querySelector('#panelEmployees');
  if (!panel) return;
  const form = panel.querySelector('form');
  if (!form) return;

  // Wrap form in a card if not already
  if (!form.closest('.form-card')) {
    const card = document.createElement('div');
    card.className = 'form-card';
    form.parentNode.insertBefore(card, form);
    card.appendChild(form);
  }

  // Enter-to-submit (except textarea)
  form.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
      e.preventDefault();
      const submit = form.querySelector('button[type="submit"], input[type="submit"]');
      if (submit) submit.click();
    }
  });

  // Auto-mark dangerous buttons
  form.querySelectorAll('button, input[type="button"]').forEach(el => {
    const text = (el.textContent || el.value || '').toLowerCase();
    if (/(clear|reset|delete|remove)/.test(text)) el.classList.add('btn-danger');
    if (/(save|add|submit|create)/.test(text)) el.classList.add('btn-primary');
  });

  // Group actions into a row if not already
  const actions = Array.from(form.querySelectorAll('button, input[type="submit"], input[type="button"]'));
  if (actions.length) {
    let bar = form.querySelector('.form-actions');
    if (!bar) {
      bar = document.createElement('div');
      bar.className = 'form-actions';
      // move trailing buttons into actions
      actions.forEach(btn => {
        if (!btn.closest('.form-actions')) bar.appendChild(btn);
      });
      form.appendChild(bar);
    }
  }
});
</script>

<script>
// Clean print for per-project sheet (modal) with strong grid lines
function printProjectReportClean(){
  try{
    var box = document.getElementById('projectReportContent');
    if (!box) return;
    var css = '<style>'+
      'html,body{margin:0;padding:10px;font-family:Arial,Helvetica,sans-serif}'+
      '*{-webkit-print-color-adjust:exact;print-color-adjust:exact}'+
      'h3{margin:0 0 8px 0}'+
      'table{width:100%;border-collapse:collapse;font-size:12px}'+
      'table,th,td{border:0.6pt solid #000 !important}'+
      'th,td{padding:4px 6px;vertical-align:middle}'+
      'th{background:#f1f5f9;text-align:left}'+
      '@media print{@page{margin:10mm}}'+
      '</style>';
    var html = '<!doctype html><html><head><meta charset="utf-8">'+css+'</head><body>'+ box.innerHTML + '</body></html>';
    var w = window.open('', '', 'width=1024,height=768');
    if (!w) return;
    w.document.open(); w.document.write(html); try{ w.document.title=' '; }catch(e){}; w.document.close();
    w.focus(); setTimeout(function(){ try{ safePrint(w); }catch(e){} }, 0);
  }catch(e){ console.warn('Project report clean print failed', e); }
}
document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('printProjectTotalsBtn');
  if (btn) btn.addEventListener('click', function(e){ e.preventDefault(); printProjectReportClean(); });
});
</script>

<!-- Enhanced DTR Print -->
<script>
// Enhanced DTR print: clones the results table, removes 'Split' or 'Actions' columns,
// replaces dropdowns with selected text, and shows date range/project filter.
(function(){
  function printDTR(){
    try{
      var table = document.getElementById('resultsTable');
      if(!table){ alert('No DTR records to print.'); return; }
      // Capture selected texts from original selects
      var selectedTexts = [];
      var origSelects = table.querySelectorAll('select');
      origSelects.forEach(function(osel){
        var txt = '';
        try{
          var idx = osel.selectedIndex;
          if(idx >= 0 && osel.options[idx]){
            var opt = osel.options[idx];
            txt = (opt.textContent || opt.innerText || opt.value || '');
          }
        }catch(e){}
        selectedTexts.push(txt);
      });
      // Clone table
      var clone = table.cloneNode(true);
      // Remove columns labelled 'Split', 'Actions', or 'Editor'
      var dropIdx = [];
      clone.querySelectorAll('thead th').forEach(function(th, idx){
        var t = (th.textContent || '').trim().toLowerCase();
        if(t === 'split' || t === 'actions' || t === 'editor') dropIdx.push(idx);
      });
      if(dropIdx.length){
        // Remove header cells
        var headers = clone.querySelectorAll('thead th');
        headers.forEach(function(th, idx){
          if(dropIdx.indexOf(idx) !== -1){ th.remove(); }
        });
        // Remove columns from each row (in reverse order)
        clone.querySelectorAll('tbody tr').forEach(function(tr){
          var cells = tr.children;
          var sorted = dropIdx.slice().sort(function(a,b){ return b - a; });
          sorted.forEach(function(i){
            if(cells[i]) cells[i].remove();
          });
        });

        // Remove columns from any footer rows as well
        var footRows = clone.querySelectorAll('tfoot tr');
        footRows.forEach(function(fr){
          var fc = fr.children;
          var sortedF = dropIdx.slice().sort(function(a,b){ return b - a; });
          sortedF.forEach(function(i){
            if(fc[i]) fc[i].remove();
          });
        });
      }
      // Replace select dropdowns in the clone with the captured text values
      var cloneSelects = clone.querySelectorAll('select');
      cloneSelects.forEach(function(csel, i){
        var td = csel.closest('td');
        if(td){ td.textContent = selectedTexts[i] || ''; }
      });
      // Remove any buttons inside the cloned table (e.g., split buttons)
      clone.querySelectorAll('button').forEach(function(btn){ btn.remove(); });
      
      function fmtLong(d){
        if(!d) return '';
        try{
          var dt = new Date(d);
          if (isNaN(dt)) return d;
          return dt.toLocaleDateString(undefined,{ year:'numeric', month:'long', day:'numeric' });
        }catch(e){ return d; }
      }
      function fmtLongWithDay(d){
        if(!d) return '';
        try{
          var dt = new Date(d);
          if (isNaN(dt)) return d;
          var dateStr = dt.toLocaleDateString(undefined,{ year:'numeric', month:'long', day:'numeric' });
          var dayStr  = dt.toLocaleDateString(undefined,{ weekday:'long' });
          return dateStr + ' (' + String(dayStr||'').toUpperCase() + ')';
        }catch(e){ return d; }
      }
// Build header for print

      function fmtLong(d){
        if(!d) return '';
        try{
          var dt = new Date(d);
          if (isNaN(dt)) return d;
          var opts = { year: 'numeric', month: 'long', day: 'numeric' };
          return dt.toLocaleDateString(undefined, opts);
        }catch(e){ return d; }
      }

      var start = (document.getElementById('weekStart') || {}).value || '';
      var end = (document.getElementById('weekEnd') || {}).value || '';
      // Prefer the small Date range filter in the DTR tab
      var smallFrom = (document.getElementById('dtrDateRangeFrom')||{}).value || (document.getElementById('dtrDateFrom')||{}).value || '';
      var smallTo   = (document.getElementById('dtrDateRangeTo')||{}).value   || (document.getElementById('dtrDateTo')||{}).value   || '';
      var s = smallFrom || start;
      var e = smallTo   || end;
      var hdr = 'Daily Time Records';
      if(start || end){
        var sL = fmtLong(start), eL = fmtLong(end);
        hdr += ' - ' + (sL || '') + (eL ? (' - ' + eL) : '');
      }
      // Determine project filter text
      var filterSel = document.getElementById('filterProject');
      var filterTxt = '';
      if(filterSel){
        try{
          if(!filterSel.value || filterSel.value === 'all'){
            filterTxt = 'All Projects';
          } else {
            var o = filterSel.options[filterSel.selectedIndex];
            filterTxt = (o && (o.textContent || o.innerText || '')) || '';
          }
        }catch(e){}
      }
      var w = window.open('', '_blank', 'width=900,height=700');
      w.document.write('<!DOCTYPE html><html><head><meta charset="utf-8"><title>DTR Records</title>');
      w.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;margin:16px} h2{margin:0 0 6px} .muted{color:#555;margin:0 0 12px;font-size:12px} table{width:100%;border-collapse:collapse} th,td{border:1px solid #000;padding:6px;text-align:center;font-size:12px} th{background:#eee}#payrollTable th, #payrollTable td { white-space: nowrap; }#payrollTable th:nth-child(3), #payrollTable td:nth-child(3) { width:110px; min-width:110px; }#payrollTable th:nth-child(4), #payrollTable td:nth-child(4) { width:120px; min-width:120px; }#payrollTable th:nth-child(5), #payrollTable td:nth-child(5) { width:120px; min-width:120px; }</style>');
      w.document.write('</head><body>');
      w.document.write('<h2>' + hdr.replace(/</g, '&lt;') + '</h2>');
      if(filterTxt){
        var __pf = (filterTxt||'').replace(/</g,'&lt;');
      w.document.write('<div style="margin:2px 0;font-weight:700;font-size:14px;">Project filter: ' + __pf + '</div>');
      // Date Filter line (shows weekday)
      (function(){
        var df = (document.getElementById('dtrDateRangeFrom')||{}).value || (document.getElementById('dtrDateFrom')||{}).value || '';
        var dt = (document.getElementById('dtrDateRangeTo')||{}).value   || (document.getElementById('dtrDateTo')||{}).value   || '';
        var s = df || start, e = dt || end;
        if (s && e && s !== e){
          w.document.write('<div style="margin:2px 0;font-weight:700;font-size:14px;">Date filter: ' + fmtLongWithDay(s) + ' - ' + fmtLongWithDay(e) + '</div>');
        } else if (s){
          w.document.write('<div style="margin:2px 0;font-weight:700;font-size:14px;">Date filter: ' + fmtLongWithDay(s) + '</div>');
        }
      })();
      }
      // Include summary of totals (Grand Total Hours, Regular, OT, Employees) if available
      try {
        var summaryEl = document.getElementById('dtrSummary');
        if(summaryEl){
          var summaryText = (summaryEl.textContent || '').trim();
          if(summaryText){
            // Escape angle brackets
            var safeSummary = summaryText.replace(/</g,'&lt;');
            w.document.write('<div style="margin:8px 0;font-weight:bold;font-size:12px;">'+ safeSummary +'</div>');
          }
        }
      } catch(e) {}
      w.document.write(clone.outerHTML);
      w.document.write('</body></html>');
      w.document.close();
      w.focus();
      safePrint(w);
    }catch(err){
      alert('Unable to print DTR: ' + err);
    }
  }
  window.printDTR = printDTR;
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id === 'printDtrBtn'){
      printDTR();
    }
  });
})();
</script>



<script>
(function(){
  function _parse(n){ var x=parseFloat(String(n||'').replace(/[^0-9.\-]/g,'')); return isNaN(x)?0:x; }
  function _val(el){
    try {
      if (!el) return '';
      if (typeof el.value !== 'undefined') return el.value;
      return el.textContent || '';
    } catch(e){ return ''; }
  }
  function _fmt(n){
    var v = Math.round((n||0)*100)/100;
    try { return v.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }
    catch(e){ return v.toFixed(2); }
  }

  // === Payroll ===
  function updatePayrollGrandTotals(){
    var tb = document.querySelector('#payrollTable tbody');
    var foot = document.querySelector('#payrollTotalsFoot');
    if (!tb || !foot) return;
      var t = {regHrs:0, otHrs:0, adjHrs:0, totalHrs:0, rate:0, regPay:0, otPay:0, adjAmt:0, bantay:0, grossPay:0, pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, totalDed:0, netPay:0};
    var div = Number(divisor) || 1;
    tb.querySelectorAll('tr').forEach(function(tr){
      t.regHrs   += _parse(_val(tr.querySelector('.regHrs')));
      t.otHrs    += _parse(_val(tr.querySelector('.otHrs')));
      // Sum adjustment hours from the adjHrs cell (displayed as text)
      t.adjHrs   += _parse(tr.querySelector('.adjHrs')?.textContent);
      // Sum total hours from the computed totalHrs cell
      t.totalHrs += _parse(tr.querySelector('.totalHrs')?.textContent);
      t.rate     += _parse(_val(tr.querySelector('.rate')));
        t.regPay   += _parse(tr.querySelector('.regPay')?.textContent);
        t.otPay    += _parse(tr.querySelector('.otPay')?.textContent);
        t.adjAmt   += _parse(tr.querySelector('.adjAmt')?.textContent);
        // Sum Bantay allowance from the bantay input
        t.bantay  += _parse(_val(tr.querySelector('.bantay')));
        t.grossPay += _parse(tr.querySelector('.grossPay')?.textContent);
        const dedPagibig = readRowDeductionDataset(tr, 'pagibig', 'effective');
        const dedPhilhealth = readRowDeductionDataset(tr, 'philhealth', 'effective');
        const dedSss = readRowDeductionDataset(tr, 'sss', 'effective');
        const dedLoanSss = readRowDeductionDataset(tr, 'loanSSS', 'effective');
        const dedLoanPi = readRowDeductionDataset(tr, 'loanPI', 'effective');
        const dedVale = readRowDeductionDataset(tr, 'vale', 'effective');
        const dedValeWed = readRowDeductionDataset(tr, 'valeWed', 'effective');
        const dedTotal = readRowDeductionDataset(tr, 'total', 'effective');
        t.pagibig  += dedPagibig != null ? _parse(dedPagibig) : _parse(tr.querySelector('.pagibig')?.textContent);
        t.philhealth += dedPhilhealth != null ? _parse(dedPhilhealth) : _parse(tr.querySelector('.philhealth')?.textContent);
        t.sss      += dedSss != null ? _parse(dedSss) : _parse(tr.querySelector('.sss')?.textContent);
        t.loanSSS  += dedLoanSss != null ? _parse(dedLoanSss) : (_parse(_val(tr.querySelector('.loanSSS'))) / div);
        t.loanPI   += dedLoanPi != null ? _parse(dedLoanPi) : (_parse(_val(tr.querySelector('.loanPI'))) / div);
        t.vale     += dedVale != null ? _parse(dedVale) : _parse(_val(tr.querySelector('.vale')));
        t.valeWed  += dedValeWed != null ? _parse(dedValeWed) : _parse(_val(tr.querySelector('.valeWed')));
        t.totalDed += dedTotal != null ? _parse(dedTotal) : _parse(tr.querySelector('.totalDed')?.textContent);
        t.netPay   += _parse(tr.querySelector('.netPay')?.textContent);
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updatePayrollGrandTotals = updatePayrollGrandTotals;

  // === Deductions ===
  function updateDeductionsGrandTotals(){
    var tb = document.querySelector('#deductionsTable tbody');
    var foot = document.querySelector('#deductionsTable_foot');
    if (!tb || !foot) return;
    var totalsRaw = {pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, adjustments:0, valeWed:0};
    tb.querySelectorAll('tr').forEach(function(tr){
      DEDUCTION_COLUMN_KEYS.forEach(function(key){
        if (key === 'total') return;
        var cell = tr.querySelector('[data-col="'+key+'"]');
        if (!cell) return;
        var rawAttr = cell.getAttribute('data-raw');
        var rawVal = rawAttr != null ? parseFloat(rawAttr) : NaN;
        if (!Number.isFinite(rawVal)) {
          rawVal = _parse(cell.textContent || '');
        }
        if (!Number.isFinite(rawVal)) rawVal = 0;
        totalsRaw[key] += rawVal;
      });
    });
    totalsRaw.total = roundToCents(Object.keys(totalsRaw).reduce(function(sum, key){ return sum + (key === 'total' ? 0 : totalsRaw[key]); }, 0));
    var effectiveTotals = computeEffectiveDeductionValues(totalsRaw);
    Object.keys(effectiveTotals).forEach(function(key){
      var cell = foot.querySelector('[data-col="'+key+'"]');
      if (!cell) return;
      var raw = roundToCents(totalsRaw[key] || 0);
      var effective = roundToCents(effectiveTotals[key] || 0);
      updateDeductionCellDisplay(cell, raw, effective, isDeductionColumnIncluded(key));
    });
  }
  window.updateDeductionsGrandTotals = updateDeductionsGrandTotals;

  // Debounced scheduling for totals to avoid thrash during bulk updates
  window.__suspendTotals = window.__suspendTotals || false;
  window.__needsTotalsUpdate = window.__needsTotalsUpdate || false;
  (function(){
    var rafId = null;
    function flush(){
      rafId = null;
      if (window.__suspendTotals) { window.__needsTotalsUpdate = true; return; }
      try { updatePayrollGrandTotals(); } catch(e){}
      try { updateDeductionsGrandTotals(); } catch(e){}
    }
    window.scheduleTotals = function(){
      if (window.__suspendTotals) { window.__needsTotalsUpdate = true; return; }
      if (rafId) return;
      var raf = window.requestAnimationFrame || function(cb){ return setTimeout(cb, 16); };
      rafId = raf(flush);
    };
  })();

  // Run on load
  function _initTotals(){
    try{ (window.scheduleTotals||updatePayrollGrandTotals)(); }catch(e){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', _initTotals);
  } else { _initTotals(); }

  // Observe table changes to keep totals fresh (debounced)
  try {
    var mo = new MutationObserver(function(){ try{ (window.scheduleTotals||updatePayrollGrandTotals)(); }catch(e){} });
    var ptb = document.querySelector('#payrollTable tbody');
    var dtb = document.querySelector('#deductionsTable tbody');
    if (ptb) mo.observe(ptb, {childList:true, subtree:true, characterData:true});
    if (dtb) mo.observe(dtb, {childList:true, subtree:true, characterData:true});
  } catch(e){}

  // Also recalc on payroll inputs (debounced)
  document.addEventListener('input', function(ev){
    if ((ev.target && ev.target.closest('#payrollTable'))) {
      try{ (window.scheduleTotals||updatePayrollGrandTotals)(); }catch(e){}
    }
  });

  // Patch into existing functions if present
  try {
    var _calcAll = window.calculateAll;
    if (typeof _calcAll === 'function'){
      window.calculateAll = function(){
        var prev = window.__suspendTotals;
        window.__suspendTotals = true;
        try { var r = _calcAll.apply(this, arguments); return r; }
        finally {
          window.__suspendTotals = prev;
          var need = window.__needsTotalsUpdate; window.__needsTotalsUpdate = false;
          try { (window.scheduleTotals||updatePayrollGrandTotals)(); if (need) (window.scheduleTotals||updateDeductionsGrandTotals)(); } catch(e){}
        }
      };
    }
  } catch(e){}
  try {
    var _renderDed = window.renderDeductionsTable;
    if (typeof _renderDed === 'function'){
      window.renderDeductionsTable = function(){ var r = _renderDed.apply(this, arguments); try{ (window.scheduleTotals||updateDeductionsGrandTotals)(); }catch(e){}; return r; };
    }
  } catch(e){}

})();</script>

<script>
// Custom Payroll CSV export: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay)
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // If "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = parts[0].trim();
      var rhs = (parts.slice(1).join(',')).trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Else assume "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){
    var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,''));
    return isNaN(n) ? 0 : n;
  }
  function csvEscape(val){
    var s = String(val==null?'':val);
    var needs = /[",\n]/.test(s);
    if (needs) s = '"' + s.replace(/"/g,'""') + '"';
    return s;
  }
  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};
    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || '';
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });
    // Serialize
    return rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n');
  }
  function attachPayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    btn.addEventListener('click', function(){
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(e){
        console.error('Payroll CSV export failed', e);
        alert('Failed to build Payroll CSV.');
      }
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachPayrollCsv);
  } else {
    attachPayrollCsv();
  }
})();
</script>

<script>
// === Override Payroll CSV to: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay) ===
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // Handle "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = (parts.shift()||'').trim();
      var rhs = (parts.join(',')||'').trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Default "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){ var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,'')); return isNaN(n)?0:n; }
  function csvEscape(val){ var s=String(val==null?'':val); return /[",\n]/.test(s) ? ('"'+s.replace(/"/g,'""')+'"') : s; }

  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};

    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || ''; // Employee Account Number
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });

    return rows.map(r => r.map(csvEscape).join(',')).join('\n');
  }

  function overridePayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    // Remove all existing listeners by cloning
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(err){
        console.error('Payroll CSV export failed', err);
        alert('Failed to build Payroll CSV.');
      }
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', overridePayrollCsv);
  } else {
    overridePayrollCsv();
  }
})();
</script>


</div>






<link rel="preconnect" href="https://cdn.jsdelivr.net"/>


</div>




<script>
document.addEventListener('DOMContentLoaded', function(){
  var nodes = document.querySelectorAll('#cloudSyncCard');
  for (var i=1;i<nodes.length;i++){ nodes[i].remove(); }
});
</script>

<!-- Payslip Button functionality -->
<script>
// Add click listener for payslip buttons on payroll table
document.addEventListener('click', function(e) {
  var target = e.target;
  if (!target || !target.classList || !target.classList.contains('payslipBtn')) return;

  var row = target.closest('tr');
  if (!row) return;

  function cellText(sel){
    var el = row.querySelector(sel);
    return (el ? (el.textContent || el.value || '') : '').toString().trim();
  }
  function inputVal(sel){
    var el = row.querySelector(sel);
    var v = el ? (el.value || el.textContent || '') : '';
    return v.toString().trim();
  }
  function perLoanShare(raw){
    if (typeof window !== 'undefined' && typeof window.computeLoanPerPeriodShare === 'function'){
      return window.computeLoanPerPeriodShare(raw);
    }
    var amt = parseFloat((raw == null ? '' : raw).toString().replace(/,/g,''));
    if (!isFinite(amt)) amt = 0;
    var key = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
    var div = 0;
    if (typeof window !== 'undefined' && typeof window.divisor !== 'undefined'){
      var winDiv = Number(window.divisor);
      if (!isNaN(winDiv) && winDiv > 0) div = winDiv;
    }
    if (!(div > 0)){
      try {
        if (typeof localStorage !== 'undefined' && localStorage){
          var stored = localStorage.getItem(key);
          if (stored != null){
            var parsed = parseInt(stored, 10);
            if (!isNaN(parsed) && parsed > 0) div = parsed;
          }
        }
      } catch(err){}
    }
    if (!(div > 0)) div = 1;
    var per = amt / div;
    if (!isFinite(per)) per = 0;
    return per.toFixed(2);
  }

  function datasetNumber(key){
    if (!row || !row.dataset) return 0;
    var raw = row.dataset[key];
    if (raw == null || raw === '') return 0;
    var num = parseFloat(raw.toString().replace(/,/g,''));
    return isNaN(num) ? 0 : num;
  }

  function parseAmount(val){
    var num = parseFloat((val == null ? '' : val).toString().replace(/,/g,''));
    return isNaN(num) ? 0 : num;
  }

  var rowData = (typeof window.collectPayslipRowData === 'function') ? window.collectPayslipRowData(row) : null;

  var id = (rowData && rowData.id) || ((row.cells[0] && row.cells[0].textContent) ? row.cells[0].textContent.trim() : '');
  var name = (rowData && rowData.name) || ((row.cells[1] && row.cells[1].textContent) ? row.cells[1].textContent.trim() : '');

  var rate      = rowData ? rowData.rate : inputVal('.rate');
  var regHrs    = rowData ? rowData.regHours : inputVal('.regHrs');
  var otHrs     = rowData ? rowData.otHours : inputVal('.otHrs');
  var regPay    = rowData ? rowData.regPay : cellText('.regPay');
  var otPay     = rowData ? rowData.otPay : cellText('.otPay');
  var gross     = rowData ? rowData.gross : cellText('.grossPay');
  var pagibig   = rowData ? rowData.pagibig : cellText('.pagibig');
  var philhealth= rowData ? rowData.philhealth : cellText('.philhealth');
  var sss       = rowData ? rowData.sss : cellText('.sss');
  var sssLoan   = rowData ? rowData.sssLoan : perLoanShare(inputVal('.loanSSS'));
  var piLoan    = rowData ? rowData.piLoan : perLoanShare(inputVal('.loanPI'));
  var valeAmt   = rowData ? rowData.vale : inputVal('.vale');
  var wedValeAmt= rowData ? rowData.valeWed : inputVal('.valeWed');
  var bantayVal = rowData ? rowData.bantay : inputVal('.bantay');
  var adjPositiveNum = rowData ? Number(rowData.adjustmentPositive || 0) : datasetNumber('adjustmentPositive');
  var adjDeductNum = rowData ? Number(rowData.adjustmentDeductions || 0) : datasetNumber('adjustmentDeduction');
  if (!(adjPositiveNum > 0)){
    adjPositiveNum = parseAmount(cellText('.adjAmt'));
  }
  if (!(adjDeductNum > 0)){
    try {
      var rawAdjMap = 0;
      if (typeof adjustments !== 'undefined' && adjustments && id){
        rawAdjMap = Number(adjustments[id] ?? 0) || 0;
      } else if (typeof window !== 'undefined' && window.adjustments && id){
        rawAdjMap = Number(window.adjustments[id] ?? 0) || 0;
      }
      var splitAdj = splitAdjustmentValue(rawAdjMap);
      if (!(adjPositiveNum > 0)) adjPositiveNum = splitAdj.positive;
      adjDeductNum = splitAdj.deduction;
    } catch (err) { adjDeductNum = adjDeductNum || 0; }
  }
  var adjAmt    = adjPositiveNum > 0 ? adjPositiveNum.toFixed(2) : '0.00';
  var adjDeductionStr = adjDeductNum > 0 ? adjDeductNum.toFixed(2) : '0.00';
  var totalDed  = rowData ? rowData.totalDeductions : cellText('.totalDed');
  var net       = rowData ? rowData.net : cellText('.netPay');
  var bantayRowLegacy = parseAmount(bantayVal) !== 0 ? `<tr><td>Bantay</td><td class="right">${bantayVal}</td></tr>` : '';
  var adjPositiveRowLegacy = adjPositiveNum > 0 ? `<tr><td>Adjustments</td><td class="right">${adjAmt}</td></tr>` : '';

  var ws = (document.getElementById('weekStart') || {}).value || '';
  var we = (document.getElementById('weekEnd')   || {}).value || '';
  var periodText = (typeof window.formatPayslipPeriod === 'function') ? window.formatPayslipPeriod(ws, we) : ((ws && we) ? (ws + ' to ' + we) : (ws || we || ''));
  var html = '';

  if (rowData && typeof window.buildCompactPayslip === 'function'){
    var slip = window.buildCompactPayslip(rowData, periodText);
    if (slip){
      var stylesSingle = window.PAYSLIP_PRINT_STYLES || '';
      if (!stylesSingle){
        stylesSingle = `@page { size: letter portrait; margin: 0.25in; }
html, body { width: 8.5in; height: 11in; margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:0 0.1in;}
.payslip-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:0.03in;}
.payslip-grid.single{grid-template-columns:repeat(1,1fr);max-width:3in;margin:0 auto;}
.payslip{box-sizing:border-box;padding:0.06in;border:1px solid #475569;height:2.6in;overflow:hidden;border-radius:3px;background:#fff;box-shadow:0 0 0 1px rgba(15,23,42,0.2);}
table{border-collapse:collapse;width:100%;font-size:8.5px;}
th,td{border:1px solid #e2e8f0;padding:1px;text-align:left;}
th{background:#f1f5f9;}
.page-break{page-break-after:always;break-after:page;}
h3{margin:0 0 3px 0;font-size:10px;}
.payslip .meta{margin:0 0 2px 0;font-size:8px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}`;
      }
      html = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>Payslip - ${name}</title><style>${stylesSingle}</style></head><body><div class="payslip-grid single">${slip}</div></body></html>`;
    }
  }

  if (!html){
    var legacyPeriod = (ws && we) ? `Period: ${ws} - ${we}` : '';
    html = `<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Payslip - ${name}</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;padding:20px;line-height:1.4;}
  h2{margin:0 0 12px 0;text-align:center;}
  .meta{margin:0 0 16px 0;text-align:center;color:#475569;}
  table{border-collapse:collapse;width:100%;font-size:14px;}
  th,td{border:1px solid #e2e8f0;padding:8px;text-align:left;}
  th{background:#f1f5f9;}
  .right{text-align:right;}
  .section{margin-top:16px;}
</style>
</head><body>
  <h2>Payslip</h2>
  <div class="meta">${legacyPeriod}</div>

  <table>
    <tr><th>Employee ID</th><td>${id}</td><th>Name</th><td>${name}</td></tr>
    <tr><th>Rate</th><td class="right">${rate}</td><th>Reg Hrs</th><td class="right">${regHrs}</td></tr>
    <tr><th>OT Hrs</th><td class="right">${otHrs}</td><th>Gross Pay</th><td class="right">${gross}</td></tr>
  </table>

  <div class="section">
    <table>
      <tr><th colspan="2">Earnings</th></tr>
      <tr><td>Regular Pay</td><td class="right">${regPay}</td></tr>
      <tr><td>OT Pay</td><td class="right">${otPay}</td></tr>
      ${bantayRowLegacy}
      ${adjPositiveRowLegacy}
    </table>
  </div>

  <div class="section">
    <table>
      <tr><th colspan="2">Deductions</th></tr>
      <tr><td>Pag-IBIG</td><td class="right">${pagibig}</td></tr>
      <tr><td>PhilHealth</td><td class="right">${philhealth}</td></tr>
      <tr><td>SSS</td><td class="right">${sss}</td></tr>
      <tr><td>SSS Loan</td><td class="right">${sssLoan}</td></tr>
      <tr><td>Pag-IBIG Loan</td><td class="right">${piLoan}</td></tr>
      <tr><td>Account</td><td class="right">${valeAmt}</td></tr>
      <tr><td>Wednesday Vale</td><td class="right">${wedValeAmt}</td></tr>
      <tr><td>Adjustments</td><td class="right">${adjDeductionStr}</td></tr>
      <tr><th>Total Deductions</th><th class="right">${totalDed}</th></tr>
    </table>
  </div>

  <div class="section">
    <table>
      <tr><th>Net Pay</th><th class="right">${net}</th></tr>
    </table>
  </div>
</body></html>`;
  }

  var w = window.open('', '', 'width=800,height=900');
  if (!w) return;
  w.document.open();
  w.document.write(html);
  try{ w.document.title = ' '; }catch(e){}
  w.document.close();
  w.focus();
  try{ safePrint(w); }catch(e){}
});
var LS_FROM = (typeof window.LS_FROM !== 'undefined') ? window.LS_FROM : 'dtrDateFrom';
var LS_TO   = (typeof window.LS_TO   !== 'undefined') ? window.LS_TO   : 'dtrDateTo';
function getEl(id){ return document.getElementById(id); }
function loadSaved(){
    const from = localStorage.getItem(LS_FROM) || '';
    const to   = localStorage.getItem(LS_TO) || '';
    const f = getEl('dtrDateFrom'), t = getEl('dtrDateTo');
    if (f) f.value = from;
    if (t) t.value = to;
  }

  function withinRange(dateStr, from, to){
    if (!dateStr) return false;
    const s = dateStr.trim();
    if (!s) return false;
    if (from && s < from) return false;
    if (to   && s > to)   return false;
    return true;
  }

  function applyDtrDateFilter(){
    const f = getEl('dtrDateFrom')?.value || '';
    const t = getEl('dtrDateTo')?.value || '';
    try { localStorage.setItem(LS_FROM, f); } catch(e){}
    try { localStorage.setItem(LS_TO, t); } catch(e){}

    const tbody = document.querySelector('#resultsTable tbody');
    if (!tbody) return;
    const hasRange = !!(f || t);

    Array.from(tbody.rows).forEach(tr=>{
      // Adjust the index below if your Date column index is different.
      // Assuming the "Date" column is 4 (0-based), change as necessary.
      const dateStr = (tr.cells[4]?.textContent || '').trim();
      const show = !hasRange || withinRange(dateStr, f, t);
      tr.style.display = show ? '' : 'none';
    });

    // After applying the date filter, recompute the DTR summary to reflect only visible rows.
    const summaryEl = document.getElementById('dtrSummary');
    if (summaryEl) {
      // Initialize totals
      let regSum = 0;
      let otSum  = 0;
      const empSet = new Set();
      const rows = Array.from(tbody.rows);
      let visibleCount = 0;
      rows.forEach(row => {
        // Skip rows hidden by the date filter
        if (row.style.display === 'none') return;
        visibleCount++;
        // Extract values from the Total Regular Hrs and OT Hrs columns (indices 11 and 12)
        const regVal = parseFloat((row.cells[11]?.textContent || '').trim()) || 0;
        const otVal  = parseFloat((row.cells[12]?.textContent || '').trim()) || 0;
        regSum += regVal;
        otSum  += otVal;
        // Collect unique employee IDs (column 0)
        const idCell = (row.cells[0]?.textContent || '').trim();
        if (idCell) empSet.add(idCell);
      });
      // If there are visible rows, update the summary text; otherwise clear it
      if (visibleCount > 0) {
        const totalHours = regSum + otSum;
        summaryEl.textContent = `Grand Total Hours: ${formatHours(totalHours)} | Regular Hours: ${formatHours(regSum)} | OT Hours: ${formatHours(otSum)} | Employees: ${empSet.size}`;
      } else {
        summaryEl.textContent = '';
      }
    }
  }

  function hookUI(){
    const f = getEl('dtrDateFrom');
    const t = getEl('dtrDateTo');
    const c = getEl('dtrDateClear');
    if (f) f.addEventListener('change', applyDtrDateFilter);
    if (t) t.addEventListener('change', applyDtrDateFilter);
    if (c) c.addEventListener('click', ()=>{
      if (f) f.value = '';
      if (t) t.value = '';
      try { localStorage.removeItem(LS_FROM); } catch(e){}
      try { localStorage.removeItem(LS_TO); } catch(e){}
      applyDtrDateFilter();
    });
  }

  function monkeyPatchRender(){
    const orig = window.renderResults;
    if (typeof orig === 'function') {
      window.renderResults = function(){
        orig.apply(this, arguments);
        applyDtrDateFilter();
      };
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    // Inject controls right before #resultsTable if not already in DOM.
    if (!document.getElementById('dtrDateControls')){
      const table = document.getElementById('resultsTable');
      if (table && table.parentNode){
        const wrapper = document.createElement('div');
      wrapper.innerHTML = '<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;"><label style="display:flex;align-items:center;gap:.35rem;"><span>Date:</span><input id="dtrDateFrom" type="date" /></label><span>-</span><label><input id="dtrDateTo" type="date" /></label><button id="dtrDateClear" type="button">Clear</button></div>';
        table.parentNode.insertBefore(wrapper.firstElementChild, table);
      }
    }
    loadSaved();
    hookUI();
    monkeyPatchRender();
    applyDtrDateFilter();
  });

</script>


<script>
// === Thousands Separator Formatting for Amounts (Payroll & Deductions) ===
(function(){
  // Format helper: 1,234.56
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function formatAllNumbers(){
    var sels = '#payrollTable td.num, #payrollTable tfoot td.num, #deductionsTable td.num';
    document.querySelectorAll(sels).forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g, '').trim();
      var num = parseFloat(raw);
      if (isFinite(num)) {
        if (num === 0) {
          td.textContent = '-';
        } else {
          td.textContent = fmt(num);
        }
      }
    });
    // Inputs: hide zeros by showing blank
    document.querySelectorAll('#payrollTable input.regHrs, #payrollTable input.otHrs, #payrollTable input.rate').forEach(function(inp){
      var v = parseFloat(inp.value);
      if (!isNaN(v) && v === 0) { inp.value = ''; }
    });
  }

  // Patch calculateAll to apply formatting after calculations
  function patchCalculateAll(){
    try{
      var orig = window.calculateAll;
      if (typeof orig === 'function'){
        window.calculateAll = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      } else {
        // If not defined yet, retry after load
        document.addEventListener('DOMContentLoaded', function(){
          if (typeof window.calculateAll === 'function'){
            patchCalculateAll(); 
            try { formatAllNumbers(); } catch(e){}
          }
        });
      }
    }catch(e){}
  }

  // Also patch renderDeductionsTable so that a manual refresh there also formats
  function patchRenderDeductions(){
    try{
      var orig = window.renderDeductionsTable;
      if (typeof orig === 'function'){
        window.renderDeductionsTable = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      }
    }catch(e){}
  }

  // Initial hooks
  patchCalculateAll();
  patchRenderDeductions();
  document.addEventListener('DOMContentLoaded', function(){
    try { formatAllNumbers(); } catch(e){}
  });
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function patch(fnName){
    var orig=window[fnName];
    if(typeof orig==='function'){
      window[fnName]=function(){
        var out=orig.apply(this,arguments);
        try{formatAllNumbers();}catch(e){}
        return out;
      }
    }
  }
  patch('calculateAll');
  patch('renderDeductionsTable');
  patch('renderReportTable');
  patch('renderTable');
  document.addEventListener('DOMContentLoaded', function(){ try{ window.formatAllNumbers && formatAllNumbers(); }catch(e){} });
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function formatCells(cells){
    cells.forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (raw === '') return;
      var num = parseFloat(raw);
      if (isFinite(num)) td.textContent = fmt(num);
    });
  }
  function formatProjectTotals(){
    var tbl = document.getElementById('projectTotalsTable');
    if(!tbl) return;
    var tds = tbl.querySelectorAll('tbody td, tfoot td');
    formatCells(Array.from(tds));
  }
  function formatProjectModal(){
    var box = document.getElementById('projectReportContent');
    if (!box) return;
    var tds = box.querySelectorAll('td');
    formatCells(Array.from(tds));
  }
  // Patch showProjectReport to format modal numbers
  (function(){
    var orig = window.showProjectReport;
    if (typeof orig === 'function'){
      window.showProjectReport = function(){
        var out = orig.apply(this, arguments);
        try { formatProjectModal(); } catch(e){}
        return out;
      };
    }
  })();
  // Observe changes on the project totals table and auto-format
  document.addEventListener('DOMContentLoaded', function(){
    formatProjectTotals();
    var tbl = document.getElementById('projectTotalsTable');
    if (tbl && window.MutationObserver){
      var timer = null;
      var mo = new MutationObserver(function(){
        clearTimeout(timer);
        timer = setTimeout(formatProjectTotals, 50);
      });
      mo.observe(tbl.tBodies[0] || tbl, { childList: true, subtree: true });
    }
  });
})();
</script>


<script>
(function(){
  const ACTIVE_KEY = 'payroll_active';            // object map: key=start_end, value={startDate,endDate,rows,totals}
  const CURRENT_KEY = 'current_active_week';      // string: "YYYY-MM-DD__YYYY-MM-DD"
  const HIST_KEY = 'payroll_hist';                // existing history (may contain locked snapshots)

  function loadJSON(k, d){ try{ return JSON.parse(localStorage.getItem(k)||''); }catch(_){ return d; } }
  function saveJSON(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){} }

  function toKey(s,e){ return (s||'') + '__' + (e||''); }
  function fromKey(k){ const [s,e] = String(k||'').split('__'); return {start:s,end:e}; }

  // Build active store from locked history (one-time, if active is empty)
  function maybeSeedActiveFromHistory(){
    let active = loadJSON(ACTIVE_KEY, null);
    if (active && typeof active === 'object' && Object.keys(active).length) return;
    const hist = loadJSON(HIST_KEY, []);
    active = {};
    (hist||[]).forEach(s=>{
      if (s && s.startDate && s.endDate /* && s.locked */){
        const key = toKey(s.startDate, s.endDate);
        active[key] = { startDate:s.startDate, endDate:s.endDate, rows:s.rows||[], totals:s.totals||{} };
      }
    });
    saveJSON(ACTIVE_KEY, active);
  }

  function upsertActiveWeek(snap){
    if(!snap || !snap.startDate || !snap.endDate) return;
    const key = toKey(snap.startDate, snap.endDate);
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    active[key] = { startDate:snap.startDate, endDate:snap.endDate, rows:snap.rows||[], totals:snap.totals||{} };
    saveJSON(ACTIVE_KEY, active);
    localStorage.setItem(CURRENT_KEY, key);
  }

  function listActiveWeeks(){
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    return Object.keys(active).sort().map(k=>({ key:k, ...fromKey(k) }));
  }

  function fillActiveWeekSelects(){
    const weeks = listActiveWeeks();
    const current = localStorage.getItem(CURRENT_KEY) || (weeks[weeks.length-1]?.key || '');
    if (current) localStorage.setItem(CURRENT_KEY, current);
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      const prev = sel.value;
      sel.innerHTML='';
      weeks.forEach(w=>{
        const opt = document.createElement('option');
        opt.value = w.key;
        opt.textContent = `${w.start} - ${w.end}`;
        sel.appendChild(opt);
      });
      if (weeks.length){
        sel.value = current && weeks.some(w=>w.key===current) ? current : weeks[weeks.length-1].key;
      }
    });
  }

  function applyActiveWeekToGlobals(){
    const key = localStorage.getItem(CURRENT_KEY) || '';
    const {start,end} = fromKey(key);
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    if (ws) ws.value = start || ws.value;
    if (we) we.value = end || we.value;
  }

  function reRenderAll(){
    try{ applyActiveWeekToGlobals(); }catch(_){}
    try{ window.renderResults && renderResults(); }catch(_){}
    try{ window.calculateAll && calculateAll(); }catch(_){}
    try{ window.renderReportTable && renderReportTable(); }catch(_){}
    // If you have totals/project tables:
    try{ window.formatAllNumbers && formatAllNumbers(); }catch(_){}
  }

  // Wire the dropdown "Apply" buttons
  function hookActiveWeekUI(){
    document.querySelectorAll('.refreshActiveWeek').forEach(btn=>{
      if (btn._wired) return;
      btn._wired = true;
      btn.addEventListener('click', ()=>{
        const sel = btn.parentElement && btn.parentElement.querySelector('.activeWeekSelect');
        if (!sel) return;
        localStorage.setItem(CURRENT_KEY, sel.value || '');
        applyActiveWeekToGlobals();
        reRenderAll();
      });
    });
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      if (sel._wired) return;
      sel._wired = true;
      sel.addEventListener('change', ()=>{
        localStorage.setItem(CURRENT_KEY, sel.value || '');
      });
    });
  }

  // Patch Generate to upsert into ACTIVE store (while keeping existing behavior)
  function patchGenerateToActive(){
    const btn = document.getElementById('dashGenerate');
    if (!btn || btn._activeWired) return;
    btn._activeWired = true;
    btn.addEventListener('click', async ()=>{
      // Wait a moment for existing listeners to compute tables, then capture
      setTimeout(()=>{
        try{
          const ws = document.getElementById('weekStart')?.value;
          const we = document.getElementById('weekEnd')?.value;
          if (!ws || !we) return;
          // Try to collect current payroll rows/totals from existing functions
          if (typeof window.buildSnapshot === 'function'){
            (async ()=>{
              const snap = await window.buildSnapshot(ws, we);
              if (snap) upsertActiveWeek(snap);
              fillActiveWeekSelects();
            })();
          } else {
            // Fallback: minimal capture from payroll table if present
            const rows = [];
            document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
              rows.push(Array.from(tr.cells).map(td=>td.textContent.trim()));
            });
            upsertActiveWeek({ startDate: ws, endDate: we, rows, totals:{} });
            fillActiveWeekSelects();
          }
        }catch(_){}
      }, 300);
    }, { capture: true });
  }

  // On load
  document.addEventListener('DOMContentLoaded', ()=>{
    maybeSeedActiveFromHistory();
    fillActiveWeekSelects();
    hookActiveWeekUI();
    patchGenerateToActive();

    // Optional: visually disable weekStart/weekEnd outside dashboard
    try {
      const onHashChange = () => {
        const ws = document.getElementById('weekStart');
        const we = document.getElementById('weekEnd');
        // Simple heuristic: if dashboard panel isn't visible, keep inputs disabled
        const dash = document.getElementById('panelDashboard');
        const dashActive = dash && (dash.classList.contains('active') || dash.style.display !== 'none');
        const disabled = !dashActive;
        if (ws) ws.disabled = disabled;
        if (we) we.disabled = disabled;
      };
      onHashChange();
      window.addEventListener('hashchange', onHashChange);
    } catch(_){}
  });
})();
</script>

<!-- Script to manage global Active Payroll dropdown and New Period functionality -->
<script>
(function(){
  const PAYROLL_HIST_KEY = 'payroll_hist';
  const LS_ACTIVE_INDEX = 'payroll_active_index';
  let reloadTimer = null;

  function scheduleFullReload(){
    if (reloadTimer !== null) return;
    try {
      reloadTimer = window.setTimeout(() => {
        try {
          window.location.reload();
        } catch (_) {}
      }, 120);
    } catch (_) {
      try { window.location.reload(); } catch (_) {}
    }
  }

  function loadHistory() {
    try {
      const hist = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
      return Array.isArray(hist) ? hist : [];
    } catch (e) {
      return [];
    }
  }

  function saveActiveIndex(idx) {
    localStorage.setItem(LS_ACTIVE_INDEX, String(idx));
  }

  function getActiveIndex() {
    const v = localStorage.getItem(LS_ACTIVE_INDEX);
    const n = v == null ? -1 : parseInt(v, 10);
    return Number.isFinite(n) ? n : -1;
  }

  function toIsoDate(s){
  if(!s) return '';
  if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) {
    const mm = String(parseInt(m[1],10)).padStart(2,'0');
    const dd = String(parseInt(m[2],10)).padStart(2,'0');
    return m[3] + '-' + mm + '-' + dd;
  }
  const d = new Date(s);
  if (!isNaN(d)) return d.toISOString().slice(0,10);
  return '';
}
function updateWeekInputs(snap) {
  const isLockedSnapshot = !!(snap && snap.locked);
  const startISO = toIsoDate(snap && snap.startDate);
  const endISO   = toIsoDate(snap && snap.endDate);

  // If the user already set a custom DTR date filter (persisted in localStorage),
  // do not override it when switching payroll periods or when realtime sync
  // repopulates the dropdowns. Previously, every populateDropdowns() call
  // would reset the DTR inputs back to the payroll period range, causing the
  // dates to "jump" while the user was editing them.
  let hasCustomDtrFilter = false;
  try {
    hasCustomDtrFilter = !!(localStorage.getItem(LS_FROM) || localStorage.getItem(LS_TO));
  } catch (_) {}

  const ws = document.getElementById('weekStart');
  const we = document.getElementById('weekEnd');
  if (ws) ws.value = startISO || '';
  if (we) we.value = endISO   || '';

  // Notify listeners that the week range changed (so Reports can re-render)
  try {
    if (ws) ws.dispatchEvent(new Event('change', { bubbles: true }));
    if (we) we.dispatchEvent(new Event('change', { bubbles: true }));
  } catch (_) {}

  // DTR date inputs (type=date) must receive ISO; then fire change events
  if (!hasCustomDtrFilter) {
    try {
      const df = document.getElementById('dtrDateFrom');
      const dt = document.getElementById('dtrDateTo');
      if (df) { df.value = startISO || ''; df.dispatchEvent(new Event('change', { bubbles: true })); }
      if (dt) { dt.value = endISO   || ''; dt.dispatchEvent(new Event('change', { bubbles: true })); }
    } catch (_) {}
  }

  // Refresh DTR list immediately
  try { if (typeof renderResults === 'function') { renderResults(); } } catch (e) {}

  // Recalculate payroll if available, deriving hours from the DTR results table
  if (!isLockedSnapshot) {
    try {
      if (typeof calculatePayrollFromResultsTable === 'function') { calculatePayrollFromResultsTable(); }
      else if (typeof calculatePayrollFromRecords === 'function') { calculatePayrollFromRecords(); }
    } catch (e) {}
  } else {
    try { setSnapshotOverride(snap); } catch (e) {}
    try { applySnapshotToPayrollTable(snap); } catch (e) {}
  }

  // After updating the week range, toggle editing state based on whether the
  // selected period is locked. Without this, switching between periods would
  // incorrectly leave the UI enabled for locked snapshots or vice versa.
  try {
    if (typeof checkAndToggleEditState === 'function') {
      checkAndToggleEditState();
    }
  } catch (e) {}
}

  function populateDropdowns() {
    // Prefer the global payrollHistory array if available, else fall back to localStorage
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const history = Array.isArray(hist) ? hist : [];
    // Build list of items with their original indices; sort newest first by start date
    const items = history.map((s, i) => Object.assign({ i: i }, s)).sort((a, b) => {
      return (b.startDate || '').localeCompare(a.startDate || '');
    });
    const globalSelect = document.getElementById('activePayrollSelect');
    const panelSelects = Array.from(document.querySelectorAll('.activeWeekSelect'));
    function fill(selectEl) {
      if (!selectEl) return;
      // Rebuild the dropdown options
      selectEl.innerHTML = '';
      items.forEach(item => {
        const opt = document.createElement('option');
        opt.value = String(item.i);
        const rangeText = typeof window.formatDateRange === 'function'
          ? window.formatDateRange(item.startDate, item.endDate)
          : [item.startDate || '', item.endDate || ''].filter(Boolean).join(' - ');
        const lockedSuffix = item.locked ? ' (locked)' : '';
        const label = `${rangeText}${lockedSuffix}`.trim();
        opt.textContent = label;
        selectEl.appendChild(opt);
      });
      // Always set the selected value to the saved active index so all selectors stay in sync
      const saved = String(getActiveIndex());
      if ([...selectEl.options].some(o => o.value === saved)) {
        selectEl.value = saved;
      } else if (selectEl.options.length) {
        selectEl.selectedIndex = 0;
      }
    }
    fill(globalSelect);
    panelSelects.forEach(sel => {
      if (sel !== globalSelect) fill(sel);
    });
    // after filling, apply active
    const idxVal = parseInt((globalSelect && globalSelect.value) || getActiveIndex(), 10);
    const snap = Number.isFinite(idxVal) ? history[idxVal] : null;
    if (snap) {
      saveActiveIndex(idxVal);
      updateWeekInputs(snap);
    }
  }

  function onSelectChange(e) {
    const idx = parseInt(e.target.value, 10);
    if (!Number.isFinite(idx)) return;
    const history = loadHistory();
    if (!history[idx]) return;
    saveActiveIndex(idx);
    updateWeekInputs(history[idx]);
    // Keep all selects in sync
    populateDropdowns();
    scheduleFullReload();
  }

  async function createNewPeriodSnapshot(start, end){
    if (!start || !end) return;
    // Normalize to ISO (YYYY-MM-DD)
    const toIso = (s)=>{ try{ return s && /^\d{4}-\d{2}-\d{2}$/.test(s) ? s : (new Date(s)).toISOString().slice(0,10); } catch { return s; } };
    let s = toIso(start), e = toIso(end);
    if (s && e && s > e) { const t = s; s = e; e = t; }
    // Prevent duplicates
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const exists = hist.some(x => x && x.startDate === s && x.endDate === e);
    if (exists) { alert('A payroll snapshot for this date range already exists.'); return; }
    if (typeof buildSnapshot !== 'function') { alert('buildSnapshot function not available.'); return; }
    const snap = await buildSnapshot(s, e);
    if (!snap) { alert('Payroll table is missing or empty.'); return; }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    const newSnap = { startDate: s, endDate: e, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false };
    if (Array.isArray(window.payrollHistory)) {
      window.payrollHistory.push(newSnap);
      if (typeof saveHistory === 'function') saveHistory();
    } else {
      const localHist = loadHistory();
      localHist.push(newSnap);
      localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(localHist));
    }
    // Refresh UI pieces
    try { if (typeof renderHistory === 'function') renderHistory(); } catch {}
    try { if (typeof renderActivePayrolls === 'function') renderActivePayrolls(); } catch {}
    // Set new active index (last)
    let idx;
    if (Array.isArray(window.payrollHistory)) idx = window.payrollHistory.length - 1; else idx = (loadHistory().length - 1);
    saveActiveIndex(idx);
    populateDropdowns();
  }

  function validateNewPeriodForm(){
    const sEl = document.getElementById('newPeriodStart');
    const eEl = document.getElementById('newPeriodEnd');
    const err = document.getElementById('newPeriodErr');
    const saveBtn = document.getElementById('saveNewPeriod');
    const s = sEl && sEl.value || '';
    const e = eEl && eEl.value || '';
    const ok = !!s && !!e && (!s || !e || s <= e);
    if (err) err.style.display = (s && e && s > e) ? 'block' : 'none';
    if (saveBtn) saveBtn.disabled = !ok;
    return ok;
  }

  function setNewPeriodBusy(busy){
    const saveBtn = document.getElementById('saveNewPeriod');
    const cancelBtn = document.getElementById('cancelNewPeriod');
    const status = document.getElementById('newPeriodStatus');
    const spin = document.getElementById('newPeriodSpin');
    if (status) status.style.display = busy ? 'inline-flex' : 'none';
    if (spin) spin.style.display = busy ? 'inline-block' : 'none';
    if (saveBtn) saveBtn.disabled = !!busy;
    if (cancelBtn) cancelBtn.disabled = !!busy;
  }

  function ensureNewPeriodBindings(){
    const modal = document.getElementById('newPeriodModal');
    if (!modal) return;
    if (!modal.__bound){
      modal.addEventListener('click', (e)=>{ if (e.target === modal) { modal.style.display = 'none'; } });
      document.getElementById('cancelNewPeriod')?.addEventListener('click', ()=>{ if (!document.getElementById('cancelNewPeriod').disabled) modal.style.display='none'; });
      const saveBtn = document.getElementById('saveNewPeriod');
      if (saveBtn){
        saveBtn.addEventListener('click', async ()=>{
          if (!validateNewPeriodForm()) return;
          setNewPeriodBusy(true);
          // allow spinner to render
          await new Promise(r=>setTimeout(r,0));
          const s = (document.getElementById('newPeriodStart')||{}).value || '';
          const e = (document.getElementById('newPeriodEnd')||{}).value || '';
          await createNewPeriodSnapshot(s, e);
          setNewPeriodBusy(false);
          modal.style.display = 'none';
        });
      }
      const sEl = document.getElementById('newPeriodStart');
      const eEl = document.getElementById('newPeriodEnd');
      const syncMins = ()=>{ try{ if (eEl) eEl.min = sEl && sEl.value ? sEl.value : ''; } catch{} };
      sEl?.addEventListener('input', ()=>{ syncMins(); validateNewPeriodForm(); });
      eEl?.addEventListener('input', ()=>{ validateNewPeriodForm(); });
      syncMins();
      // Keyboard shortcuts
      modal.addEventListener('keydown', async (ev)=>{
        if (ev.key === 'Escape') { ev.preventDefault(); if (!document.getElementById('cancelNewPeriod').disabled) modal.style.display='none'; }
        if (ev.key === 'Enter') { ev.preventDefault(); if (validateNewPeriodForm()) document.getElementById('saveNewPeriod').click(); }
      });
      modal.__bound = true;
    }
  }

  function onNewPeriod() {
    const modal = document.getElementById('newPeriodModal');
    ensureNewPeriodBindings();
    if (!modal) return;
    // Prefill from existing inputs
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const sEl = document.getElementById('newPeriodStart');
    const eEl = document.getElementById('newPeriodEnd');
    if (sEl) sEl.value = (ws && ws.value) || '';
    if (eEl) eEl.value = (we && we.value) || '';
    // Reset UI state
    const err = document.getElementById('newPeriodErr');
    if (err) err.style.display = 'none';
    setNewPeriodBusy(false);
    validateNewPeriodForm();
    modal.style.display = 'flex';
    try { modal.setAttribute('tabindex','-1'); modal.focus(); } catch{}
    // Focus start date without forcing the picker to open (avoids jank)
    setTimeout(()=>{ try{ sEl?.focus(); } catch{} }, 0);
  }

  function onPanelApply(e) {
    const wrap = e.target.closest('.active-week-bar');
    if (!wrap) return;
    const sel = wrap.querySelector('.activeWeekSelect');
    if (!sel) return;
    onSelectChange({ target: sel });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const globalSelect = document.getElementById('activePayrollSelect');
    if (globalSelect) {
      globalSelect.addEventListener('change', onSelectChange);
    }
    const newBtn = document.getElementById('newPayrollPeriod');
    if (newBtn) {
      newBtn.addEventListener('click', onNewPeriod);
    }
    // Bind modal controls once DOM is ready for instant usage
    try { ensureNewPeriodBindings(); } catch(_){ }
    document.addEventListener('click', (e) => {
      if (e.target && e.target.classList && e.target.classList.contains('refreshActiveWeek')) {
        onPanelApply(e);
      }
    });
    populateDropdowns();
  });

  (function() {
    const tbody = document.querySelector('#historyTable tbody');
    if (!tbody) return;
    const observer = new MutationObserver(() => {
      try {
        populateDropdowns();
      } catch (err) {}
    });
    observer.observe(tbody, { childList: true, subtree: false });
  })();
})();
</script>

<script>
(function(){
  // On page load, immediately check whether the currently selected payroll period
  // is locked and toggle the UI accordingly. Without this, the DTR panel may
  // remain interactive on initial load even if the chosen period has been
  // previously locked. The check is wrapped in a try-catch to avoid
  // exceptions during startup.
  document.addEventListener('DOMContentLoaded', () => {
    try {
      if (typeof checkAndToggleEditState === 'function') {
        checkAndToggleEditState();
      }
    } catch (e) {}
  });
})();
</script>

<!-- =====================================================================
     DTR Cloud Persistence with Supabase

     The payroll application originally stored uploaded DTR records exclusively
     in localStorage.  Browsers typically limit localStorage to about 5Â MB,
     which can be quickly exceeded when importing large attendance files.  To
     provide true crossâ€‘device persistence and remove the size constraint,
     the functions below save and load the DTR dataset via Supabase.  They
     expect a table named `dtr_records` in your Supabase database with the
     following schema:

         CREATE TABLE dtr_records (
           id text PRIMARY KEY,
           data jsonb
         );

     The policy can mirror the permissive configuration used for kv_store:

         -- Allow anon users to read and write the single row
         CREATE POLICY "Allow all access to dtr_records" ON dtr_records
           FOR ALL USING (true) WITH CHECK (true);

     The row uses a fixed primary key (id = 'records') so that each upsert
     overwrites the existing dataset.  If you wish to store separate sets
     by period or company, you can adjust the id accordingly.  When the
     page loads it attempts to fetch the remote DTR and, if found, will
     populate the global `storedRecords` array and update localStorage.
     Uploaded files are automatically persisted to the cloud via
     saveDtrToCloud(), invoked in the file upload handler above.
===================================================================== -->
<script>
/*
 * Save the entire DTR dataset to Supabase.  This helper uses the
 * globally scoped `supabase` client (injected by the KV sync adapter)
 * to upsert the records into the `dtr_records` table.  The primary
 * key is fixed to 'records' so that only a single row is maintained.
 */
async function saveDtrToCloud(records) {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa) return;
    const { error } = await supa
      .from('dtr_records')
      .upsert({ id: 'records', data: records }, { onConflict: 'id' });
    if (error) console.error('Supabase DTR save error:', error.message);
  } catch (e) {
    console.error('Supabase DTR save failed', e);
  }
}

/*
 * Upload a raw DTR file to Supabase Storage.  This helper uploads the
 * original .DAT/.TXT file into the 'dtr_uploads' folder of the 'app'
 * storage bucket.  If the bucket does not exist or the upload fails,
 * the error is logged and the application continues silently.  Each
 * upload uses a timestamp and random suffix to avoid collisions.
 */
async function uploadDtrFileToCloud(file) {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa || !file) return;
    const bucket = supa.storage.from('app');
    // Compose a unique path using a timestamp and random number to avoid collisions
    const path = `dtr_uploads/${Date.now()}_${Math.floor(Math.random() * 1000)}_${file.name}`;
    const { error } = await bucket.upload(path, file, { upsert: false });
    if (error) {
      console.warn('Supabase DTR file upload error:', error.message);
    }
  } catch (err) {
    console.warn('Supabase DTR file upload failed', err);
  }
}

/*
 * Retrieve the DTR dataset from Supabase.  Returns an array of
 * attendance records if available, otherwise null.  The returned
 * object is expected to have the shape { data: [...] }, so we
 * unwrap the nested data field when present.
 */
async function loadDtrFromCloud() {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa) return null;
    const { data, error } = await supa
      .from('dtr_records')
      .select('data')
      .eq('id', 'records')
      .maybeSingle();
    if (error) {
      // Only warn on fetch errors to avoid blocking page load.  The
      // application will fall back to localStorage if the fetch fails.
      console.warn('Supabase DTR fetch error:', error.message);
      return null;
    }
    return data && Array.isArray(data.data) ? data.data : null;
  } catch (e) {
    console.error('Supabase DTR fetch failed', e);
    return null;
  }
}

// Helpers to control the remote DTR alert banner.  These functions
// locate the #remoteDtrAlert element and toggle its visibility.  The
// banner notifies users when there is no remote DTR data available
// and encourages them to upload a .DAT/.TXT file to populate the
// cloud.  If the element is not present these helpers silently do
// nothing.
function showRemoteDtrAlert(msg){
  const el = document.getElementById('remoteDtrAlert');
  if (!el) return;
  // Prefix the message with a warning symbol for emphasis
  el.textContent = `âš  ${msg}`;
  el.style.display = '';
}
function hideRemoteDtrAlert(){
  const el = document.getElementById('remoteDtrAlert');
  if (!el) return;
  el.style.display = 'none';
}

// On initial load, attempt to hydrate storedRecords from Supabase.  If
// remote data exists it will overwrite the current storedRecords array
// and localStorage.  This ensures that the latest DTR data is available
// across devices while preserving offline capability.  The call is
// performed after DOMContentLoaded to ensure that other scripts have
// defined storedRecords and renderResults() before we modify them.
document.addEventListener('DOMContentLoaded', async function () {
  try {
    const remote = await loadDtrFromCloud();
    if (Array.isArray(remote) && remote.length) {
      // When remote data is available, replace the inâ€‘memory dataset.  We
      // deliberately overwrite both the local variable and the global
      // window.storedRecords to ensure all modules reference the same
      // canonical source of truth.  Persist into localStorage as an
      // offline fallback, but always prefer Supabase on subsequent loads.
      storedRecords = remote;
      window.storedRecords = remote;
      try { localStorage.setItem(LS_RECORDS, JSON.stringify(remote)); } catch (e) {}
      if (typeof renderResults === 'function') {
        try { renderResults(); } catch (e) {}
      }
      if (typeof hideRemoteDtrAlert === 'function') hideRemoteDtrAlert();
    } else {
      // No remote data: clear any existing local dataset and inform the user. window. try { localStorage.removeItem(LS_RECORDS); } catch (e) {}
      if (typeof renderResults === 'function') {
        try { renderResults(); } catch (e) {}
      }
      if (typeof showRemoteDtrAlert === 'function') {
        showRemoteDtrAlert('No remote DTR data found. Import a .DAT/.TXT file to populate cloud data.');
      }
    }
  } catch (e) {
    console.error('Error hydrating DTR from Supabase', e);
  }
});
</script>

<script>
(function(){
  document.addEventListener('DOMContentLoaded', function(){
    const supabase = window.supabase;
    const KV_TABLE = window.SUPABASE_TABLE || 'kv_store';
    const DTR_TABLE = 'dtr_records';
    const BUCKET = 'backups';
    // locate header to attach controls (fallback to body if missing)
    const header = document.querySelector('#panelPayroll header') || document.body;
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'wrap';
    wrap.style.gap = '6px';
    wrap.style.alignItems = 'center';
    wrap.style.marginTop = '10px';
    // status element
    const statusSpan = document.createElement('span');
    statusSpan.id = 'backupStatus';
    statusSpan.style.fontSize = '12px';
    statusSpan.style.color = '#374151';
    // Buttons
    const backupBtn = document.createElement('button');
    backupBtn.id = 'backupNowBtn';
    backupBtn.type = 'button';
    backupBtn.textContent = 'ðŸ”’ Backup Now';
    backupBtn.style.cursor = 'pointer';
    const testBtn = document.createElement('button');
    testBtn.id = 'testRestoreBtn';
    testBtn.type = 'button';
    testBtn.textContent = 'ðŸ§ª Test Restore (Dry Run)';
    testBtn.style.cursor = 'pointer';
    const restoreBtn = document.createElement('button');
    restoreBtn.id = 'restoreBundleBtn';
    restoreBtn.type = 'button';
    restoreBtn.textContent = 'Restore Bundle';
    restoreBtn.style.cursor = 'pointer';
    const listCloudBtn = document.createElement('button');
    listCloudBtn.id = 'listCloudBackups';
    listCloudBtn.type = 'button';
    listCloudBtn.textContent = 'List Backups';
    listCloudBtn.style.cursor = 'pointer';
    listCloudBtn.title = 'Fetch available backups from Supabase storage';
    const cloudSelect = document.createElement('select');
    cloudSelect.id = 'cloudBackupSelect';
    cloudSelect.style.display = 'none';
    const restoreCloudBtn = document.createElement('button');
    restoreCloudBtn.id = 'restoreCloudBtn';
    restoreCloudBtn.type = 'button';
    restoreCloudBtn.textContent = 'Restore Selected';
    restoreCloudBtn.style.cursor = 'pointer';
    restoreCloudBtn.style.display = 'none';
    restoreCloudBtn.title = 'Download the selected backup from Supabase and restore';
    const healthBtn = document.createElement('button');
    healthBtn.id = 'healthCheckBtn';
    healthBtn.type = 'button';
    healthBtn.textContent = 'ðŸ©º Health Check';
    healthBtn.style.cursor = 'pointer';
    const restoreInput = document.createElement('input');
    restoreInput.id = 'restoreFileInput';
    restoreInput.type = 'file';
    restoreInput.accept = '.json';
    restoreInput.style.display = 'none';
    const logDiv = document.createElement('div');
    logDiv.id = 'backupLog';
    logDiv.style.width = '100%';
    logDiv.style.maxWidth = '920px';
    logDiv.style.background = '#ffffff';
    logDiv.style.border = '1px solid #e5e7eb';
    logDiv.style.borderRadius = '8px';
    logDiv.style.padding = '10px';
    logDiv.style.fontSize = '12px';
    logDiv.style.color = '#111111';
    logDiv.style.lineHeight = '1.35';
    logDiv.style.display = 'none';
    // Append children
    wrap.appendChild(statusSpan);
    wrap.appendChild(backupBtn);
    wrap.appendChild(testBtn);
    wrap.appendChild(restoreBtn);
    wrap.appendChild(listCloudBtn);
    wrap.appendChild(cloudSelect);
    wrap.appendChild(restoreCloudBtn);
    wrap.appendChild(healthBtn);
    wrap.appendChild(logDiv);
    wrap.appendChild(restoreInput);
    header.appendChild(wrap);
    // Local references
    const statusEl = statusSpan;
    const logEl = logDiv;
    const btnBackup = backupBtn;
    const btnDry = testBtn;
    const btnRestore = restoreBtn;
    const btnList = listCloudBtn;
    const selectCloud = cloudSelect;
    const btnRestoreCloud = restoreCloudBtn;
    const btnHealth = healthBtn;
    const inputRestore = restoreInput;
    // Utility functions
    function setStatus(msg, isError){
      if (!statusEl) return;
      statusEl.textContent = msg || '';
      statusEl.style.color = isError ? '#b91c1c' : '#374151';
    }
    function logMsg(msg){
      if (!logEl) return;
      if (logEl.style.display === 'none') logEl.style.display = 'block';
      const div = document.createElement('div');
      const now = new Date();
      div.textContent = now.toLocaleTimeString() + ' - ' + msg;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function clearLog(){
      if (logEl){ logEl.innerHTML = ''; logEl.style.display = 'none'; }
    }
    function lockUI(lock){
      [btnBackup, btnDry, btnRestore, btnHealth, inputRestore, btnList, btnRestoreCloud, selectCloud].forEach(function(el){ if (el){ el.disabled = lock; el.style.opacity = lock ? '0.7' : '1'; }});
    }
    async function listBackups(){
      if(!supabase || !supabase.storage){ setStatus('Supabase storage unavailable', true); return; }
      try {
        setStatus('Fetching backups...');
        const { data, error } = await supabase.storage.from(BUCKET).list('');
        if (error){ setStatus('List failed: ' + error.message, true); return; }
        selectCloud.innerHTML = '';
        (data || []).filter(o=>o.name && o.name.endsWith('.json')).sort((a,b)=> b.name.localeCompare(a.name)).forEach(function(obj){
          const opt = document.createElement('option');
          opt.value = obj.name;
          opt.textContent = obj.name;
          selectCloud.appendChild(opt);
        });
        if (selectCloud.options.length){
          selectCloud.style.display = '';
          btnRestoreCloud.style.display = '';
          setStatus('Select a backup to restore');
        } else {
          selectCloud.style.display = 'none';
          btnRestoreCloud.style.display = 'none';
          setStatus('No backups found');
        }
      } catch(e){ setStatus('List failed: ' + e.message, true); }
    }
    async function restoreFromCloud(){
      const name = selectCloud && selectCloud.value;
      if(!name){ alert('Select a backup first'); return; }
      if(!supabase || !supabase.storage){ setStatus('Supabase storage unavailable', true); return; }
      try {
        setStatus('Downloading ' + name + '...');
        const { data, error } = await supabase.storage.from(BUCKET).download(name);
        if (error) throw error;
        const file = new File([data], name, { type: 'application/json' });
        await restoreFile(file, { dryRun: false });
      } catch(e){
        setStatus('Cloud restore failed: ' + e.message, true);
        logMsg('Cloud restore failed: ' + e.message);
      }
    }
    function nowStamp(){
      const d = new Date();
      const iso = d.toISOString().replace(/[:]/g,'').replace(/\.\d{3}Z$/,'Z');
      return iso;
    }
    async function sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }
    async function buildMetadata(local, db){
      const meta = { localKeys: Object.keys(local).length, tables: {} };
      try { meta.localHash = await sha256Hex(JSON.stringify(local)); } catch(e){ meta.localHash = 'n/a'; }
      const entries = Object.entries(db || {});
      for (const [name, rows] of entries){
        const safeRows = Array.isArray(rows) ? rows : [];
        const entry = { count: safeRows.length };
        try { entry.hash = await sha256Hex(JSON.stringify(safeRows)); } catch(e){ entry.hash = 'n/a'; }
        meta.tables[name] = entry;
      }
      return meta;
    }
    async function validateBundleIntegrity(bundle){
      const local = isObject(bundle.local) ? bundle.local : {};
      const db = isObject(bundle.db) ? bundle.db : {};
      const meta = isObject(bundle.meta) ? bundle.meta : {};
      if (meta.localHash && meta.localHash !== 'n/a' && meta.localHash !== await sha256Hex(JSON.stringify(local))){
        throw new Error('Local payload hash mismatch');
      }
      for (const [name, rows] of Object.entries(db)){
        const expected = meta.tables && meta.tables[name] ? meta.tables[name] : null;
        const safeRows = Array.isArray(rows) ? rows : [];
        if (expected){
          if (typeof expected.count === 'number' && expected.count !== safeRows.length){
            throw new Error(name + ' row count mismatch');
          }
          if (expected.hash && expected.hash !== 'n/a' && expected.hash !== await sha256Hex(JSON.stringify(safeRows))){
            throw new Error(name + ' hash mismatch');
          }
        }
      }
      return true;
    }
    async function backupNow(){
      try {
        lockUI(true); clearLog(); setStatus('Running backup...');
        logMsg('Starting backup');
        const local = {};
        const lsKeys = Object.keys(localStorage);
        lsKeys.forEach(function(k){
          try { local[k] = localStorage.getItem(k); } catch(e){}
        });
        logMsg('LocalStorage keys: ' + lsKeys.length);
        const TABLES = window.DB_TABLES || [KV_TABLE, DTR_TABLE];
        const db = {};
        let totalRows = 0;
        for (const t of TABLES){
          try {
            const { data, error } = await supabase.from(t).select('*');
            if (error){
              logMsg(t + ' fetch warning: ' + error.message);
              db[t] = [];
            } else {
              db[t] = data || [];
              totalRows += db[t].length;
              logMsg(t + ' rows: ' + db[t].length);
            }
          } catch(e){
            logMsg(t + ' fetch failed: ' + e.message);
            db[t] = [];
          }
        }
        const meta = await buildMetadata(local, db);
        const bundle = {
          schema: 'payrollhub.backup.v1',
          createdAt: new Date().toISOString(),
          local: local,
          db: db,
          meta: meta
        };
        const withoutHash = JSON.stringify(bundle);
        const hash = await sha256Hex(withoutHash);
        bundle.hash = hash;
        const final = JSON.stringify(bundle, null, 2);
        const blob = new Blob([final], { type: 'application/json' });
        const filename = 'backup-' + nowStamp() + '.json';
        try {
          if (supabase && supabase.storage){
            const { error: upErr } = await supabase.storage.from(BUCKET).upload(filename, blob, { upsert: true, contentType: 'application/json' });
            if (upErr) logMsg('Storage upload skipped: ' + upErr.message);
            else logMsg('Uploaded to storage bucket: ' + BUCKET + '/' + filename);
          }
        } catch(e){ logMsg('Storage error: ' + e.message); }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        setStatus('Backup complete âœ“  (Local: ' + lsKeys.length + ', Tables: ' + TABLES.length + ', Rows: ' + totalRows + ')');
        logMsg('Backup complete - SHA256: ' + hash);
      } catch(e){
        console.error(e);
        setStatus('Backup failed: ' + e.message, true);
        logMsg('ERROR: ' + e.message);
        alert('Backup failed: ' + e.message);
      } finally {
        lockUI(false);
      }
    }
    function isObject(o){ return o && typeof o === 'object' && !Array.isArray(o); }
    async function verifyBackup(bundle){
      const local = isObject(bundle.local) ? bundle.local : {};
      const db = isObject(bundle.db) ? bundle.db : {};
      const lsKeys = Object.keys(local);
      const tableNames = Object.keys(db);
      let tablesOk = 0;
      let localOk = 0;
      const tableIssues = [];
      const localIssues = [];
      if (supabase){
        for (const t of tableNames){
          const expected = Array.isArray(db[t]) ? db[t].length : 0;
          try {
            const { count, error } = await supabase.from(t).select('*', { count: 'exact', head: true });
            if (!error && count === expected) tablesOk++;
            else tableIssues.push(t + ': expected ' + expected + ', got ' + (error ? ('error ' + error.message) : count));
          } catch(e){ tableIssues.push(t + ': verify failed - ' + e.message); }
        }
      }
      lsKeys.forEach(function(k){
        try {
          const expected = typeof local[k] === 'string' ? local[k] : JSON.stringify(local[k]);
          const actual = localStorage.getItem(k);
          if (String(actual) === String(expected)) localOk++;
          else localIssues.push(k);
        } catch(e){ localIssues.push(k + ' (' + e.message + ')'); }
      });
      if (tableIssues.length) tableIssues.forEach(function(m){ logMsg('Table mismatch: ' + m); });
      if (localIssues.length) localIssues.forEach(function(m){ logMsg('LocalStorage mismatch: ' + m); });
      logMsg('Verification result - tables: ' + tablesOk + '/' + tableNames.length + ', local: ' + localOk + '/' + lsKeys.length);
      return { tables: { ok: tablesOk, total: tableNames.length }, local: { ok: localOk, total: lsKeys.length } };
    }
    window.verifyBackup = verifyBackup;
    async function restoreFile(file, opts){
      lockUI(true); clearLog();
      try {
        setStatus((opts && opts.dryRun ? 'Dry run: ' : '') + 'Reading file...');
        logMsg('Reading file: ' + file.name);
        const text = await file.text();
        let bundle;
        try { bundle = JSON.parse(text); } catch(e){ setStatus('Invalid JSON', true); throw e; }
        if (!isObject(bundle) || bundle.schema !== 'payrollhub.backup.v1'){ setStatus('Schema mismatch', true); throw new Error('Schema mismatch'); }
        const clone = Object.assign({}, bundle);
        const declared = clone.hash; delete clone.hash;
        const recompute = await sha256Hex(JSON.stringify(clone));
        if (declared && declared !== recompute){ setStatus('Hash mismatch', true); throw new Error('Hash mismatch'); }
        await validateBundleIntegrity(bundle);
        const local = isObject(bundle.local) ? bundle.local : {};
        const db = isObject(bundle.db) ? bundle.db : {};
        const lsKeys = Object.keys(local);
        const tableNames = Object.keys(db);
        logMsg('Bundle valid - Local keys: ' + lsKeys.length + ', Tables: ' + tableNames.length);
        if (opts && opts.dryRun){ setStatus('Dry run passed âœ“'); logMsg('No writes performed'); alert('Dry run OK - no data written.'); return; }
        if (!confirm('Restoring this backup will overwrite local data and Supabase tables (' + tableNames.length + ' tables, ' + lsKeys.length + ' local keys). Continue?')){
          setStatus('Restore cancelled');
          logMsg('User cancelled restore');
          return;
        }
        // Upsert tables
        if (supabase){
          for (const t of tableNames){
            const rows = Array.isArray(db[t]) ? db[t] : [];
            if (!rows.length) continue;
            try {
              const { error } = await supabase.from(t).upsert(rows);
              if (error) logMsg(t + ' upsert warning: ' + error.message);
              else logMsg(t + ' upserted: ' + rows.length);
            } catch(e){ logMsg(t + ' upsert failed: ' + e.message); }
          }
        }
        // Hydrate localStorage
        try {
          lsKeys.forEach(function(k){
            const v = local[k];
            const str = typeof v === 'string' ? v : JSON.stringify(v);
            localStorage.setItem(k, str);
          });
          logMsg('LocalStorage hydrated: ' + lsKeys.length + ' keys');
        } catch(e){ logMsg('LocalStorage hydrate warning: ' + e.message); }
        try {
          if (typeof calculateAll === 'function') calculateAll();
          if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
          if (typeof renderTable === 'function') renderTable();
        } catch(e){}
        const verify = await verifyBackup(bundle);
        const localSummary = verify.local.ok + '/' + verify.local.total;
        const tableSummary = verify.tables.ok + '/' + verify.tables.total;
        const allOk = verify.local.ok === verify.local.total && verify.tables.ok === verify.tables.total;
        const msg = (allOk ? 'Restore complete âœ“ ' : 'Restore completed with discrepancies') +
          ' (Local: ' + localSummary + ', Tables: ' + tableSummary + ')';
        setStatus(msg, !allOk);
        logMsg(msg);
        alert(allOk ? 'Restore complete.' : 'Restore completed with discrepancies. See log.');
      } catch(e){
        console.error(e);
        setStatus('Restore failed: ' + e.message, true);
        logMsg('ERROR: ' + e.message);
        alert('Restore failed: ' + e.message);
      } finally {
        lockUI(false);
      }
    }
    async function healthCheck(){
      lockUI(true); clearLog();
      setStatus('Running health checkâ€¦');
      logMsg('Checking KV table, DTR table, and Storage bucket');
      const results = { kv:false, dtr:false, storage:false };
      try {
        const r = await supabase.from(KV_TABLE).select('key').limit(1);
        if (!r.error){ results.kv = true; logMsg('KV table OK'); } else { logMsg('KV issue: ' + r.error.message); }
      } catch(e){ logMsg('KV exception: ' + e.message); }
      try {
        const r2 = await supabase.from(DTR_TABLE).select('count', { count: 'exact', head: true });
        if (!r2.error){ results.dtr = true; logMsg('DTR table OK'); } else { logMsg('DTR issue: ' + r2.error.message); }
      } catch(e){ logMsg('DTR exception: ' + e.message); }
      try {
        if (supabase && supabase.storage){
          const r3 = await supabase.storage.from(BUCKET).list('', { limit: 1 });
          if (!r3.error){ results.storage = true; logMsg('Storage bucket OK'); } else { logMsg('Storage bucket issue: ' + r3.error.message); }
        } else { logMsg('Supabase storage client not available'); }
    } catch(e){ logMsg('Storage exception: ' + e.message); }
    const summary = 'KV: ' + (results.kv?'OK':'Issue') + ' | DTR: ' + (results.dtr?'OK':'Issue') + ' | Storage: ' + (results.storage?'OK':'Issue');
    setStatus('Health check done - ' + summary, !(results.kv && results.dtr));
    lockUI(false);
    }
    // Attach event listeners
    backupBtn.addEventListener('click', backupNow);
    testBtn.addEventListener('click', function(){
      const tmpInput = document.createElement('input');
      tmpInput.type = 'file';
      tmpInput.accept = '.json';
      tmpInput.onchange = function(e){
        const f = e.target.files && e.target.files[0];
        if (f) restoreFile(f, { dryRun: true });
      };
      tmpInput.click();
    });
    restoreBtn.addEventListener('click', function(){
      inputRestore.click();
    });
    inputRestore.addEventListener('change', function(e){
      const f = e.target.files && e.target.files[0];
      if (f) restoreFile(f, { dryRun: false });
      e.target.value = '';
    });
    healthBtn.addEventListener('click', healthCheck);
    listCloudBtn.addEventListener('click', listBackups);
    restoreCloudBtn.addEventListener('click', restoreFromCloud);
  });
})();
</script>

<script>
// ===== DTR Editor Column (Total Regular & OT editable) =====
(function(){
  const LS_OVR_HOURS = 'att_overrides_hours_v1';
  let overridesHours = {};
  try { overridesHours = JSON.parse(localStorage.getItem(LS_OVR_HOURS) || '{}') || {}; } catch(e){ overridesHours = {}; }
  function saveOverridesHours(){ try { localStorage.setItem(LS_OVR_HOURS, JSON.stringify(overridesHours)); } catch(e){} }
  // Persist overrides to Supabase (kv_store) and fetch initial remote data
  function saveOverridesHoursRemote(){
    try {
      const supabaseClient = window.supabase;
      const table = window.SUPABASE_TABLE;
      if(!supabaseClient || !table) return;
      // Upsert the entire overridesHours object as the value for LS_OVR_HOURS
      supabaseClient
        .from(table)
        .upsert({ key: LS_OVR_HOURS, value: overridesHours }, { onConflict: 'key' })
        .then(({ error }) => {
          if (error) console.warn('Supabase upsert overridesHours error:', error);
        });
    } catch(e){ console.warn('Supabase upsert overridesHours failed', e); }
  }
  // Load remote overridesHours from Supabase on startup, merge/replace local state and apply to table
  (async function loadRemoteOverrides(){
    try {
      const supabaseClient = window.supabase;
      const table = window.SUPABASE_TABLE;
      if(!supabaseClient || !table) return;
      const { data, error } = await supabaseClient
        .from(table)
        .select('value')
        .eq('key', LS_OVR_HOURS)
        .maybeSingle();
      if(!error && data && data.value){
        // replace overridesHours with remote value
        if (typeof data.value === 'object') {
          overridesHours = data.value;
          // persist to local storage for offline use
          saveOverridesHours();
          // apply remote values to table after they've loaded
          applyOverridesToTable();
          recomputeDtrSummaryFromTable();
        }
      }
    } catch(e){ console.warn('Load remote overrides failed', e); }
  })();
  // Subscribe to realtime updates for overridesHours in Supabase so edits on other devices reflect here
  try {
    const supabaseClient = window.supabase;
    const table = window.SUPABASE_TABLE;
    if (supabaseClient && table && supabaseClient.channel) {
      supabaseClient
        .channel('dtr_overrides_hours')
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: table, filter: `key=eq.${LS_OVR_HOURS}` },
          (payload) => {
            try {
              const newVal = payload.new && payload.new.value;
              if (newVal && typeof newVal === 'object') {
                overridesHours = newVal;
                saveOverridesHours();
                applyOverridesToTable();
                recomputeDtrSummaryFromTable();
              }
            } catch(e) { console.warn('Realtime payload handling error', e); }
          }
        )
        .subscribe();
    }
  } catch(e){ console.warn('Realtime subscription error:', e); }

  function ensureEditorHeader(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const theadRow = table.querySelector('thead tr');
    if(!theadRow) return;
    if(!theadRow.querySelector('.editor-header')){
      const th = document.createElement('th');
      th.textContent = 'Editor';
      th.className = 'editor-header';
      theadRow.appendChild(th);
    }
  }

  function getColIndexes(table){
    const heads = Array.from(table.querySelectorAll('thead th')).map(th => String((th.textContent || '')).trim());
    const norm = txt => String(txt || '').replace(/\s+/g, ' ').trim().toLowerCase();
    const map = {
      regIdx: heads.findIndex(t => /(^(Total\s+)?Regular\s+Hrs$)/i.test(t)),
      otIdx:  heads.findIndex(t => /^OT\s*Hrs$/i.test(t)),
      clockIn1Idx: -1,
      clockOut1Idx: -1,
      clockIn2Idx: -1,
      clockOut2Idx: -1,
      otInIdx: -1,
      otOutIdx: -1
    };
    heads.forEach((txt, idx) => {
      const n = norm(txt);
      if (n === 'clock in 1' || n === 'am in') map.clockIn1Idx = idx;
      else if (n === 'clock out 1' || n === 'am out') map.clockOut1Idx = idx;
      else if (n === 'clock in 2' || n === 'pm in') map.clockIn2Idx = idx;
      else if (n === 'clock out 2' || n === 'pm out') map.clockOut2Idx = idx;
      else if (n === 'ot in') map.otInIdx = idx;
      else if (n === 'ot out') map.otOutIdx = idx;
    });
    return map;
  }

  // Generate keys for an editor row.
  // - base key: stable across devices (empId + date)
  // - half key: includes segment when table is split (AM/PM/OT)
  function baseKeyForRow(tr){
    const empId = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
    const date  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
    return empId + '___' + date;
  }
  function keyForRow(tr){
    const base = baseKeyForRow(tr);
    if (tr.dataset && tr.dataset.half) return base + '___' + tr.dataset.half; // AM/PM/OT
    return base;
  }

  function applyOverridesToTable(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const {regIdx, otIdx} = getColIndexes(table);
    if(regIdx < 0 || otIdx < 0) return;
    table.querySelectorAll('tbody tr').forEach(tr=>{
      const kHalf = keyForRow(tr);
      const kBase = baseKeyForRow(tr);
      const ov = overridesHours[kHalf] || overridesHours[kBase];
      if(ov){
        const regVal = (parseFloat(ov.reg)||0).toFixed(2);
        const otVal  = (parseFloat(ov.ot )||0).toFixed(2);
        const regStar = (Object.prototype.hasOwnProperty.call(ov,'regEdited') ? !!ov.regEdited : true);
        const otStar  = (Object.prototype.hasOwnProperty.call(ov,'otEdited')  ? !!ov.otEdited  : true);
        tr.cells[regIdx].textContent = regVal + (regStar ? ' *' : '');
        tr.cells[otIdx ].textContent = otVal  + (otStar  ? ' *' : '');
      }
    });
  }

  function recomputeDtrSummaryFromTable(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const {regIdx, otIdx} = getColIndexes(table);
    if(regIdx < 0 || otIdx < 0) return;
    let sumReg = 0, sumOt = 0, empSet = new Set();
    table.querySelectorAll('tbody tr').forEach(tr=>{
      const empId = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
      if(empId) empSet.add(empId);
      const reg = parseFloat(tr.cells[regIdx] && tr.cells[regIdx].textContent) || 0;
      const ot  = parseFloat(tr.cells[otIdx]  && tr.cells[otIdx].textContent)  || 0;
      sumReg += reg; sumOt += ot;
    });
    const summaryEl = document.getElementById('dtrSummary');
    if(summaryEl){
      const total = sumReg + sumOt;
      summaryEl.textContent = 'Grand Total Hours: ' + formatHours(total) + ' | Regular: ' + formatHours(sumReg) + ' | OT Hours: ' + formatHours(sumOt) + ' | Employees: ' + empSet.size;
    }
  }

  function getTimeFieldsForRow(tr){
    if (!tr || !tr.dataset) {
      return ['clockIn1','clockOut1','clockIn2','clockOut2','otIn','otOut'];
    }
    const half = tr.dataset.half;
    if (half === 'AM') return ['clockIn1','clockOut1'];
    if (half === 'PM') return ['clockIn2','clockOut2'];
    if (half === 'OT') return ['otIn','otOut'];
    return ['clockIn1','clockOut1','clockIn2','clockOut2','otIn','otOut'];
  }

  function revertTimeCellsToDisplay(tr, fields, idxMap){
    if (!tr) return;
    fields.forEach(field => {
      const idxProp = field + 'Idx';
      const idx = idxMap[idxProp];
      if (typeof idx !== 'number' || idx < 0) return;
      const cell = tr.cells[idx];
      if (!cell) return;
      const val = (tr.dataset && tr.dataset[field]) ? tr.dataset[field] : '';
      cell.innerHTML = '';
      if (val){
        cell.textContent = __fmt12Clock(val);
        cell.classList.remove('missing');
      } else {
        cell.textContent = '-';
        cell.classList.add('missing');
      }
    });
  }

  function removeRecordsForTimes(empId, date, times){
    if (!Array.isArray(times) || !times.length) return;
    times.forEach(t => {
      for (let i = storedRecords.length - 1; i >= 0; i--){
        const rec = storedRecords[i];
        if (String(rec.empId) === String(empId) && rec.date === date && rec.time === t){
          storedRecords.splice(i, 1);
          break;
        }
      }
    });
  }

  function persistStoredRecords(){
    try { localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords)); } catch(e){}
    try {
      if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
    } catch(e){
      console.warn('Failed to save DTR to Supabase', e);
    }
  }

  function applyTimeUpdates(tr, fields, idxMap){
    if (!tr) return { changed: false };
    const values = {};
    const prevValues = {};
    let changed = false;
    fields.forEach(field => {
      const prev = (tr.dataset && tr.dataset[field]) || '';
      prevValues[field] = prev;
      const idxProp = field + 'Idx';
      const idx = idxMap[idxProp];
      if (typeof idx !== 'number' || idx < 0) {
        values[field] = prev;
        return;
      }
      const cell = tr.cells[idx];
      if (!cell){
        values[field] = prev;
        return;
      }
      const input = cell.querySelector('input.edit-time');
      const val = input && input.value ? input.value : '';
      values[field] = val;
      if (val !== prev) changed = true;
    });
    if (!changed){
      revertTimeCellsToDisplay(tr, fields, idxMap);
      return { changed: false };
    }
    const empId = (tr.dataset && tr.dataset.empId) || (tr.cells[0] ? tr.cells[0].textContent.trim() : '');
    const date = (tr.dataset && tr.dataset.date) || (tr.cells[4] ? tr.cells[4].textContent.trim() : '');
    if (!empId || !date){
      revertTimeCellsToDisplay(tr, fields, idxMap);
      return { changed: false };
    }
    const toRemove = new Set();
    const toAdd = new Set();
    fields.forEach(field => {
      const before = prevValues[field] || '';
      const after = values[field] || '';
      if (before && before !== after){
        toRemove.add(before);
      }
      if (!after && before){
        toRemove.add(before);
      }
      if (after && before !== after){
        toAdd.add(after);
      }
    });
    if (toRemove.size){
      removeRecordsForTimes(empId, date, Array.from(toRemove));
    }
    if (toAdd.size){
      Array.from(toAdd).forEach(time => {
        storedRecords.push({ empId: String(empId), date, time, manual: true });
      });
    }
    fields.forEach(field => {
      const nextVal = values[field] || '';
      tr.dataset[field] = nextVal;
    });
    const allTimes = fields
      .map(field => tr.dataset && tr.dataset[field] ? tr.dataset[field] : '')
      .filter(Boolean)
      .sort();
    try {
      tr.dataset.times = JSON.stringify(allTimes);
    } catch(_) {
      tr.dataset.times = '[]';
    }
    persistStoredRecords();
    return { changed: true };
  }

  function addDtrEditorButtons(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    ensureEditorHeader();
    const idxMap = getColIndexes(table);
    const regIdx = idxMap.regIdx;
    const otIdx = idxMap.otIdx;
    table.querySelectorAll('tbody tr').forEach(tr => {
      if(tr.querySelector('.dtr-edit-btn')) return;
      const td = document.createElement('td');
      td.className = 'editor-cell';
      const btn = document.createElement('button');
      btn.textContent = 'Edit';
      btn.className = 'dtr-edit-btn';
      btn.addEventListener('click', () => {
        const regCell = (regIdx >= 0) ? tr.cells[regIdx] : null;
        const otCell  = (otIdx >= 0) ? tr.cells[otIdx] : null;
        const timeFields = getTimeFieldsForRow(tr);
        if(btn.textContent === 'Edit'){
          const regVal = regCell ? (parseFloat(regCell.textContent) || 0) : 0;
          const otVal  = otCell  ? (parseFloat(otCell.textContent)  || 0) : 0;
          if (regCell) regCell.innerHTML = '<input type="number" step="0.01" class="edit-reg" value="'+regVal+'">';
          if (otCell)  otCell .innerHTML = '<input type="number" step="0.01" class="edit-ot"  value="'+otVal+'">';
          try {
            if (regCell) tr.dataset.origReg = String(regVal.toFixed(2));
            if (otCell)  tr.dataset.origOt  = String(otVal.toFixed(2));
            const kHalf0 = keyForRow(tr);
            const kBase0 = baseKeyForRow(tr);
            const ov0 = (overridesHours && (overridesHours[kHalf0] || overridesHours[kBase0])) || null;
            const hadAny = !!ov0;
            const hadReg = hadAny ? (Object.prototype.hasOwnProperty.call(ov0,'regEdited') ? !!ov0.regEdited : true) : false;
            const hadOt  = hadAny ? (Object.prototype.hasOwnProperty.call(ov0,'otEdited')  ? !!ov0.otEdited  : true) : false;
            tr.dataset.hadRegEdited = hadReg ? '1' : '0';
            tr.dataset.hadOtEdited  = hadOt  ? '1' : '0';
          } catch(_){}
          timeFields.forEach(field => {
            const idxProp = field + 'Idx';
            const idx = idxMap[idxProp];
            if (typeof idx !== 'number' || idx < 0) return;
            const cell = tr.cells[idx];
            if (!cell) return;
            const val = (tr.dataset && tr.dataset[field]) ? tr.dataset[field] : '';
            const input = document.createElement('input');
            input.type = 'time';
            input.className = 'edit-time';
            input.dataset.field = field;
            if (val) input.value = val;
            cell.classList.remove('missing');
            cell.innerHTML = '';
            cell.appendChild(input);
          });
          btn.textContent = 'Save';
        } else {
          const regInput = tr.querySelector('input.edit-reg');
          const otInput  = tr.querySelector('input.edit-ot');
          const regVal = regInput ? (parseFloat(regInput.value) || 0) : 0;
          const otVal  = otInput  ? (parseFloat(otInput.value)  || 0) : 0;
          const kHalf = keyForRow(tr);
          const kBase = baseKeyForRow(tr);
          const origR = parseFloat(tr.dataset.origReg || 'NaN');
          const origO = parseFloat(tr.dataset.origOt  || 'NaN');
          const hadPrevReg = (tr.dataset.hadRegEdited === '1');
          const hadPrevOt  = (tr.dataset.hadOtEdited  === '1');
          const changedReg = (regInput && isFinite(origR)) ? Math.abs(regVal - origR) > 1e-9 : false;
          const changedOt  = (otInput  && isFinite(origO)) ? Math.abs(otVal  - origO) > 1e-9 : false;
          const regEdited  = changedReg || hadPrevReg;
          const otEdited   = changedOt  || hadPrevOt;
          const timeResult = applyTimeUpdates(tr, timeFields, idxMap);
          let overridesTouched = false;
          if (timeResult.changed && !changedReg && !changedOt){
            try { if (overridesHours && Object.prototype.hasOwnProperty.call(overridesHours, kHalf)) { delete overridesHours[kHalf]; overridesTouched = true; } } catch(_){ }
            try { if (overridesHours && Object.prototype.hasOwnProperty.call(overridesHours, kBase)) { delete overridesHours[kBase]; overridesTouched = true; } } catch(_){ }
          } else if (regEdited || otEdited){
            const payload = { reg: regVal, ot: otVal, regEdited: !!regEdited, otEdited: !!otEdited };
            overridesHours[kHalf] = payload;
            overridesHours[kBase] = payload;
            overridesTouched = true;
          } else {
            try { if (overridesHours && Object.prototype.hasOwnProperty.call(overridesHours, kHalf)) { delete overridesHours[kHalf]; overridesTouched = true; } } catch(_){ }
            try { if (overridesHours && Object.prototype.hasOwnProperty.call(overridesHours, kBase)) { delete overridesHours[kBase]; overridesTouched = true; } } catch(_){ }
          }
          if (overridesTouched){
            saveOverridesHours();
            if (typeof saveOverridesHoursRemote === 'function') saveOverridesHoursRemote();
          }
          if (timeResult.changed){
            btn.textContent = 'Edit';
            try { renderResults(); } catch(e){}
            return;
          }
          const ovNow = overridesHours && (overridesHours[kHalf] || overridesHours[kBase]);
          const starReg = ovNow ? (Object.prototype.hasOwnProperty.call(ovNow,'regEdited') ? !!ovNow.regEdited : true) : false;
          const starOt  = ovNow ? (Object.prototype.hasOwnProperty.call(ovNow,'otEdited')  ? !!ovNow.otEdited  : true) : false;
          if (regCell) regCell.textContent = regVal.toFixed(2) + (starReg ? ' *' : '');
          if (otCell)  otCell.textContent  = otVal.toFixed(2) + (starOt ? ' *' : '');
          btn.textContent = 'Edit';
          recomputeDtrSummaryFromTable();
        }
      });
      td.appendChild(btn);
      tr.appendChild(td);
    });
  }

  function afterRender(){
    applyOverridesToTable();
    addDtrEditorButtons();
    recomputeDtrSummaryFromTable();
  }

  function patchOnce(){
    if (window.__DTR_EDITOR_PATCHED) return;
    window.__DTR_EDITOR_PATCHED = true;
    const orig = window.renderResults;
    if (typeof orig === 'function'){
      window.renderResults = function(){
        const out = orig.apply(this, arguments);
        try { afterRender(); } catch(e){}
        return out;
      };
    }
    document.addEventListener('DOMContentLoaded', afterRender);
  }

  patchOnce();
})();
</script>

<script>
// === Reports: match last date (RWH & OTH) width to the common RWH width of other dates ===
(function(){
  function getTable(){
    const host = document.getElementById('r_table');
    return host ? (host.tagName.toLowerCase()==='table' ? host : host.querySelector('table')) : null;
  }
  function bottomHeader(t){ return t && t.tHead ? t.tHead.rows[t.tHead.rows.length-1] : null; }
  function lastPairIdx(t){
    const row = bottomHeader(t); if (!row) return null;
    const ths = Array.from(row.cells);
    let rwh = -1, oth = -1;
    for (let i = ths.length-1; i >= 0; i--){
      const txt = (ths[i].textContent||'').trim().toUpperCase();
      if (oth === -1 && txt === 'OTH'){ oth = i; continue; }
      if (oth !== -1 && txt === 'RWH'){ rwh = i; break; }
    }
    return (rwh !== -1 && oth !== -1) ? {rwh, oth, ths} : null;
  }
  function modeWidth(numbers){
    const map = new Map();
    numbers.forEach(v=>{ map.set(Math.round(v), (map.get(Math.round(v))||0)+1); });
    let best=0, bestCount=-1;
    map.forEach((c, w)=>{ if (c>bestCount){ best=w; bestCount=c; } });
    return best||90;
  }
  function computeRefWidth(t, idx){
    const row = bottomHeader(t); const ths = Array.from(row.cells);
    const widths = [];
    for (let i=0;i<ths.length;i++){
      const txt = (ths[i].textContent||'').trim().toUpperCase();
      if (txt === 'RWH' && i !== idx.rwh){
        widths.push(ths[i].getBoundingClientRect().width);
      }
    }
    if (!widths.length){
      for (let i=0;i<ths.length;i++){
        const txt = (ths[i].textContent||'').trim().toUpperCase();
        if (txt === 'OTH' && i !== idx.oth){
          widths.push(ths[i].getBoundingClientRect().width);
        }
      }
    }
    return modeWidth(widths);
  }
  function classCols(t, idx, cls){
    // add class to header and all body cells at the given column index
    const row = bottomHeader(t);
    if (row && row.cells[idx]) row.cells[idx].classList.add(cls);
    if (t.tBodies && t.tBodies.length){
      for (const tr of Array.from(t.tBodies[0].rows)){
        if (tr.cells[idx]) tr.cells[idx].classList.add(cls);
      }
    }
  }
  function apply(){
    const t = getTable(); if (!t) return false;
    const pair = lastPairIdx(t); if (!pair) return false;
    const w = computeRefWidth(t, pair);

    // ensure a style root with CSS var
    let style = document.getElementById('__match_last_pair_style');
    if (!style){
      style = document.createElement('style');
      style.id = '__match_last_pair_style';
      style.textContent = `
        :root { --LAST_PAIR_W: ${w}px; }
        #r_table { table-layout: fixed; }
        #r_table .__lastR, #r_table .__lastO {
          width: var(--LAST_PAIR_W) !important;
          min-width: var(--LAST_PAIR_W) !important;
          max-width: var(--LAST_PAIR_W) !important;
          box-sizing: border-box;
          white-space: nowrap;
          text-align: center;
          padding-left: 8px; padding-right: 8px;
        }
        #r_table .__lastR > *, #r_table .__lastO > * {
          display:block; max-width:100%; overflow:hidden;
        }
      `;
      document.head.appendChild(style);
    } else {
      style.textContent = style.textContent.replace(/--LAST_PAIR_W:\s*\d+px/, `--LAST_PAIR_W: ${w}px`);
    }

    // mark both columns with classes
    classCols(t, pair.rwh, '__lastR');
    classCols(t, pair.oth, '__lastO');

    // also set parent header colspan cell width to 2*ref
    if (t.tHead && t.tHead.rows.length >= 2){
      const top = t.tHead.rows[t.tHead.rows.length-2];
      let cur = 0;
      for (const th of Array.from(top.cells)){
        const span = Number(th.getAttribute('colspan')||1);
        if (cur <= pair.rwh && pair.oth < cur + span){
          th.style.width = (w*2) + 'px';
          th.style.minWidth = (w*2) + 'px';
          th.style.maxWidth = (w*2) + 'px';
          th.style.boxSizing = 'border-box';
          break;
        }
        cur += span;
      }
    }
    return true;
  }
  function init(){
    let tries = 0;
    const timer = setInterval(()=>{ tries++; if (apply()) clearInterval(timer); if (tries>80) clearInterval(timer); }, 200);
    try{ new MutationObserver(apply).observe(document.body, {childList:true, subtree:true}); }catch(e){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
// === END ===
</script>

<script>
(function(){
  function applyReportSizing(){ /* disabled: CSS handles widths to avoid twitch */ }

  // Apply after build and on any changes
  function initSizingObserver(){ /* no-op; observers removed to prevent jitter */ }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initSizingObserver);
  } else {
    initSizingObserver();
  }
})();
</script>

<script>
(function(){
  function forcePersonnel150(){ /* disabled: using CSS constraints for first column */ }
  function init(){
    var tbl = document.getElementById('r_table');
    if(!tbl) return;
    // no observers; width handled by CSS
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>

<script>
(function(){
  function applyTotalsWidth100(){ /* disabled: CSS handles totals columns */ }
  function init(){
    var tbl = document.getElementById('r_table');
    if(!tbl) return;
    // no observers; widths handled by CSS
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>

<script>
// Clean Reports Print: opens a minimal window with just the reports table.
// Note: Browser header/footer (date, title, URL) are controlled by the print dialog.
// To remove them entirely, uncheck "Headers and footers" in the print settings.
(function(){
  function printReportsClean(){
    try{
      var tbl = document.getElementById('r_table');
      if (!tbl) return;
      var hint = document.getElementById('r_range_hint');
      var css = `
        <style>
          html,body{margin:0;padding:10px;font-family:Arial,Helvetica,sans-serif}
          *{-webkit-print-color-adjust:exact;print-color-adjust:exact}
          h3{margin:0 0 8px 0}
          .proj-title{font-weight:700;font-size:14px;margin:10px 0 6px 0}
          table{width:100%;border-collapse:collapse;font-size:12px;table-layout:fixed}
          table, th, td{border:0.6pt solid #000 !important}
          th,td{padding:4px 6px;vertical-align:middle}
          th{background:#f1f5f9;text-align:left}
          thead{display:table-header-group}
          .left{text-align:left}
          .num{text-align:right}
          .proj-block{page-break-after:always}
          /* First column fixed width with ellipsis, no wrap */
          table th:first-child, table td:first-child{
            width:170px !important; min-width:170px !important; max-width:170px !important;
            white-space:nowrap !important; overflow:hidden; text-overflow:ellipsis;
            word-break: keep-all; overflow-wrap: normal; hyphens: none;
          }
          table th:first-child *, table td:first-child *{ white-space:nowrap !important; }
          /* Make RATE compact to leave more room for names */
          table th:nth-child(2), table td:nth-child(2){
            width:70px; min-width:70px; max-width:80px; white-space:nowrap;
          }
          /* First header row date-group cells (colspan=2 each) => 80px */
          thead tr:first-child th:nth-child(n+3):not(:nth-last-child(-n+4)){
            width: 80px; min-width: 80px; max-width: 80px; white-space: nowrap;
          }
          /* Uniform date column widths (RWH/OTH pairs), exclude the last 4 total columns */
          thead tr:nth-child(2) th:not(:nth-last-child(-n+4)){
            width: 40px; min-width: 40px; max-width: 40px; white-space: nowrap;
          }
          tbody td:nth-child(n+3):not(:nth-last-child(-n+4)){
            width: 40px; min-width: 40px; max-width: 40px; white-space: nowrap;
          }
          /* Totals column widths: Total Reg Hrs, Total OT Hrs, Grand Total Hours, Gross */
          thead tr:nth-child(2) th:nth-last-child(4),
          tbody td:nth-last-child(4){ width: 90px; min-width: 90px; max-width: 100px; white-space: nowrap; }
          thead tr:nth-child(2) th:nth-last-child(3),
          tbody td:nth-last-child(3){ width: 90px; min-width: 90px; max-width: 100px; white-space: nowrap; }
          thead tr:nth-child(2) th:nth-last-child(2),
          tbody td:nth-last-child(2){ width: 120px; min-width: 120px; max-width: 140px; white-space: nowrap; }
          thead tr:nth-child(2) th:nth-last-child(1),
          tbody td:nth-last-child(1){ width: 110px; min-width: 110px; max-width: 120px; white-space: nowrap; }
          @media print{ @page { margin: 10mm; } }
        </style>`;

      // Build per-project sections with clear headers (strip inline widths)
      var headHTML = '';
      if (tbl.tHead) {
        try{
          var headClone = tbl.tHead.cloneNode(true);
          headClone.querySelectorAll('th,td').forEach(function(el){ el.removeAttribute('style'); });
          // Force first column (PERSONNEL) to fixed 170px and no-wrap in print
          try {
            headClone.querySelectorAll('tr th:first-child').forEach(function(th){
              th.style.width = '170px';
              th.style.minWidth = '170px';
              th.style.maxWidth = '170px';
              th.style.whiteSpace = 'nowrap';
              th.style.overflow = 'hidden';
              th.style.textOverflow = 'ellipsis';
              th.style.wordBreak = 'keep-all';
              th.style.overflowWrap = 'normal';
              th.style.hyphens = 'none';
            });
          } catch(_e) {}
          headHTML = headClone.innerHTML;
        }catch(e){ headHTML = tbl.tHead.innerHTML; }
      }
      var bodies = tbl.querySelectorAll('tbody.proj-page');
      var blocks = '';
      bodies.forEach(function(tb){
        try{
          var projName = (tb.querySelector('.proj-break td')?.textContent || 'Project').trim();
          var clone = tb.cloneNode(true);
          // Remove inline styles from cells to avoid overriding print CSS
          try{ clone.querySelectorAll('th,td').forEach(function(el){ el.removeAttribute('style'); }); }catch(_){ }
          // Enforce first column width and no-wrap inline to survive print engine quirks
          try{
            clone.querySelectorAll('tr > td:first-child').forEach(function(td){
              if (td && !td.hasAttribute('colspan')){
                td.style.width = '170px';
                td.style.minWidth = '170px';
                td.style.maxWidth = '170px';
                td.style.whiteSpace = 'nowrap';
                td.style.overflow = 'hidden';
                td.style.textOverflow = 'ellipsis';
                td.style.wordBreak = 'keep-all';
                td.style.overflowWrap = 'normal';
                td.style.hyphens = 'none';
              }
            });
          }catch(_e){}
          var first = clone.querySelector('.proj-break');
          if (first) first.parentNode.removeChild(first);
          blocks += '<div class="proj-block">' +
                    '<div class="proj-title">Project: ' + projName + (hint ? ' — ' + (hint.textContent||'') : '') + '</div>' +
                    '<table><thead>' + headHTML + '</thead><tbody>' + clone.innerHTML + '</tbody></table>' +
                   '</div>';
        }catch(e){}
      });
      if (!blocks) { blocks = '<div>No project data to print.</div>'; }
      var html = '<!doctype html><html><head><meta charset="utf-8">' + css + '</head><body>' + blocks + '</body></html>';
      var w = window.open('', '', 'width=1024,height=768');
      if (!w) return;
      w.document.open();
      w.document.write(html);
      // Set a blank title to avoid printing the original long page title in some browsers
      try{ w.document.title = ' '; }catch(e){}
      w.document.close();
      w.focus();
      setTimeout(function(){ try{ safePrint(w); }catch(e){} }, 0);
    }catch(e){ console.warn('Clean print failed', e); }
  }

  function attach(){
    var btn = document.getElementById('r_print');
    if (!btn || btn.__cleanPrint) return;
    btn.addEventListener('click', function(ev){ ev.preventDefault(); printReportsClean(); });
    btn.__cleanPrint = true;
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', attach, {once:true}); }
  else { attach(); }
})();
</script>

<script>
(function(){
  function applyGrandAndGross(){ /* disabled: handled via CSS to avoid twitch */ }
  function init(){
    var tbl = document.getElementById('r_table');
    if(!tbl) return;
    // widths handled by CSS; no observers to prevent layout jitter
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>
<!-- Remove Payroll backup/test/restore/health UI -->
<style>
  #backupNowBtn,
  #testRestoreBtn,
  #restoreBundleBtn,
  #healthCheckBtn,
  #backupLog,
  #backupStatus { display: none !important; }
  /* Also hide the extra spacing wrapper if left behind */
  #panelPayroll header > div:has(#backupNowBtn) { display: none !important; }
</style>
<script>
  (function(){
    function removeBackupUI(){
      try {
        var btn = document.getElementById('backupNowBtn');
        if (btn && btn.parentElement) { btn.parentElement.remove(); }
        var log = document.getElementById('backupLog'); if (log) log.remove();
      } catch(e){}
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', removeBackupUI, { once:true });
    } else {
      removeBackupUI();
    }
  })();
  </script>

<script>
// Auto-update "Total Hours" (Reg + OT) using lightweight event hooks
(function(){
  function findColIdxByHeader(tbl, text){
    if (!tbl) return -1;
    const ths = tbl.querySelectorAll('thead th');
    for (let i=0;i<ths.length;i++){
      const t = (ths[i].textContent||'').trim().toLowerCase();
      if (t === String(text||'').toLowerCase()) return i;
    }
    return -1;
  }
  function num(x){
    const n = parseFloat(String(x==null?'':x).replace(/[^0-9.\-]/g,''));
    return isNaN(n) ? 0 : n;
  }
  function computeTotalHoursForTable(){
    const tbl = document.getElementById('resultsTable');
    if (!tbl) return;
    const regIdx = findColIdxByHeader(tbl, 'Regular Hrs') || findColIdxByHeader(tbl, 'Total Regular Hrs');
    const otIdx  = findColIdxByHeader(tbl, 'OT Hrs');
    const totIdx = findColIdxByHeader(tbl, 'Total Hours');
    if (regIdx < 0 || otIdx < 0 || totIdx < 0) return;
    const rows = tbl.tBodies && tbl.tBodies[0] ? Array.from(tbl.tBodies[0].rows) : [];
    for (const tr of rows){
      const regCell = tr.cells[regIdx];
      const otCell  = tr.cells[otIdx];
      const totCell = tr.cells[totIdx];
      if (!regCell || !otCell || !totCell) continue;
      const reg = num(regCell.textContent);
      const ot  = num(otCell.textContent);
      totCell.textContent = (reg + ot).toFixed(2);
    }
  }
  function hookTable(){
    const tbl = document.getElementById('resultsTable');
    if (!tbl) return;
    const run = () => { try{ computeTotalHoursForTable(); }catch(e){} };
    // Also watch DOM changes (rows re-rendered after edits) and recompute
    const tbody = tbl.tBodies && tbl.tBodies[0];
    if (tbody) {
      let t = null;
      const obs = new MutationObserver(() => {
        if (t) clearTimeout(t);
        t = setTimeout(run, 0); // micro-debounce
      });
      obs.observe(tbody, { childList: true, subtree: true, characterData: true });
      // save ref
      window.__dtrTotalsObserver = obs;
    }

    // Recompute on typical edit signals
    ['input','change','keyup'].forEach(evt => tbl.addEventListener(evt, run, true));
    // Also expose a manual trigger for existing code paths
    window.computeTotalHoursForTable = computeTotalHoursForTable;
    // First run
    run();
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', hookTable);
  } else {
    hookTable();
  }
})();
</script>

<script>
// ---- Unified visible-rows totals & footer sync (applied) ----
(function(){
  function norm(s){ return String(s||'').trim().toLowerCase(); }
  function num(txt){
    var v = parseFloat(String(txt==null?'':txt).replace(/[^0-9.\-]/g,''));
    return isNaN(v) ? 0 : v;
  }
  function findColIndex(ths, labelOrFn){
    for (var i=0;i<ths.length;i++){
      var t = norm(ths[i].textContent);
      if (typeof labelOrFn === 'function'){ if (labelOrFn(t)) return i; }
      else if (t === norm(labelOrFn)) return i;
    }
    return -1;
  }
  function computeVisibleTotals(){
    var tbl = document.getElementById('resultsTable');
    if (!tbl || !tbl.tBodies || !tbl.tBodies[0]) return null;
    var ths = tbl.querySelectorAll('thead th');
    var idIdx  = findColIndex(ths, 'id');
    var regIdx = findColIndex(ths, function(t){ return t==='regular hrs' || t==='total regular hrs'; });
    var otIdx  = findColIndex(ths, 'ot hrs');
    var totIdx = findColIndex(ths, 'total hours');
    var rows = Array.from(tbl.tBodies[0].rows||[]);
    var reg=0, ot=0, tot=0;
    var seen = new Set();
    for (var r=0; r<rows.length; r++){
      var tr = rows[r];
      var style = window.getComputedStyle(tr);
      if (tr.offsetParent===null || style.display==='none' || style.visibility==='hidden') continue;
      if (regIdx>=0) reg += num(tr.cells[regIdx] && tr.cells[regIdx].textContent);
      if (otIdx>=0)  ot  += num(tr.cells[otIdx] && tr.cells[otIdx].textContent);
      if (totIdx>=0) tot += num(tr.cells[totIdx] && tr.cells[totIdx].textContent);
      if (idIdx>=0){
        var idtxt = String(tr.cells[idIdx] && tr.cells[idIdx].textContent || '').trim();
        if (idtxt) seen.add(idtxt);
      }
    }
    if (totIdx<0) tot = reg + ot;
    return { reg: reg, ot: ot, tot: tot, emp: seen.size, regIdx, otIdx, totIdx, idIdx, ths: ths };
  }
  function rebuildDtrFooter(){
    var tbl = document.getElementById('resultsTable');
    if (!tbl) return;
    var res = computeVisibleTotals();
    if (!res) return;
    var foot = tbl.querySelector('tfoot#resultsFoot');
    if (!foot){
      foot = document.createElement('tfoot');
      foot.id = 'resultsFoot';
      tbl.appendChild(foot);
    }
    var cols = res.ths.length;
    var tr = document.createElement('tr');
    tr.className = 'totals-row';
    for (var i=0;i<cols;i++){
      var td = document.createElement('td');
      td.style.fontWeight = '700';
      td.style.background = '#fafafa';
      var t = norm(res.ths[i].textContent);
      if (i===0) { td.textContent = 'Totals:'; td.style.textAlign='left'; }
      else if (t==='name') { td.textContent = 'Employees: ' + res.emp; }
      else if (i===res.regIdx) { td.textContent = formatHours(res.reg); td.style.textAlign='right'; }
      else if (i===res.otIdx)  { td.textContent = formatHours(res.ot);  td.style.textAlign='right'; }
      else if (i===res.totIdx) { td.textContent = formatHours(res.tot || (res.reg+res.ot)); td.style.textAlign='right'; }
      else if (t==='split' || t==='actions') { td.style.display='none'; td.style.border='0'; }
      else { td.textContent = ''; }
      tr.appendChild(td);
    }
    foot.innerHTML = '';
    foot.appendChild(tr);
    var summaryEl = document.getElementById('dtrSummary');
    if (summaryEl){
      var grand = res.tot || (res.reg + res.ot);
      summaryEl.textContent = 'Grand Total Hours: ' + formatHours(grand) +
        ' | Regular Hours: ' + formatHours(res.reg) +
        ' | OT Hours: ' + formatHours(res.ot) +
        ' | Employees: ' + res.emp;
      summaryEl.style.display = '';
    }
  }
  window.computeVisibleTotals = computeVisibleTotals;
  window.rebuildDtrFooter = rebuildDtrFooter;
  function hook(){
    rebuildDtrFooter();
    var tbl = document.getElementById('resultsTable');
    if (!tbl || !tbl.tBodies || !tbl.tBodies[0]) return;
    var tbody = tbl.tBodies[0];
    var run = function(){ try{ rebuildDtrFooter(); }catch(e){} };
    ['input','change','keyup'].forEach(function(evt){ tbody.addEventListener(evt, run, true); });
    var obs = new MutationObserver(function(){ run(); });
    obs.observe(tbody, { childList:true, subtree:true, characterData:true });
    window.__dtrFooterObserver = obs;
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', hook);
  else hook();
  if (typeof window.renderResults === 'function'){
    var _origRR = window.renderResults;
    window.renderResults = function(){ var r = _origRR.apply(this, arguments); try{ rebuildDtrFooter(); }catch(e){} return r; };
  }
  if (typeof window.calculateAll === 'function'){
    var _origCA = window.calculateAll;
    window.calculateAll = function(){ var r = _origCA.apply(this, arguments); try{ rebuildDtrFooter(); }catch(e){} return r; };
  }
})();
</script>
</body>
<script>
// === CalculateAll Scheduler: coalesce multiple calls per frame ===
(function(){
  try {
    if (window.calculateAll && !window.calculateAll.__scheduledWrapped) {
      const orig = window.calculateAll;
      let scheduled = false;
      function run(){
        scheduled = false;
        try { orig(); } catch(e) { console.warn('calculateAll error', e); }
      }
      const wrap = function(){
        if (scheduled) return;
        scheduled = true;
        (window.requestAnimationFrame || setTimeout)(run, 0);
      };
      wrap.__scheduledWrapped = true;
      window.calculateAll = wrap;
    }
  } catch(e) { /* no-op */ }
})();

// === Deductions render: skip work when hidden; defer to original builder when visible ===
(function(){
  function isDeductionsVisible(){
    const el = document.getElementById('deductionsTab');
    return !!(el && el.classList && el.classList.contains('active'));
  }
  try {
    const orig = window.renderDeductionsTable;
    if (typeof orig === 'function' && !orig.__perfWrapped) {
      const optimized = function(){
        if (!isDeductionsVisible()) { window.__deductionsDirty = true; return; }
        window.__deductionsDirty = false;
        let result;
        try {
          result = orig.apply(this, arguments);
        } catch (e) {
          console.warn('renderDeductionsTable fallback', e);
          try { result = orig.apply(this, arguments); } catch (_) { return; }
        }
        try { (window.scheduleTotals||window.updateDeductionsGrandTotals||function(){})(); } catch(e){}
        return result;
      };
      optimized.__perfWrapped = true;
      window.renderDeductionsTable = optimized;
    }
  } catch(e) { /* no-op */ }
  // Render pending deductions when its tab becomes active
  document.addEventListener('click', function(ev){
    const btn = ev.target && ev.target.closest && ev.target.closest('#panelPayroll .tabs .tab-btn');
    if (btn && btn.dataset && btn.dataset.tab === 'deductionsTab'){
      if (!window.__deductionsDirty || typeof window.renderDeductionsTable !== 'function') return;
      const schedule = window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(cb){ return setTimeout(cb, 0); };
      schedule(function(){
        if (window.__deductionsDirty && typeof window.renderDeductionsTable === 'function' && isDeductionsVisible()){
          try { window.renderDeductionsTable(); } catch(e){}
        }
      });
    }
  });
})();
</script>
<script>
// === RenderResults Scheduler: coalesce rapid calls into one per frame ===
(function(){
  try {
    if (window.renderResults && !window.renderResults.__scheduledWrapped) {
      const orig = window.renderResults;
      let scheduled = false;
      function run(){
        scheduled = false;
        try { orig(); } catch(e) { console.warn('renderResults error', e); }
      }
      const wrap = function(){
        if (scheduled) return;
        scheduled = true;
        (window.requestAnimationFrame || setTimeout)(run, 0);
      };
      wrap.__scheduledWrapped = true;
      window.renderResults = wrap;
    }
  } catch(e) { /* no-op */ }
})();
</script>
<script>
// Minimal lock handler: reuse freeze helpers instead of serializing snapshots.
(function(){
  function getPeriod(){
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    return {
      start: ws && ws.value ? ws.value : '',
      end: we && we.value ? we.value : ''
    };
  }
  function isLocked(){
    try { if (typeof isSelectedPeriodLocked === 'function') return !!isSelectedPeriodLocked(); }
    catch (err) {}
    return false;
  }
  async function lockPeriod(){
    try {
      if (typeof window.lockCurrentPeriod === 'function') {
        await Promise.resolve(window.lockCurrentPeriod());
      }
    } catch (err) {
      console.warn('lockPeriod failed', err);
    }
  }
  async function unlockPeriod(){
    try {
      if (typeof window.unlockCurrentPeriod === 'function') {
        await Promise.resolve(window.unlockCurrentPeriod());
      }
    } catch (err) {
      console.warn('unlockPeriod failed', err);
    }
  }
  const ALLOW_WHEN_LOCKED = new Set([
    'renderResults',          // Needed to display the DTR grid while locked
    'rebuildReports',         // Allows read-only report refreshes
    'renderProjectTotals',    // Keeps project totals visible
    'renderMasterReport',     // Ensures master report tab still renders
    'renderTable',            // Employees tab
    'renderDeductionsTable'   // Deductions tab
  ]);

  function guard(name){
    try {
      const fn = window[name];
      if (typeof fn !== 'function' || fn.__guarded) return;
      const wrapped = function(){
        if (isLocked() && !ALLOW_WHEN_LOCKED.has(name)) return;
        return fn.apply(this, arguments);
      };
      wrapped.__guarded = true;
      window[name] = wrapped;
    } catch (err) {}
  }
  ['renderResults','calculatePayrollFromResultsTable','calculatePayrollFromRecords','rebuildReports','renderProjectTotals','renderMasterReport','calculateAll','renderTable','renderDeductionsTable'].forEach(guard);
  document.addEventListener('DOMContentLoaded', function(){
    document.addEventListener('click', function(ev){
      const t = ev.target;
      if (!t) return;
    }, true);

    try {
      if (isLocked()) {
        if (typeof window.checkAndToggleEditState === 'function') window.checkAndToggleEditState();
      } else if (typeof window.applyPayrollLockUI === 'function') {
        window.applyPayrollLockUI(false);
      }
    } catch (err) {}

    try {
      var tp = document.getElementById('tabPayroll');
      var tp2 = document.getElementById('old-tabPayroll');
      function onOpenPayroll(){
        try {
          if (isLocked() && typeof window.checkAndToggleEditState === 'function') {
            window.checkAndToggleEditState();
          }
        } catch (e) {}
      }
      if (tp && !tp.__lockBind){ tp.addEventListener('click', onOpenPayroll); tp.__lockBind = true; }
      if (tp2 && !tp2.__lockBind){ tp2.addEventListener('click', onOpenPayroll); tp2.__lockBind = true; }
    } catch (e) {}

    var __lockStableAt = 0;
    function markPeriodChanged(){ try { __lockStableAt = Date.now() + 250; } catch(e){} }
    function isStable(){ try { return Date.now() >= __lockStableAt; } catch(e){ return true; } }
    try {
      var _isLocked = isLocked;
      isLocked = function(){ if (!isStable()) return false; return _isLocked(); };
    } catch (e) {}
    function scheduleUiReeval(){
      setTimeout(function(){
        try {
          if (typeof window.checkAndToggleEditState === 'function') window.checkAndToggleEditState();
        } catch (e) {}
      }, 260);
    }
    try { var ws = document.getElementById('weekStart'); if (ws && !ws.__lockBind){ ws.addEventListener('change', function(){ markPeriodChanged(); scheduleUiReeval(); }); ws.__lockBind = true; } } catch(e){}
    try { var we = document.getElementById('weekEnd'); if (we && !we.__lockBind){ we.addEventListener('change', function(){ markPeriodChanged(); scheduleUiReeval(); }); we.__lockBind = true; } } catch(e){}
    try { var sel = document.getElementById('activePayrollSelect'); if (sel && !sel.__lockBind){ sel.addEventListener('change', function(){ markPeriodChanged(); scheduleUiReeval(); }); sel.__lockBind = true; } } catch(e){}
  });
  try { window.lockPeriod = lockPeriod; window.unlockPeriod = unlockPeriod; } catch (err) {}
})();
// Toggle Payroll table inputs read-only state based on lock
function setPayrollLockedUI(locked){
  try {
    // 1) Toggle form controls (inputs only) inside Payroll panel; leave tab buttons enabled
    var panel = document.getElementById('panelPayroll');
    if (panel){
      var inputs = panel.querySelectorAll('input, select, textarea');
      inputs.forEach(function(el){ el.disabled = !!locked; });
      // Explicitly disable file-import fields when locked
      if (locked){
        panel.querySelectorAll('#importSss').forEach(function(el){ el.disabled = true; });
      }
    }
    // 2) Also toggle just the payroll grid controls for safety
    document.querySelectorAll('#payrollTable input, #payrollTable select, #payrollTable textarea').forEach(function(el){ el.disabled = !!locked; });
    // 3) Re-assert on DOM mutations while locked (payroll table only)
    var tbl = document.getElementById('payrollTable');
    if (tbl){
      if (locked && !tbl.__lockObs){
        var mo = new MutationObserver(function(){ try { document.querySelectorAll('#payrollTable input, #payrollTable select, #payrollTable textarea').forEach(function(el){ el.disabled = true; }); } catch(e){} });
        mo.observe(tbl, { childList: true, subtree: true });
        tbl.__lockObs = mo;
      } else if (!locked && tbl.__lockObs){ try { tbl.__lockObs.disconnect(); } catch(e){}; tbl.__lockObs = null; }
    }
  } catch(e){}
}
</script>
<script>
// Normalize Deductions note: rename Column 8 label from Vale to Account in the help text.
document.addEventListener('DOMContentLoaded', function(){
  try{
    var note = document.querySelector('#deductionsTab .section.note');
    if (note && note.innerHTML && /Column\s*8:<\/strong>\s*Vale/i.test(note.innerHTML)){
      note.innerHTML = note.innerHTML.replace(/(Column\s*8:<\/strong>)\s*Vale/i, '$1 Account');
    }
  }catch(e){}
});
</script>
<script>
// Full-featured live-reload helper for development.
//
// Capabilities
// ------------
// * Prefers WebSocket push updates (configurable endpoint) for near-instant reloads.
// * Falls back to EventSource/SSE when WebSockets are unavailable.
// * Falls back again to polling HEAD requests so changes are still detected in simple setups.
// * Supports CSS hot-swapping without a full-page reload when the server notifies us which
//   files changed (payload: { type: 'refresh-css', files: ['app.css'] }).
// * Can be configured globally via window.__LIVE_RELOAD_CONFIG__ before this script loads.
//
// Minimal server contract
// -----------------------
//   WebSocket/SSE messages should be JSON encoded with a "type" field. Supported types:
//     { type: 'reload', reason?: 'optional message' }              -> location.reload()
//     { type: 'refresh-css', files?: ['relative/or/absolute.css'] } -> swap <link rel=stylesheet>
//
//   If you don't have a live-reload server, the polling fallback still works when the HTML file
//   is served via HTTP(S) and responds to HEAD requests with Last-Modified or ETag headers.
(function(){
  try {
    if (!/^https?:/i.test(window.location.protocol)) return; // Only when served over HTTP/S

    var host = (window.location && window.location.hostname) || '';
    var isLoopback = host === 'localhost' || host === '127.0.0.1' || host === '::1' || host === '[::1]';
    var isPrivateIp = /^10\./.test(host) || /^192\.168\./.test(host) || /^172\.(1[6-9]|2\d|3[0-1])\./.test(host);
    var isDevLike = isLoopback || isPrivateIp || /\.local(?:domain)?$/i.test(host) || /\.test$/i.test(host);
    if (!isDevLike) return; // Avoid connecting to live-reload endpoints on public hosts (e.g. GitHub Pages)

    var cfg = window.__LIVE_RELOAD_CONFIG__ || {};
    var logEnabled = !cfg.quiet;

    function log(){
      if (!logEnabled || !window.console) return;
      try {
        var args = Array.prototype.slice.call(arguments);
        args.unshift('[live-reload]');
        console.log.apply(console, args);
      } catch (e) {}
    }

    function reloadPage(reason){
      try {
        if (reason) log('Reloading:', reason);
        window.location.reload();
      } catch (e) {
        log('Reload failed', e);
      }
    }

    function refreshCss(files){
      try {
        var candidates = Array.prototype.slice.call(document.querySelectorAll('link[rel~="stylesheet"]'));
        if (!candidates.length) { reloadPage('stylesheet update'); return; }

        var normalized = null;
        if (Array.isArray(files) && files.length){
          normalized = files.map(function(file){
            try {
              var a = document.createElement('a');
              a.href = file;
              return a.href;
            } catch (err) {
              return file;
            }
          });
        }

        candidates.forEach(function(link){
          try {
            var hrefBase = link.href.split('?')[0];
            if (normalized && normalized.length) {
              var match = normalized.some(function(target){
                return target === link.href || target === hrefBase;
              });
              if (!match) return;
            }

            var clone = link.cloneNode(true);
            var cacheBust = 'lr=' + Date.now();
            clone.href = hrefBase + (hrefBase.indexOf('?') >= 0 ? '&' : '?') + cacheBust;
            clone.onload = function(){
              try { link.remove(); } catch (err) {}
            };
            clone.onerror = function(){
              try {
                clone.remove();
                reloadPage('stylesheet reload failed');
              } catch (err) {}
            };
            link.parentNode.insertBefore(clone, link.nextSibling);
          } catch (err) {}
        });
      } catch (e) {
        reloadPage('stylesheet refresh error');
      }
    }

    var pollUrl = cfg.pollUrl || window.location.href.split('#')[0];
    var pollIntervalMs = typeof cfg.pollIntervalMs === 'number' ? cfg.pollIntervalMs : 2000;
    var lastPollSignature = null;
    var pollTimer = null;

    function stopPolling(){
      if (pollTimer){
        try { window.clearTimeout(pollTimer); } catch (e) {}
        pollTimer = null;
      }
    }

    function schedulePoll(){
      stopPolling();
      try {
        pollTimer = window.setTimeout(checkForUpdate, pollIntervalMs);
      } catch (e) {}
    }

    function checkForUpdate(){
      try {
        if (!window.fetch) { schedulePoll(); return; }
        fetch(pollUrl, { method: 'HEAD', cache: 'no-store' })
          .then(function(resp){
            if (!resp || !resp.ok) { schedulePoll(); return; }
            var signature = resp.headers.get('last-modified') || resp.headers.get('etag');
            if (!signature) { schedulePoll(); return; }
            if (!lastPollSignature) {
              lastPollSignature = signature;
              schedulePoll();
              return;
            }
            if (signature !== lastPollSignature) {
              reloadPage('file change detected via polling');
            } else {
              schedulePoll();
            }
          })
          .catch(function(){ schedulePoll(); });
      } catch (e) {
        schedulePoll();
      }
    }

    function startPollingFallback(){
      log('Polling for changes every', pollIntervalMs + 'ms');
      schedulePoll();
    }

    var retryTimer = null;
    function scheduleRetry(nextFn){
      try {
        if (retryTimer) window.clearTimeout(retryTimer);
        retryTimer = window.setTimeout(nextFn, cfg.retryDelayMs || 3000);
      } catch (e) {
        try { nextFn(); } catch (err) {}
      }
    }

    function handleMessage(data){
      try {
        if (!data) return;
        var payload = typeof data === 'string' ? JSON.parse(data) : data;
        if (!payload || !payload.type) return;
        if (payload.type === 'reload') {
          reloadPage(payload.reason || 'server request');
        } else if (payload.type === 'refresh-css') {
          refreshCss(payload.files);
        }
      } catch (err) {
        log('Failed to process message', err);
      }
    }

    function startEventSource(){
      if (!window.EventSource) {
        startPollingFallback();
        return;
      }

      var esUrl = cfg.eventSourceUrl;
      if (!esUrl){
        var path = cfg.eventSourcePath || '/__live_reload/events';
        esUrl = window.location.origin + path;
      }

      log('Connecting to EventSource', esUrl);
      try {
        var es = new EventSource(esUrl);
        es.onmessage = function(evt){ handleMessage(evt && evt.data); };
        es.onerror = function(){
          log('EventSource error, falling back to polling');
          try { es.close(); } catch (e) {}
          startPollingFallback();
        };
      } catch (err) {
        log('EventSource setup failed, falling back to polling');
        startPollingFallback();
      }
    }

    function startWebSocket(){
      if (!window.WebSocket) {
        startEventSource();
        return;
      }

      var wsUrl = cfg.websocketUrl;
      if (!wsUrl){
        var wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        var wsPath = cfg.websocketPath || '/__live_reload';
        wsUrl = wsProto + '//' + window.location.host + wsPath;
      }

      log('Connecting to WebSocket', wsUrl);
      try {
        var ws = new WebSocket(wsUrl);
        ws.onopen = function(){ log('WebSocket connected'); };
        ws.onmessage = function(evt){ handleMessage(evt && evt.data); };
        ws.onerror = function(){ log('WebSocket error'); };
        ws.onclose = function(){
          log('WebSocket closed, retrying via EventSource');
          scheduleRetry(startEventSource);
        };
      } catch (err) {
        log('WebSocket setup failed, trying EventSource');
        startEventSource();
      }
    }

    startWebSocket();

    // Safety net: if neither WS nor SSE succeed within ~1s, ensure polling is running.
    try {
      window.setTimeout(function(){
        if (!lastPollSignature && !pollTimer) {
          startPollingFallback();
        }
      }, 1000);
    } catch (e) {}
  } catch (e) {}
})();
</script>
</html>
